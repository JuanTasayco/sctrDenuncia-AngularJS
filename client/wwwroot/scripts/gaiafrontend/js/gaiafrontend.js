(function (window) {

"use strict";

/*TODO: REVIEW*/
/*global angular */
angular.module('themeCtrl', [])
    /**
     * @doc-component controller
     * @name gaiafrontend.controller.themeCtrl
     * @description
     * The theme for the application is handled by this controller. It can be used as follows:
     *
     *  ```js
     *  <link rel="stylesheet" ng-controller="ThemeCtrl" ng-href="gaiafrontend/css/{{theme}}.css"/>
     *  ```
     *
     * See `Theme` and `ThemeInterceptor` for more info.
     *
     */
    .controller('ThemeCtrl', ['$scope', 'Theme',
        function($scope, Theme) {
            $scope.theme = Theme.get();
        }]);

/*global angular*/
angular.module('accordion', ['ui.bootstrap'])
    .run(['$templateCache', function ($templateCache) {
        $templateCache.put('template/accordion/accordion-group.html',
            '<div class=\"panel panel-default\">\n' +
            '  <div class=\"panel-heading\">\n' +
            '    <h4 class=\"panel-title\">\n' +
            '      <a href=\"javascript:void(0)\" tabindex=\"0\" class=\"accordion-toggle\" ng-click=\"toggleOpen()\" accordion-transclude=\"heading\">\n' +
            '       <span ng-class=\"{\'text-muted\': isDisabled}\">{{heading}}</span></a>\n' +
            '    </h4>\n' +
            '  </div>\n' +
            '  <div class=\"panel-collapse\" collapse=\"!isOpen\">\n' +
            '     <div class=\"panel-body\" ng-class=\"{\'accordion-disabled\': isDisabled}\" ng-transclude></div>\n' +
            '  </div>\n' +
            '</div>'
        );
    }]);

/*global angular, _*/
angular.module('bsDateParse', ['mgcrea.ngStrap'])
    .config(['$provide', function($provide) {

        function $dateParserDecorator($delegate, $locale, dateFilter) {
            var $dateParser = $delegate;

            function extendedDateParser(config) {
                var $dateParserInstance = $dateParser.apply(this, arguments),
                    defaults = {
                        format: 'shortDate',
                        strict: false
                    },
                    options = angular.extend({}, defaults, config),
                    regExpMap = {
                        'sss': '[0-9]{3}',
                        'ss': '[0-5][0-9]',
                        's': options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',
                        'mm': '[0-5][0-9]',
                        'm': options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',
                        'HH': '[01][0-9]|2[0-3]',
                        'H': options.strict ? '1?[0-9]|2[0-3]' : '[01]?[0-9]|2[0-3]',
                        'hh': '[0][1-9]|[1][012]',
                        'h': options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',
                        'a': 'AM|PM',
                        'EEEE': $locale.DATETIME_FORMATS.DAY.join('|'),
                        'EEE': $locale.DATETIME_FORMATS.SHORTDAY.join('|'),
                        'dd': '0[1-9]|[12][0-9]|3[01]',
                        'd': options.strict ? '[1-9]|[1-2][0-9]|3[01]' : '0?[1-9]|[1-2][0-9]|3[01]',
                        'MMMM': $locale.DATETIME_FORMATS.MONTH.join('|'),
                        'MMM': $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),
                        'MM': '0[1-9]|1[012]',
                        'M': options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',
                        'yyyy': '[1]{1}[0-9]{3}|[2]{1}[0-9]{3}',
                        'yy': '[0-9]{2}',
                        'y': options.strict ? '-?(0|[1-9][0-9]{0,3})' : '-?0*[0-9]{1,4}'
                    },
                    setFnMap = {
                        'sss': Date.prototype.setMilliseconds,
                        'ss': Date.prototype.setSeconds,
                        's': Date.prototype.setSeconds,
                        'mm': Date.prototype.setMinutes,
                        'm': Date.prototype.setMinutes,
                        'HH': Date.prototype.setHours,
                        'H': Date.prototype.setHours,
                        'hh': Date.prototype.setHours,
                        'h': Date.prototype.setHours,
                        'EEEE': angular.noop(),
                        'EEE': angular.noop(),
                        'dd': Date.prototype.setDate,
                        'd': Date.prototype.setDate,
                        'a': function(value) {
                            var hours = this.getHours() % 12;
                            return this.setHours(value.match(/pm/i) ? hours + 12 : hours);
                        },
                        'MMMM': function(value) {
                            return this.setMonth($locale.DATETIME_FORMATS.MONTH.indexOf(value));
                        },
                        'MMM': function(value) {
                            return this.setMonth($locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value));
                        },
                        'MM': function(value) {
                            return this.setMonth(1 * value - 1);
                        },
                        'M': function(value) {
                            return this.setMonth(1 * value - 1);
                        },
                        'yyyy': Date.prototype.setFullYear,
                        'yy': function(value) {
                            return this.setFullYear(2000 + 1 * value);
                        },
                        'y': Date.prototype.setFullYear
                    };
                function daysInMonth(month, year) {
                    switch (month) {
                    case 2:
                        return (year % 4 === 0 && year % 100) || year % 400 === 0 ? 29 : 28;
                    case 4:
                    case 6:
                    case 9:
                    case 11:
                        return 30;
                    default:
                        return 31;
                    }
                }

                function isValid(year, month, day, hours, minutes) {

                    if (angular.isDefined(hours) || angular.isDefined(minutes)) {
                        return +hours >= 0 && +hours <= 24 && +minutes >= 0 && +minutes <= 59;
                    } else {
                        return +month > 0 && +month <= 12 && +day > 0 && +day <= daysInMonth(+month, +year);
                    }
                }

                function escapeReservedSymbols(text) {
                    return text.replace(/\//g, '[\\/]').replace('/-/g', '[-]').replace(/\./g, '[.]').replace(/\\s/g, '[\\s]');
                }

                function regExpForFormat(format) {
                    var keys = Object.keys(regExpMap),
                        i,
                        re;

                    re = format;
                    // Abstract replaces to avoid collisions
                    for (i = 0; i < keys.length; i += 1) {
                        re = re.split(keys[i]).join('${' + i + '}');
                    }
                    // Replace abstracted values
                    for (i = 0; i < keys.length; i += 1) {
                        re = re.split('${' + i + '}').join('(' + regExpMap[keys[i]] + ')');
                    }
                    format = escapeReservedSymbols(format);

                    return new RegExp('^' + re + '$', ['i']);
                }

                function setMapForFormat(format) {
                    var keys = Object.keys(setFnMap),
                        i,
                        map = [],
                        sortedMap = [],
                        index,
                        clonedFormat = format; // Map to setFn
                    for (i = 0; i < keys.length; i += 1) {
                        if (format.split(keys[i]).length > 1) {
                            index = clonedFormat.search(keys[i]);
                            format = format.split(keys[i]).join('');
                            if (setFnMap[keys[i]]) {
                                map[index] = setFnMap[keys[i]];
                            }
                        }
                    }
                    // Sort result map
                    angular.forEach(map, function(v) {
                        // conditional required since angular.forEach broke around v1.2.21
                        // related pr: https://github.com/angular/angular.js/pull/8525
                        if (v) {
                            sortedMap.push(v);
                        }
                    });
                    return sortedMap;
                }

                function sortMatches(matches, format) {
                    var myMap = {
                            'y': 0,
                            'yy': 0,
                            'yyyy': 0,
                            'M': 1,
                            'MM': 1,
                            'MMM': 1,
                            'MMMM': 1,
                            'd': 2,
                            'dd': 2,
                            'h': 3,
                            'hh': 3,
                            'HH': 3,
                            'H': 3,
                            'mm': 4,
                            'm': 4
                        },
                        arr = [],
                        response = [],
                        found;

                    _.forEach(myMap, function(pos, key) {
                        found = format.search(key);

                        if (found > -1) {
                            arr.push({
                                pos: pos,
                                found: found
                            });
                        }
                    });

                    _.sortBy(_.uniq(arr, 'pos'), 'found').forEach(function(aux, index) {
                        response[aux.pos] = matches[index];
                    });

                    return response;
                }

                $dateParserInstance.parse = function(value, baseDate, format) {
                    var formatDate = $locale.DATETIME_FORMATS[options.format] || options.format,
                        formatRegex,
                        formatSetMap,
                        matches,
                        sortedMatches,
                        sortedFormatSetMap,
                        date = new Date(),
                        i;

                    if (angular.isDate(value)) {
                        value = dateFilter(value, format || formatDate);
                    }

                    formatRegex = format ? regExpForFormat(format) : regExpForFormat(formatDate);
                    formatSetMap = format ? setMapForFormat(format) : setMapForFormat(formatDate);
                    matches = formatRegex.exec(value);

                    sortedMatches = matches ? sortMatches(_.rest(angular.copy(matches)), formatDate) : matches;
                    sortedFormatSetMap = formatSetMap ? sortMatches(formatSetMap, formatDate) : formatSetMap;
                    matches = matches !== null && isValid(sortedMatches[0], sortedMatches[1], sortedMatches[2], sortedMatches[3], sortedMatches[4]) ? matches : null;


                    if (!matches) {
                        return false;
                    }

                    date = baseDate && !isNaN(baseDate.getTime()) ? baseDate : new Date();

                    //for (i = sortedMatches.length - 1; i >= 0; i -= 1) {
                    for (i = 0; i < sortedMatches.length; i++) {
                        if (sortedFormatSetMap[i]) {
                            sortedFormatSetMap[i].call(date, sortedMatches[i]);
                        }
                    }
                    return date;
                };

                return $dateParserInstance;
            }

            return extendedDateParser;
        }

        $dateParserDecorator.$inject = ['$delegate', '$locale', 'dateFilter'];

        $provide.decorator('$dateParser', $dateParserDecorator);
    }]);

/*global angular, _ */
angular.module('bsSelect', ['mgcrea.ngStrap'])
    .config(['$provide', function ($provide) {

        function $selectDecorator($delegate, $window, $timeout) {
            var $select = $delegate,
                isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent),
                isTouch = ('createTouch' in $window.document) && isNative;

            function newSelectFactory(element, controller, config) {
                var $selectInstance = $select.apply(this, arguments),
                    scope = $selectInstance.$scope,
                    options = angular.extend({}, $select.defaults, config),
                    _show = $selectInstance.show,
                    _hide = $selectInstance.hide,
                    stringToFind = '';

                scope.$selecting = function (index) {
                    return scope.$focusedIndex === index;
                }

                $selectInstance.$getIndex = function(value) {
                    var l = scope.$matches.length,
                        i = l;
                    if (!l) return;
                    for (i = l; i--;) {
                        if (_.isEqual(scope.$matches[i].value, value)) break;
                    }
                    if (i < 0) return;
                    return i;
                };

                function scrollOnKeyDown (element, keyPress) {
                    var itemHeight = element.find('li').outerHeight(),
                        dropdownHeight = $selectInstance.$element.height(),
                        currentItemTop = options.multiple ? scope.$focusedIndex * itemHeight : scope.$activeIndex * itemHeight,
                        minItemTopVisible = element.scrollTop(),
                        maxItemTopVisible = minItemTopVisible + dropdownHeight,
                        currentItemBottom = currentItemTop + itemHeight,
                        scrolling;

                    if (currentItemTop > minItemTopVisible && currentItemBottom < maxItemTopVisible) {
                        return;
                    } else if (keyPress === 38 && (currentItemBottom + dropdownHeight) > dropdownHeight) {
                        scrolling = currentItemBottom - itemHeight;
                    } else if (keyPress === 40 && dropdownHeight < currentItemBottom) {
                        scrolling = currentItemBottom - dropdownHeight;
                    }
                    element.scrollTop(scrolling);
                }

                $selectInstance.$onKeyDown = function(evt) {
                    if (evt.keyCode > 47 && evt.keyCode < 58 || evt.keyCode > 64 && evt.keyCode < 91 || evt.keyCode === 32) {
                        stringToFind += String.fromCharCode(evt.keyCode);
                        var arrElements = _.pluck(_.filter(scope.$matches, function(n) {return n}), 'label');
                        var indexToSelect = _.findIndex(arrElements, function(item) {
                          return item.toUpperCase().indexOf (stringToFind, 0) === 0;
                        });

                        if (indexToSelect !== -1){
                            $selectInstance.select(indexToSelect);
                            $selectInstance.show();
                        }

                        $timeout( function(){
                            stringToFind = '';
                        }, 1000);

                        return;
                    } else if (!/^(38|40|13|9)$/.test(evt.keyCode)){
                        return;
                    }

                    if ($selectInstance.$isVisible()) {
                        evt.preventDefault();
                        evt.stopPropagation();

                        $timeout(function () {
                            if (options.multiple) {
                                // Select with enter/tab
                                if (evt.keyCode === 13 || evt.keyCode === 9) {
                                    if (angular.isDefined(scope.$focusedIndex)) {
                                        if (evt.keyCode === 13) $selectInstance.select(scope.$focusedIndex);
                                        if (evt.keyCode === 9) $selectInstance.hide();
                                    } else {
                                        $selectInstance.hide();
                                    }
                                    return;
                                }

                                // Navigate with keyboard
                                if (evt.keyCode === 38) {
                                    if (angular.isUndefined(scope.$focusedIndex)) {
                                        scope.$focusedIndex = scope.$matches.length - 1;
                                        scrollOnKeyDown($selectInstance.$element, evt.keyCode);
                                    } else if (scope.$focusedIndex > 0) {
                                        scope.$focusedIndex--;
                                        scrollOnKeyDown($selectInstance.$element, evt.keyCode);
                                    }
                                } else if (evt.keyCode === 40) {
                                    if (angular.isUndefined(scope.$focusedIndex)) {
                                        scope.$focusedIndex = 0;
                                        scrollOnKeyDown($selectInstance.$element, evt.keyCode);
                                    } else if (scope.$focusedIndex < scope.$matches.length - 1) {
                                        scope.$focusedIndex++;
                                        scrollOnKeyDown($selectInstance.$element, evt.keyCode);
                                    }
                                }

                            } else {
                                // Select with enter/tab
                                if (evt.keyCode === 13) {
                                    return $selectInstance.select(scope.$activeIndex);
                                }
                                if (evt.keyCode === 9) {
                                    return $selectInstance.hide(true);
                                }
                                // Navigate with keyboard
                                if (evt.keyCode === 38 && scope.$activeIndex > 0) {
                                    scope.$activeIndex--;
                                    scrollOnKeyDown($selectInstance.$element, evt.keyCode);
                                } else if (evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) {
                                    scope.$activeIndex++;
                                    scrollOnKeyDown($selectInstance.$element, evt.keyCode);
                                } else if (angular.isUndefined(scope.$activeIndex)) scope.$activeIndex = 0;
                            }
                        });
                    }
                };

                $selectInstance.$onMouseDown = function(evt) {
                    if (angular.isDefined(scope.$focusedIndex)) scope.$focusedIndex = undefined;
                    // Prevent blur on mousedown on .dropdown-menu
                    if (!isTouch) {
                        evt.preventDefault();
                        evt.stopPropagation();
                    }
                };

                $selectInstance.$onClick = function (evt) {
                    evt.stopPropagation();
                };

                function hideOptions() {
                    $selectInstance.hide(true);
                }

                $selectInstance.show = function () {
                    //angular.element(document).on('click', hideOptions);
                    setTimeout(function () {
                        $selectInstance.$element.on('click', $selectInstance.$onClick);
                    });
                    _show();
                };

                $selectInstance.hide = function () {
                    angular.element(document).off('click', hideOptions);
                    $selectInstance.$element.off('click', $selectInstance.$onClick);
                    _hide(true);
                };

                $selectInstance.select = function(index) {
                    var value = scope.$matches[index].value;
                    scope.$apply(function() {
                        $selectInstance.activate(index);
                        if (options.multiple) {
                            controller.$setViewValue(scope.$activeIndex.map(function(index) {
                                return scope.$matches[index].value;
                            }));
                        } else if (scope.$activeIndex === 0 && scope.$matches[index].label.length === 0) {
                            controller.$setViewValue(scope.$matches[index].label);
                            controller.$modelValue = undefined;
                            $selectInstance.hide();
                        } else {
                            controller.$setViewValue(value);
                            // Hide if single select
                            $selectInstance.hide();
                        }
                    });
                    // Emit event
                    scope.$emit(options.prefixEvent + '.select', value, index);
                };

                return $selectInstance;
            }

            newSelectFactory.defaults = $select.defaults;
            newSelectFactory.defaults.minLength = 0;

            return newSelectFactory;
        }


        function $bsSelectDirectiveDecorator($delegate) {
            var bsSelectDirective = $delegate[0];

            // Force the element to be a <button> to avoid default directive support for <select> markup
            bsSelectDirective.replace = true;
            bsSelectDirective.template = '<button></button>';

            return $delegate;
        }

        $provide.decorator('$select', $selectDecorator);
        $provide.decorator('bsSelectDirective', $bsSelectDirectiveDecorator);
    }])
    // FIX Trello card: https://trello.com/c/wnrPJ4mi
    .run(['$templateCache', 'Utils', function ($templateCache, Utils) {
        if (Utils.platform.isIE8()) {
            $templateCache.put('select/select.tpl.html', '<ul tabindex="-1" class="select dropdown-menu" ng-show="$isVisible()" role="select"><li ng-if="$showAllNoneButtons"><div class="btn-group" style="margin-bottom: 5px; margin-left: 5px"><button class="btn btn-default btn-xs" ng-mousedown="$selectAll()">All</button> <button class="btn btn-default btn-xs" ng-mousedown="$selectNone()">None</button></div></li><li role="presentation" ng-repeat="match in $matches" ng-class="{active: $isActive($index), selecting: $selecting($index)}"><a style="cursor: default" role="menuitem" tabindex="-1" ng-mousedown="$select($index, $event)"><span ng-bind="match.label"></span> <i class="{{$iconCheckmark}} pull-right" ng-if="$isMultiple && $isActive($index) && $selecting($index)"></i></a></li></ul>');
        } else if (!Utils.platform.isTactile()) {
            $templateCache.put('select/select.tpl.html', '<ul tabindex="-1" class="select dropdown-menu" ng-show="$isVisible()" role="select"><li ng-if="$showAllNoneButtons"><div class="btn-group" style="margin-bottom: 5px; margin-left: 5px"><button class="btn btn-default btn-xs" ng-click="$selectAll()">All</button> <button class="btn btn-default btn-xs" ng-click="$selectNone()">None</button></div></li><li role="presentation" ng-repeat="match in $matches" ng-class="{active: $isActive($index), selecting: $selecting($index)}"><a style="cursor: default" role="menuitem" tabindex="-1" ng-click="$select($index, $event)"><span ng-bind="match.label"></span> <i class="{{$iconCheckmark}} pull-right" ng-if="$isMultiple && $isActive($index) && $selecting($index)"></i></a></li></ul>');
        }
    }]);

/*global angular */
angular.module('bsTimeDatepicker', ['mgcrea.ngStrap'])
    .config(['$provide', function($provide) {
        function $datePickerDecorator($delegate) {
            var $datepicker = $delegate;

            function newDatepickerFactory(element) {
                var $datepickerInstance = $datepicker.apply(this, arguments),
                    _show = $datepickerInstance.show,
                    _hide = $datepickerInstance.hide;

                function hideCalendar() {
                    $datepickerInstance.hide(true);
                }

                $datepickerInstance.show = function() {
                    _show();
                    angular.element(document).on('mousedown', hideCalendar);
                };

                $datepickerInstance.hide = function(blur) {
                    angular.element(document).off('mousedown', hideCalendar);
                    _hide(blur);
                };

                // Dirty trick/cheat to expose $datepicker instance
                element.data('$datepicker', $datepickerInstance);

                return $datepickerInstance;
            }

            newDatepickerFactory.defaults = $datepicker.defaults;
            return newDatepickerFactory;
        }

        function $timePickerDecorator($delegate) {
            var $timepicker = $delegate;

            function newTimepickerFactory(element) {
                var $timepickerInstance = $timepicker.apply(this, arguments),
                    _show = $timepickerInstance.show,
                    _hide = $timepickerInstance.hide;

                function hideTimer() {
                    $timepickerInstance.hide(true);
                }

                $timepickerInstance.show = function() {
                    _show();
                    setTimeout(function() {
                        angular.element(document).on('mousedown', hideTimer);
                    });
                };

                $timepickerInstance.hide = function(blur) {
                    angular.element(document).off('mousedown', hideTimer);
                    _hide(blur);
                };

                // Dirty trick/cheat to expose $timepicker instance
                element.data('$timepicker', $timepickerInstance);

                return $timepickerInstance;
            }

            newTimepickerFactory.defaults = $timepicker.defaults;
            return newTimepickerFactory;
        }

        $datePickerDecorator.$inject = ['$delegate', '$window'];
        $datePickerDecorator.$inject = ['$delegate', '$window'];

        $provide.decorator('$datepicker', $datePickerDecorator);
        $provide.decorator('$timepicker', $timePickerDecorator);
    }])
    // FIX Trello card: https://trello.com/c/TFNSkyAA
    .run(['$templateCache', function($templateCache) {
        $templateCache.put('datepicker/datepicker.tpl.html', '<div class="dropdown-menu datepicker" ng-class="\'datepicker-mode-\' + $mode" style="max-width: 320px"><table style="table-layout: fixed; height: 100%; width: 100%"><thead><tr class="text-center"><th><button tabindex="-1" type="button" class="btn btn-default pull-left" ng-click="$selectPane(-1)"><img src="gaiafrontend/img/chevron-left.png" style="width: 8px" /></button></th><th colspan="{{ rows[0].length - 2 }}"><button tabindex="-1" type="button" class="btn btn-default btn-block text-strong" ng-click="$toggleMode()"><strong style="text-transform: capitalize" ng-bind="title"></strong></button></th><th><button tabindex="-1" type="button" class="btn btn-default pull-right" ng-click="$selectPane(+1)"><img src="gaiafrontend/img/chevron-right.png" style="width: 8px" /></button></th></tr><tr ng-show="showLabels" ng-bind-html="labels"></tr></thead><tbody><tr ng-repeat="(i, row) in rows" height="{{ 100 / rows.length }}%"><td class="text-center" ng-repeat="(j, el) in row"><button tabindex="-1" type="button" class="btn btn-default" style="width: 100%" ng-class="{\'btn-primary\': el.selected, \'btn-info btn-today\': el.isToday}" ng-click="$select(el.date)" ng-disabled="el.disabled"><span ng-class="{\'text-muted\': el.muted}" ng-bind="el.label"></span></button></td></tr></tbody></table></div>');
    }])
    .run(['$templateCache', function($templateCache) {
        $templateCache.put('timepicker/timepicker.tpl.html', '<div class="dropdown-menu timepicker" style="min-width: 0px;width: auto"><table height="100%"><thead><tr class="text-center"><th><button tabindex="-1" type="button" class="btn btn-default pull-left" ng-click="$arrowAction(-1, 0)"><img src="gaiafrontend/img/flechaUp.png" style="width: 12px" /></button></th><th>&nbsp;</th><th><button tabindex="-1" type="button" class="btn btn-default pull-left" ng-click="$arrowAction(-1, 1)"><img src="gaiafrontend/img/flechaUp.png" style="width: 12px" /></button></th></tr></thead><tbody><tr ng-repeat="(i, row) in rows"><td class="text-center"><button tabindex="-1" style="width: 100%" type="button" class="btn btn-default" ng-class="{\'btn-primary\': row[0].selected}" ng-click="$select(row[0].date, 0)" ng-disabled="row[0].disabled"><span ng-class="{\'text-muted\': row[0].muted}" ng-bind="row[0].label"></span></button></td><td><span ng-bind="i == midIndex ? timeSeparator : \' \'"></span></td><td class="text-center"><button tabindex="-1" ng-if="row[1].date" style="width: 100%" type="button" class="btn btn-default" ng-class="{\'btn-primary\': row[1].selected}" ng-click="$select(row[1].date, 1)" ng-disabled="row[1].disabled"><span ng-class="{\'text-muted\': row[1].muted}" ng-bind="row[1].label"></span></button></td><td ng-if="showAM">&nbsp;</td><td ng-if="showAM"><button tabindex="-1" ng-show="i == midIndex - !isAM * 1" style="width: 100%" type="button" ng-class="{\'btn-primary\': !!isAM}" class="btn btn-default" ng-click="$switchMeridian()" ng-disabled="el.disabled">AM</button><button tabindex="-1" ng-show="i == midIndex + 1 - !isAM * 1" style="width: 100%" type="button" ng-class="{\'btn-primary\': !isAM}" class="btn btn-default" ng-click="$switchMeridian()" ng-disabled="el.disabled">PM</button></td></tr></tbody><tfoot><tr class="text-center"><th><button tabindex="-1" type="button" class="btn btn-default pull-left" ng-click="$arrowAction(1, 0)"><img src="gaiafrontend/img/flechaDown.png" style="width: 12px" /></i></button></th><th>&nbsp;</th><th><button tabindex="-1" type="button" class="btn btn-default pull-left" ng-click="$arrowAction(1, 1)"><img src="gaiafrontend/img/flechaDown.png" style="width: 12px" /></i></button></th></tr></tfoot></table></div>');
    }]);

/*global angular */
angular.module('bsTooltip', ['mgcrea.ngStrap'])
    .config(['$provide', function($provide) {
        var defaults = {
            animation: 'am-fade',
            customClass: '',
            prefixClass: 'tooltip',
            prefixEvent: 'tooltip',
            container: false,
            target: false,
            placement: 'top',
            template: 'tooltip/tooltip.tpl.html',
            contentTemplate: false,
            trigger: 'hover focus',
            keyboard: false,
            html: false,
            show: false,
            title: '',
            type: '',
            delay: 0
        };

        function $tooltipDecorator($delegate, $window, $rootScope, $compile, $q, $templateCache, $http, $animate, dimensions, $$rAF, Utils) {
            var trim = String.prototype.trim;
            var isTouch = 'createTouch' in $window.document;
            var htmlReplaceRegExp = /ng-bind="/ig;

            function TooltipFactory(element, config) {

                var $tooltip = {};

                // Common vars
                var nodeName = element[0].nodeName.toLowerCase();
                var options = $tooltip.$options = angular.extend({}, defaults, config);
                $tooltip.$promise = fetchTemplate(options.template);
                var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();
                if (options.delay && angular.isString(options.delay)) {
                    var split = options.delay.split(',').map(parseFloat);
                    options.delay = split.length > 1 ? {
                        show: split[0],
                        hide: split[1]
                    } : split[0];
                }

                // Support scope as string options
                if (options.title) {
                    $tooltip.$scope.title = options.title;
                }

                // Provide scope helpers
                scope.$hide = function() {
                    scope.$$postDigest(function() {
                        $tooltip.hide();
                    });
                };
                scope.$show = function() {
                    scope.$$postDigest(function() {
                        $tooltip.show();
                    });
                };
                scope.$toggle = function() {
                    scope.$$postDigest(function() {
                        $tooltip.toggle();
                    });
                };
                $tooltip.$isShown = scope.$isShown = false;

                // Private vars
                var timeout, hoverState;

                // Support contentTemplate option
                if (options.contentTemplate) {
                    $tooltip.$promise = $tooltip.$promise.then(function(template) {
                        var templateEl = angular.element(template);
                        return fetchTemplate(options.contentTemplate)
                            .then(function(contentTemplate) {
                                var contentEl = findElement('[ng-bind="content"]', templateEl[0]);
                                if (!contentEl.length) contentEl = findElement('[ng-bind="title"]', templateEl[0]);
                                contentEl.removeAttr('ng-bind').html(contentTemplate);
                                return templateEl[0].outerHTML;
                            });
                    });
                }

                // Fetch, compile then initialize tooltip
                var tipLinker, tipElement, tipTemplate, tipContainer;
                $tooltip.$promise.then(function(template) {
                    if (angular.isObject(template)) template = template.data;
                    if (options.html) template = template.replace(htmlReplaceRegExp, 'ng-bind-html="');
                    template = trim.apply(template);
                    tipTemplate = template;
                    tipLinker = $compile(template);
                    $tooltip.init();
                });

                $tooltip.init = function() {

                    // Options: delay
                    if (options.delay && angular.isNumber(options.delay)) {
                        options.delay = {
                            show: options.delay,
                            hide: options.delay
                        };
                    }

                    // Replace trigger on touch devices ?
                    // if(isTouch && options.trigger === defaults.trigger) {
                    //   options.trigger.replace(/hover/g, 'click');
                    // }

                    // Options : container
                    if (options.container === 'self') {
                        tipContainer = element;
                    } else if (angular.isElement(options.container)) {
                        tipContainer = options.container;
                    } else if (options.container) {
                        tipContainer = findElement(options.container);
                    }

                    // Options: trigger
                    var triggers = options.trigger.split(' ');
                    angular.forEach(triggers, function(trigger) {
                        if (trigger === 'click') {
                            element.on('click', $tooltip.toggle);
                        } else if (trigger !== 'manual') {
                            element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);
                            element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);
                            if (nodeName === 'button' && trigger !== 'hover') element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);
                        }
                    });

                    // Options: target
                    if (options.target) {
                        options.target = angular.isElement(options.target) ? options.target : findElement(options.target);
                    }

                    // Options: show
                    if (options.show) {
                        scope.$$postDigest(function() {
                            if (options.trigger === 'focus') {
                                element[0].focus();
                            } else {
                                $tooltip.show();
                            }
                        });
                    }

                };

                $tooltip.destroy = function() {

                    // Unbind events
                    var triggers = options.trigger.split(' ');
                    for (var i = triggers.length; i--;) {
                        var trigger = triggers[i];
                        if (trigger === 'click') {
                            element.off('click', $tooltip.toggle);
                        } else if (trigger !== 'manual') {
                            element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);
                            element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);
                            if (nodeName === 'button' && trigger !== 'hover') element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);
                        }
                    }

                    // Remove element
                    if (tipElement) {
                        tipElement.remove();
                        tipElement = null;
                    }

                    // Cancel pending callbacks
                    clearTimeout(timeout);

                    // Destroy scope
                    scope.$destroy();

                };

                $tooltip.enter = function() {

                    clearTimeout(timeout);
                    hoverState = 'in';
                    if (!options.delay || !options.delay.show) {
                        return $tooltip.show();
                    }

                    timeout = setTimeout(function() {
                        if (hoverState === 'in') $tooltip.show();
                    }, options.delay.show);

                };

                $tooltip.show = function() {

                    scope.$emit(options.prefixEvent + '.show.before', $tooltip);
                    var parent = options.container ? tipContainer : null;
                    var after = options.container ? null : element;

                    // Hide any existing tipElement
                    if (tipElement) tipElement.remove();
                    // Fetch a cloned element linked from template
                    tipElement = $tooltip.$element = tipLinker(scope, angular.noop);

                    // Set the initial positioning.  Make the tooltip invisible
                    // so IE doesn't try to focus on it off screen.
                    tipElement.css({
                        top: '-9999px',
                        left: '-9999px',
                        display: 'block',
                        visibility: 'hidden'
                    }).addClass(options.placement);

                    // Options: animation
                    if (options.animation) tipElement.addClass(options.animation);
                    // Options: type
                    if (options.type) tipElement.addClass(options.prefixClass + '-' + options.type);
                    // Options: custom classes
                    if (options.customClass) tipElement.addClass(options.customClass);

                    // Support v1.3+ $animate
                    // https://github.com/angular/angular.js/commit/bf0f5502b1bbfddc5cdd2f138efd9188b8c652a9
                    var promise = $animate.enter(tipElement, parent, after, enterAnimateCallback);
                    if (promise && promise.then) promise.then(enterAnimateCallback);

                    $tooltip.$isShown = scope.$isShown = true;
                    if (!(scope.$$phase || (scope.$root && scope.$root.$$phase))) scope.$digest();
                    $$rAF(function() {
                        $tooltip.$applyPlacement();

                        // Once placed, make the tooltip visible
                        tipElement.css({
                            visibility: 'visible'
                        });
                    }); // var a = bodyEl.offsetWidth + 1; ?

                    // Bind events
                    if (options.keyboard) {
                        if (options.trigger !== 'focus') {
                            $tooltip.focus();
                            tipElement.on('keyup', $tooltip.$onKeyUp);
                        } else {
                            element.on('keyup', $tooltip.$onFocusKeyUp);
                        }
                    }

                };

                function positionOfTooltip(element, tipElement) {
                    var elementPosition = element[0].getBoundingClientRect(),
                        heightWindow = Utils.platform.isIE8() ? angular.element(window).innerHeight() : window.innerHeight;

                    if (options.placement === 'bottom-left' && (elementPosition.top + element.outerHeight() + tipElement.outerHeight()) > heightWindow) {
                        return 'top-left'
                    }
                    return;
                }

                $tooltip.$applyPlacement = function() {
                    if (!tipElement) return;

                    // Returns the position of the tooltip on a space available
                    var placement = positionOfTooltip(element, tipElement);

                    // Get the position of the tooltip element.
                    var elementPosition = getPosition();

                    // Get the height and width of the tooltip so we can center it.
                    var tipWidth = tipElement.prop('offsetWidth'),
                        tipHeight = tipElement.prop('offsetHeight');

                    // Get the tooltip's top and left coordinates to center it with this directive.
                    var tipPosition = getCalculatedOffset(placement || options.placement, elementPosition, tipWidth, tipHeight);

                    // Now set the calculated positioning.
                    tipPosition.top += 'px';
                    tipPosition.left += 'px';
                    tipElement.css(tipPosition);

                };

                function enterAnimateCallback() {
                    scope.$emit(options.prefixEvent + '.show', $tooltip);
                }

                $tooltip.leave = function() {

                    clearTimeout(timeout);
                    hoverState = 'out';
                    if (!options.delay || !options.delay.hide) {
                        return $tooltip.hide();
                    }
                    timeout = setTimeout(function() {
                        if (hoverState === 'out') {
                            $tooltip.hide();
                        }
                    }, options.delay.hide);

                };

                $tooltip.hide = function() {

                    if (!$tooltip.$isShown) return;
                    scope.$emit(options.prefixEvent + '.hide.before', $tooltip);

                    // Support v1.3+ $animate
                    // https://github.com/angular/angular.js/commit/bf0f5502b1bbfddc5cdd2f138efd9188b8c652a9
                    var promise = $animate.leave(tipElement, leaveAnimateCallback);
                    if (promise && promise.then) promise.then(leaveAnimateCallback);

                    $tooltip.$isShown = scope.$isShown = false;
                    if (!(scope.$$phase || (scope.$root && scope.$root.$$phase))) scope.$digest();

                    // Unbind events
                    if (options.keyboard && tipElement !== null) {
                        tipElement.off('keyup', $tooltip.$onKeyUp);
                    }

                };

                function leaveAnimateCallback() {
                    scope.$emit(options.prefixEvent + '.hide', $tooltip);
                    // Allow to blur the input when hidden, like when pressing enter key
                    // if (blur && options.trigger === 'focus') {
                    //     return element[0].blur();
                    // }
                }

                $tooltip.toggle = function() {
                    if ($tooltip.$isShown) {
                        $tooltip.leave()
                    } else {
                        $tooltip.enter();
                    }
                };

                $tooltip.focus = function() {
                    angular.element(tipElement[0]).focus();
                };

                // Protected methods

                // $tooltip.$applyPlacement = function() {
                //     if (!tipElement) return;

                //     // Get the position of the tooltip element.
                //     var elementPosition = getPosition();

                //     // Get the height and width of the tooltip so we can center it.
                //     var tipWidth = tipElement.prop('offsetWidth'),
                //         tipHeight = tipElement.prop('offsetHeight');

                //     // Get the tooltip's top and left coordinates to center it with this directive.
                //     var tipPosition = getCalculatedOffset(options.placement, elementPosition, tipWidth, tipHeight);

                //     // Now set the calculated positioning.
                //     tipPosition.top += 'px';
                //     tipPosition.left += 'px';
                //     tipElement.css(tipPosition);

                // };

                $tooltip.$onKeyUp = function(evt) {
                    if (evt.which === 27 && $tooltip.$isShown) {
                        $tooltip.hide();
                        evt.stopPropagation();
                    }
                };

                $tooltip.$onFocusKeyUp = function(evt) {
                    if (evt.which === 27) {
                        element[0].blur();
                        evt.stopPropagation();
                    }
                };

                $tooltip.$onFocusElementMouseDown = function(evt) {
                    evt.preventDefault();
                    evt.stopPropagation();
                    // Some browsers do not auto-focus buttons (eg. Safari)
                    if ($tooltip.$isShown) {
                        element[0].blur()
                    } else {
                        element[0].blur();
                        element[0].focus();
                    }
                };

                // Private methods

                function getPosition() {
                    if (options.container === 'body') {
                        return dimensions.offset(options.target[0] || element[0]);
                    } else {
                        return dimensions.position(options.target[0] || element[0]);
                    }
                }

                function getCalculatedOffset(placement, position, actualWidth, actualHeight) {
                    var offset;
                    var split = placement.split('-');

                    switch (split[0]) {
                        case 'right':
                            offset = {
                                top: position.top + position.height / 2 - actualHeight / 2,
                                left: position.left + position.width
                            };
                            break;
                        case 'bottom':
                            offset = {
                                top: position.top + position.height,
                                left: position.left + position.width / 2 - actualWidth / 2
                            };
                            break;
                        case 'left':
                            offset = {
                                top: position.top + position.height / 2 - actualHeight / 2,
                                left: position.left - actualWidth
                            };
                            break;
                        default:
                            offset = {
                                top: position.top - actualHeight,
                                left: position.left + position.width / 2 - actualWidth / 2
                            };
                            break;
                    }

                    if (!split[1]) {
                        return offset;
                    }

                    // Add support for corners @todo css
                    if (split[0] === 'top' || split[0] === 'bottom') {
                        switch (split[1]) {
                            case 'left':
                                offset.left = position.left;
                                break;
                            case 'right':
                                offset.left = position.left + position.width - actualWidth;
                        }
                    } else if (split[0] === 'left' || split[0] === 'right') {
                        switch (split[1]) {
                            case 'top':
                                offset.top = position.top - actualHeight;
                                break;
                            case 'bottom':
                                offset.top = position.top + position.height;
                        }
                    }

                    return offset;
                }

                return $tooltip;

            }

            // Helper functions

            function findElement(query, element) {
                return angular.element((element || document).querySelectorAll(query));
            }

            function fetchTemplate(template) {
                return $q.when($templateCache.get(template) || $http.get(template))
                    .then(function(res) {
                        if (angular.isObject(res)) {
                            $templateCache.put(template, res.data);
                            return res.data;
                        }
                        return res;
                    });
            }

            return TooltipFactory;
        }

        $tooltipDecorator.$inject = ['$delegate', '$window', '$rootScope', '$compile', '$q', '$templateCache', '$http', '$animate', 'dimensions', '$$rAF', 'Utils'];

        $provide.decorator('$tooltip', $tooltipDecorator);
    }]);

/*global angular, _ */
angular.module('bsTypeahead', ['mgcrea.ngStrap'])
    .config(['$provide', function($provide) {

        $provide.decorator('$typeahead', function ($delegate, $timeout) {
            var $typeahead = $delegate;

            function newTypeaheadFactory(element, controller, config) {
                var $typeaheadInstance = $typeahead.apply(this, arguments),
                    options = angular.extend({}, $typeahead.defaults, config),
                    scope = $typeaheadInstance.$scope,
                    parentScope = config.scope;

                $typeaheadInstance.select = function(index) {
                    var value = scope.$matches[index].label.length !== 0 && index !== 0 ? scope.$matches[index].value : scope.$matches[index].label;
                    if (scope.$matches[index].label.length !== 0 && scope.$matches[index].value !== 0) {
                        controller.$setViewValue(value);
                        controller.$render();
                        scope.$resetMatches();
                        if (parentScope) parentScope.$digest();
                        // Emit event
                        scope.$emit(options.prefixEvent + '.select', value, index);
                    } else {
                        controller.$setViewValue(value);
                        controller.$modelValue = undefined;
                    }

                };

                $typeaheadInstance.$onKeyDown = function(evt) {

                    if (!/^(38|40|13)$/.test(evt.keyCode)) return;

                    if ($typeaheadInstance.$isVisible()) {
                        evt.preventDefault();
                        evt.stopPropagation();

                        $timeout(function () {
                            // Select with enter
                            if ((evt.keyCode === 13) && scope.$matches.length) {
                                return scope.$select(scope.$activeIndex);
                            }

                            // Navigate with keyboard
                            else if (evt.keyCode === 38 && scope.$activeIndex > 0) scope.$activeIndex--;
                            else if (evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) scope.$activeIndex++;
                            else if (angular.isUndefined(scope.$activeIndex)) scope.$activeIndex = 0;
                        });
                    }
                };

                return $typeaheadInstance;
            }
            newTypeaheadFactory.defaults = $typeahead.defaults;
            newTypeaheadFactory.defaults.minLength = 0;

            return newTypeaheadFactory;
        });

        $provide.decorator('bsTypeaheadDirective', function($delegate, $window, $parse, $q, $typeahead, $parseOptions) {
            var bsTypeaheadDirective = $delegate[0];

            var defaults = $typeahead.defaults;

            bsTypeaheadDirective.compile = function() {
                return function(scope, element, attr, controller) {
                    // Directive options
                    var options = {
                        scope: scope
                    };
                    angular.forEach(['placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'template', 'filter', 'limit', 'minLength', 'watchOptions', 'selectMode', 'comparator', 'id'], function(key) {
                        if (angular.isDefined(attr[key])) options[key] = attr[key];
                    });

                    // Build proper ngOptions
                    var filter = options.filter || defaults.filter;
                    var limit = options.limit || defaults.limit;

                    var comparator = options.comparator || defaults.comparator;

                    var ngOptions = attr.ngOptions;
                    if (filter) ngOptions += ' | ' + filter + ':$viewValue';
                    if (limit) ngOptions += ' | limitTo:' + limit;
                    if (comparator) ngOptions += ':' + comparator;

                    var parsedOptions = $parseOptions(ngOptions);

                    parsedOptions.displayValue = function(modelValue) {
                        var valuesFn = $parse(parsedOptions.$match[7]),
                            values = valuesFn(options.scope),
                            valueName = parsedOptions.$match[4] || parsedOptions.$match[6],
                            valueFn = $parse(parsedOptions.$match[2] ? parsedOptions.$match[1] : valueName),
                            displayFn = $parse(parsedOptions.$match[2] || parsedOptions.$match[1]),
                            scope = {},
                            value = _.find(values, function (val) {
                                scope[valueName] = val;
                                return _.isEqual(valueFn(scope), modelValue);
                            });
                        scope[valueName] = value;
                        //TODO. REVIEW THIS MESS
                        return displayFn(scope);
                    };

                    parsedOptions.saveValue = function (viewValue) {
                        var valuesFn = $parse(parsedOptions.$match[7]),
                            vals = valuesFn(options.scope),
                            valueName = parsedOptions.$match[4] || parsedOptions.$match[6],
                            valueFn = $parse(parsedOptions.$match[2] ? parsedOptions.$match[1] : valueName),
                            displayFn = $parse(parsedOptions.$match[2] || parsedOptions.$match[1]),
                            scope = {},
                            value = _.find(vals, function (val) {
                                scope[valueName] = val;
                                if (typeof(viewValue) !== 'string'){
                                    return _.isEqual(displayFn(scope), viewValue);
                                }else{
                                    if(displayFn(scope) && viewValue){
                                        return _.isEqual(displayFn(scope).toLowerCase(), viewValue.toLowerCase());
                                    }else{
                                        return '';
                                    }
                                }
                            });
                            if (typeof(viewValue) !== 'string' && !angular.isUndefined(viewValue)){
                                element[0].value = viewValue;
                            } else if (displayFn(scope) && viewValue && _.isEqual(displayFn(scope).toLowerCase(), viewValue.toLowerCase())){
                                element[0].value = displayFn(scope);
                            }
                            scope[valueName] = value;
                            //FIX to solve when de model selected is 0
                            return valueFn(scope) === 0 ? 0 : (valueFn(scope) || viewValue)
                    }

                    // Initialize typeahead
                    var typeahead = $typeahead(element, controller, options);

                    // Watch options on demand
                    if (options.watchOptions) {
                        // Watch ngOptions values before filtering for changes, drop function calls
                        var watchedOptions = parsedOptions.$match[7].replace(/\|.+/, '').replace(/\(.*\)/g, '').trim();
                        scope.$watch(watchedOptions, function() {
                            // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);
                            parsedOptions.valuesFn(scope, controller).then(function(values) {
                                typeahead.update(values);
                                controller.$render();
                            });
                        }, true);
                    }

                    // Watch model for changes
                    scope.$watch(attr.ngModel, function(newValue) {
                        // console.warn('$watch', element.attr('ng-model'), newValue);
                        scope.$modelValue = newValue; // Publish modelValue on scope for custom templates
                        parsedOptions.valuesFn(scope, controller)
                            .then(function(values) {
                                // Prevent input with no future prospect if selectMode is truthy
                                // @TODO test selectMode
                                if (options.selectMode && !values.length && newValue.length > 0) {
                                    controller.$setViewValue(controller.$viewValue.substring(0, controller.$viewValue.length - 1));
                                    return;
                                }

                                var isVisible = typeahead.$isVisible();
                                if (isVisible) typeahead.update(values);
                                // Do not re-queue an update if a correct value has been selected
                                if (values.length === 1 && values[0].value === newValue) return;
                                if (!isVisible) typeahead.update(values);
                                // Queue a new rendering that will leverage collection loading
                                // controller.$render();
                                if(!angular.isUndefined(newValue) && newValue.length > 0){
                                    //setTimeout(function(){element[0].value = newValue;}, 1);
                                    controller.$viewValue = newValue;
                                }
                            });
                    });

                    // modelValue -> $formatters -> viewValue
                    controller.$formatters.push(function(modelValue) {
                        var displayValue = parsedOptions.displayValue(modelValue);
                        return displayValue === undefined ? '' : displayValue;
                    });

                    controller.$parsers.push(function (viewValue) {
                        var modelValue = parsedOptions.saveValue(viewValue);
                        return modelValue === undefined ? '' : modelValue;
                    });

                    // Model rendering in view
                    function render() {
                        // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);
                        if (controller.$isEmpty(controller.$viewValue)) return element.val('');
                        var index = typeahead.$getIndex(controller.$modelValue);
                        var selected = angular.isDefined(index) ? typeahead.$scope.$matches[index].label : controller.$modelValue;
                        selected = angular.isObject(selected) ? parsedOptions.displayValue(selected) : (angular.isDefined(index) ? selected : (!angular.isObject(selected)) ? controller.$modelValue : '');
                        element.val(selected || selected === 0 ? selected.toString().replace(/<(?:.|\n)*?>/gm, '').trim() : '');
                    }

                    // IMPORTANT! When the directive is manually compiled controller.$render is overwritten by AngularJS input[type="text"] directive
                    // This code solve the problem. REVIEW!!!
                    scope.$watch(function() {
                        return controller.$render;
                    }, function($render) {
                        if ($render !== render) controller.$render = render;
                    });

                    // Garbage collection
                    scope.$on('$destroy', function() {
                        if (typeahead) typeahead.destroy();
                        options = null;
                        typeahead = null;
                    });
                };
            }
            return $delegate;
        });
    }])
    // FIX Trello card: https://trello.com/c/wnrPJ4mi
    .run(['$templateCache', function($templateCache) {
        $templateCache.put('typeahead/typeahead.tpl.html', '<ul tabindex="-1" class="typeahead dropdown-menu" ng-show="$isVisible()" role="select"><li role="presentation" ng-repeat="match in $matches" ng-class="{active: $index == $activeIndex}"><a role="menuitem" tabindex="-1" ng-mousedown="$select($index, $event)" ng-bind="match.label"></a></li></ul>');
    }]);

/*global angular */
angular.module('carouselFix', ['ui.bootstrap'])
    .config(['$provide', function ($provide) {
        $provide.decorator('carouselDirective', function ($delegate, $animate) {
            var carouselDirective = $delegate[0],
                compile = carouselDirective.compile || function () {
                    return function () {};
                };

            carouselDirective.compile = function () {
                var postLink = compile.apply(this, arguments);

                return function (scope, element) {
                    $animate.enabled(false, element);
                    postLink.apply(this, arguments);
                };
            };

            return $delegate;
        });
    }]);

/*global angular */
angular.module('closeable', ['ui.bootstrap'])
    .config(['$provide', function ($provide) {
        $provide.decorator('tabsetDirective', function ($delegate, $controller) {
            var tabsetDirective = $delegate[0],
                controllerName = tabsetDirective.controller;

            tabsetDirective.controller = function ($scope) {
                var ctrl = this;

                angular.extend(this, $controller(controllerName, {$scope: $scope}));
                ctrl.removeTab = function removeTab(tab) {
                    var index = ctrl.tabs.indexOf(tab),
                        newActiveIndex;
                    //Select a new tab if the tab to be removed is selected
                    if (tab.active && ctrl.tabs.length > 1) {
                        //If this is the last tab, select the previous tab. else, the next tab.
                        newActiveIndex = index === ctrl.tabs.length - 1 ? index - 1 : index + 1;
                        ctrl.tabs[newActiveIndex].active = true;
                    }
                    ctrl.tabs.splice(index, 1);
                };
            };

            return $delegate;
        });

        $provide.decorator('tabDirective', function ($delegate, $parse) {
            var tabDirective = $delegate[0],
                compile = tabDirective.compile;

            angular.extend(tabDirective.scope, {
                onClose: '&close'
            });

            tabDirective.compile = function () {
                var postLink = compile.apply(this, arguments);

                return function (scope, elm, attrs, tabsetCtrl) {
                    var removeTab,
                        closeButton;

                    postLink.apply(this, arguments);

                    // IE8 FIX. A different attribute from 'disabled' is needed for this to work as intended.
                    if (attrs.tabDisabled) {
                        scope.$parent.$watch($parse(attrs.tabDisabled), function(value) {
                            scope.disabled = !!value;
                        });
                    }

                    if (angular.isDefined(attrs.close) || angular.isDefined(attrs.closeable)) {
                        removeTab = function () {
                            if (scope.disabled) return;

                            scope.$apply(function () {
                                if (angular.isDefined(attrs.closeable)) {
                                    tabsetCtrl.removeTab(scope);
                                    scope.headingElement = false;
                                }

                                if (angular.isDefined(attrs.close)) {
                                    scope.onClose();
                                }
                            });
                        };

                        closeButton = angular.element('<button class="close-tab"></button>')
                            .on('click', removeTab)
                            .on('$destroy', function () {
                                closeButton.off('click', removeTab);
                            });
                        elm.append(closeButton);
                    }
                };
            };

            return $delegate;
        });

        $provide.decorator('tabHeadingTranscludeDirective', function ($delegate) {
            var tabHeadingTranscludeDirective = $delegate[0],
                compile = tabHeadingTranscludeDirective.compile;

            tabHeadingTranscludeDirective.compile = function () {
                var postLink = compile.apply(this, arguments);

                return function (scope, elm) {
                    postLink.apply(this, arguments);

                    scope.$watch('headingElement', function updateHeadingElement(heading) {
                        if (heading) {
                            elm.empty();
                            elm.append(heading);
                        } else if (heading === false) {
                            elm.siblings('.close-tab').remove();
                            elm.remove();
                        }
                    });
                };
            };

            return $delegate;
        });

        $provide.decorator('tabContentTranscludeDirective', function ($delegate) {
            var tabContentTranscludeDirective = $delegate[0];

            function isTabHeading(node) {
                return node.tagName &&  (
                    node.hasAttribute('tab-heading') ||
                    node.hasAttribute('data-tab-heading') ||
                    node.tagName.toLowerCase() === 'tab-heading' ||
                    node.tagName.toLowerCase() === 'data-tab-heading'
                );
            }

            tabContentTranscludeDirective.compile = function () {
                return function (scope, elm, attrs) {

                    var tab = scope.$eval(attrs.tabContentTransclude);

                    //Now our tab is ready to be transcluded: both the tab heading area
                    //and the tab content area are loaded.  Transclude 'em both.
                    tab.$transcludeFn(tab.$parent, function(contents) {
                        angular.forEach(contents, function(node) {
                            if (isTabHeading(node)) {
                                //Let tabHeadingTransclude know.
                                tab.headingElement = node;
                            } else {
                                elm.append(node);
                            }
                        });
                    });
                };
            };

            return $delegate;
        });
    }]);

/*global angular */
angular.module('events', [])
    .value('Events', {
        $formControlError: function(string) {
            return '$error(' + string + ')';
        },
        $formControlFocus: function(string) {
            return '$focus(' + string + ')';
        },
        $formControlClick: function(string) {
            return '$click(' + string + ')';
        },
        $formControlReady: function(string) {
            return '$ready(' + string + ')';
        },
        $languageChanged: '$languageChanged'
    });

/*global angular */
angular.module('form', ['ng'])
    .config(['$provide', function($provide) {

        function formDirectiveDecorator($delegate) {
            var formDirective = $delegate[0],
                formController = formDirective.controller;

            function indexOf(array, obj) {
                if (array.indexOf) return array.indexOf(obj);

                for (var i = 0; i < array.length; i++) {
                    if (obj === array[i]) return i;
                }
                return -1;
            }

            function arrayRemove(array, value) {
                var index = indexOf(array, value);
                if (index >= 0)
                    array.splice(index, 1);
                return value;
            }

            function newFormController() {
                var controls = [],
                    ctrl = this,
                    addControl,
                    removeControl;

                formController.apply(ctrl, arguments);

                addControl = ctrl.$addControl;
                ctrl.$addControl = function(control) {
                    addControl.apply(this, arguments);
                    controls.push(control);
                };

                removeControl = ctrl.$removeControl;
                ctrl.$removeControl = function(control) {
                    removeControl.apply(this, arguments);
                    arrayRemove(controls, control);
                };

                ctrl.$dirtify = function() {
                    angular.forEach(controls, function(control) {
                        if (control.$dirtify) {
                            control.$dirtify();
                        }
                    });
                };
            }

            newFormController.$inject = ['$element', '$attrs', '$scope', '$animate', '$interpolate']

            formDirective.controller = newFormController;

            return $delegate;
        }

        formDirectiveDecorator.$inject = ['$delegate'];

      //  $provide.decorator('formDirective', formDirectiveDecorator);
    }])

/*global angular */
/**
 * @doc-component directive
 * @name gaiafrontend.directive.mpAccordionHeading .
 * @description
 * This directive shows a loading gliphicon when it´s linked to a promess to be resolved
 */
angular.module('mpAccordionHeading', [])
    .directive('mpAccordionHeading', ['$parse', function($parse) {
        // Runs during compile
        return {
            scope: true,
            templateUrl: 'gaiafrontend/html/mpAccordionHeading.html',
            link: function(scope, element, $attrs) {
                var accordionDefaultIcon = {
                    isOpen : true,
                    isLoading: false
                };
                scope.accordionIcon = $attrs.accordionIcon ? $parse($attrs.accordionIcon)(scope) : accordionDefaultIcon;
                scope.accTitle = $attrs.accTitle || '';

            }
        };
    }]);

/*global angular, _ */
/*jshint camelcase: false */
/*TODO: Refactor!! Clean code!! */
angular.module('mpAddressNormalizer', [])
    .constant('PROVINCIA', {
        '1': 'ARABA/ALAVA',
        '2': 'ALBACETE',
        '3': 'ALICANTE-ALACANT',
        '4': 'ALMERIA',
        '5': 'AVILA',
        '6': 'BADAJOZ',
        '7': 'ILLES BALEARS',
        '8': 'BARCELONA',
        '9': 'BURGOS',
        '10': 'CACERES',
        '11': 'CADIZ',
        '12': 'CASTELLON-CASTELLO',
        '13': 'CIUDAD REAL',
        '14': 'CORDOBA',
        '15': 'A CORUÑA',
        '16': 'CUENCA',
        '17': 'GIRONA',
        '18': 'GRANADA',
        '19': 'GUADALAJARA',
        '20': 'GIPUZKOA',
        '21': 'HUELVA',
        '22': 'HUESCA',
        '23': 'JAEN',
        '24': 'LEON',
        '25': 'LLEIDA',
        '26': 'LA RIOJA',
        '27': 'LUGO',
        '28': 'MADRID',
        '29': 'MALAGA',
        '30': 'MURCIA',
        '31': 'NAVARRA',
        '32': 'OURENSE',
        '33': 'ASTURIAS',
        '34': 'PALENCIA',
        '35': 'LAS PALMAS',
        '36': 'PONTEVEDRA',
        '37': 'SALAMANCA',
        '38': 'SANTA CRUZ DE TENERIFE',
        '39': 'CANTABRIA',
        '40': 'SEGOVIA',
        '41': 'SEVILLA',
        '42': 'SORIA',
        '43': 'TARRAGONA',
        '44': 'TERUEL',
        '45': 'TOLEDO',
        '46': 'VALENCIA',
        '47': 'VALLADOLID',
        '48': 'BIZKAIA',
        '49': 'ZAMORA',
        '50': 'ZARAGOZA',
        '51': 'CEUTA',
        '52': 'MELILLA'
    })
    .constant('TIPO_VIA', [
        {
            'code': 'ACC',
            'desc': 'ACCESO'
        }, {
            'code': 'ACE',
            'desc': 'ACERA'
        }, {
            'code': 'ACQ',
            'desc': 'ACEQUIA'
        }, {
            'code': 'AFU',
            'desc': 'AFUERA'
        }, {
            'code': 'AGR',
            'desc': 'AGRUPACIÓN'
        }, {
            'code': 'AL',
            'desc': 'ALAMEDA'
        }, {
            'code': 'AP',
            'desc': 'APARTAMENTO'
        }, {
            'code': 'APE',
            'desc': 'APARTADO POSTAL EXTRANJERO'
        }, {
            'code': 'APN',
            'desc': 'APARTADO POSTAL NACIONAL'
        }, {
            'code': 'AR',
            'desc': 'ARRABALES'
        }, {
            'code': 'ARR',
            'desc': 'ARRABAL'
        }, {
            'code': 'AUT',
            'desc': 'AUTOPISTA'
        }, {
            'code': 'AUT',
            'desc': 'AUTOVÍA'
        }, {
            'code': 'AVD',
            'desc': 'AVENIDA'
        }, {
            'code': 'BCO',
            'desc': 'BARRANCO'
        }, {
            'code': 'BDA',
            'desc': 'BARRIADA'
        }, {
            'code': 'BL',
            'desc': 'BLOQUE'
        }, {
            'code': 'BO',
            'desc': 'BARRIO'
        }, {
            'code': 'CAS',
            'desc': 'CASA'
        }, {
            'code': 'CAS',
            'desc': 'CASAS'
        }, {
            'code': 'CAS',
            'desc': 'CASETA'
        }, {
            'code': 'CAS',
            'desc': 'CASILLA'
        }, {
            'code': 'CAS',
            'desc': 'CASERÍO'
        }, {
            'code': 'CH',
            'desc': 'CHALET'
        }, {
            'code': 'CJN',
            'desc': 'CALLEJA'
        }, {
            'code': 'CJN',
            'desc': 'CALLEJÓN'
        }, {
            'code': 'CJT',
            'desc': 'CONJUNTO'
        }, {
            'code': 'CL',
            'desc': 'CALLE'
        }, {
            'code': 'CM',
            'desc': 'CAMINO'
        }, {
            'code': 'COL',
            'desc': 'COLONIA'
        }, {
            'code': 'COM',
            'desc': 'COMPLEJO'
        }, {
            'code': 'COO',
            'desc': 'COOPERATIVA'
        }, {
            'code': 'CRA',
            'desc': 'CARRETERA'
        }, {
            'code': 'CRA',
            'desc': 'CARRIL'
        }, {
            'code': 'CRA',
            'desc': 'CORREDERA'
        }, {
            'code': 'CTA',
            'desc': 'CUESTA'
        }, {
            'code': 'CTJ',
            'desc': 'CORTIJO'
        }, {
            'code': 'DIS',
            'desc': 'DISEMINADO'
        }, {
            'code': 'DIS',
            'desc': 'DISEMINADOS'
        }, {
            'code': 'EDF',
            'desc': 'EDIFICIO'
        }, {
            'code': 'ENT',
            'desc': 'ENTRADA'
        }, {
            'code': 'FCA',
            'desc': 'FINCA'
        }, {
            'code': 'GPO',
            'desc': 'GRUPO'
        }, {
            'code': 'GPO',
            'desc': 'GRUPOS'
        }, {
            'code': 'GTA',
            'desc': 'GLORIETA'
        }, {
            'code': 'GV',
            'desc': 'GRAN VIA'
        }, {
            'code': 'LUG',
            'desc': 'LUGAR'
        }, {
            'code': 'MAS',
            'desc': 'MASÍA'
        }, {
            'code': 'MC',
            'desc': 'MERCADO'
        }, {
            'code': 'MLE',
            'desc': 'MUELLE'
        }, {
            'code': 'MN',
            'desc': 'MUNICIPIO'
        }, {
            'code': 'MZ',
            'desc': 'MANZANA'
        }, {
            'code': 'NUC',
            'desc': 'NUCLEO'
        }, {
            'code': 'PAT',
            'desc': 'PATIO'
        }, {
            'code': 'PDA',
            'desc': 'PARTIDA'
        }, {
            'code': 'PJE',
            'desc': 'PASAJE'
        }, {
            'code': 'PJE',
            'desc': 'PARAJE'
        }, {
            'code': 'POB',
            'desc': 'POBLADO'
        }, {
            'code': 'POB',
            'desc': 'POBLACIÓN'
        }, {
            'code': 'POL',
            'desc': 'POLÍGONO'
        }, {
            'code': 'PQE',
            'desc': 'PARQUE'
        }, {
            'code': 'PRL',
            'desc': 'PROLONGACIÓN'
        }, {
            'code': 'PSO',
            'desc': 'PASEO'
        }, {
            'code': 'PSO',
            'desc': 'PASILLO'
        }, {
            'code': 'PSO',
            'desc': 'PASADIZO'
        }, {
            'code': 'PZA',
            'desc': 'PLAZA'
        }, {
            'code': 'PZL',
            'desc': 'PLACETA'
        }, {
            'code': 'PZL',
            'desc': 'PLAZUELA'
        }, {
            'code': 'PZL',
            'desc': 'PLAZOLETA'
        }, {
            'code': 'RAM',
            'desc': 'RAMBLA'
        }, {
            'code': 'RDA',
            'desc': 'RONDA'
        }, {
            'code': 'ROT',
            'desc': 'ROTONDA'
        }, {
            'code': 'RSD',
            'desc': 'RESIDENCIA'
        }, {
            'code': 'RSD',
            'desc': 'RESIDENCIAL'
        }, {
            'code': 'SD',
            'desc': 'SIN DEFINIR'
        }, {
            'code': 'SDA',
            'desc': 'PUJADA'
        }, {
            'code': 'SDA',
            'desc': 'SENDA'
        }, {
            'code': 'SDA',
            'desc': 'SENDERA'
        }, {
            'code': 'SDA',
            'desc': 'SUBIDA'
        }, {
            'code': 'SDA',
            'desc': 'SENDERO'
        }, {
            'code': 'SDA',
            'desc': 'SENDILLA'
        }, {
            'code': 'TRV',
            'desc': 'TRAVESÍA'
        }, {
            'code': 'URB',
            'desc': 'URBANIZACIÓN'
        }, {
            'code': 'VIA',
            'desc': 'VIA'
        }, {
            'code': 'ZNA',
            'desc': 'ZONA'
        }
    ])
    .constant('TIPO_VIA_DEYDE', [
        {
            'code': 'ACC',
            'desc': 'ACCESO'
        }, {
            'code': 'ACE',
            'desc': 'ACERA'
        }, {
            'code': 'ACQ',
            'desc': 'ACEQUIA'
        }, {
            'code': 'AFU',
            'desc': 'AFUERA'
        }, {
            'code': 'AGR',
            'desc': 'AGRUPACION'
        }, {
            'code': 'AL',
            'desc': 'ALAMEDA'
        }, {
            'code': 'AP',
            'desc': 'APARTAMENTO'
        }, {
            'code': 'APE',
            'desc': 'APARTADO DE CORREOS EXTRANJERO'
        }, {
            'code': 'APN',
            'desc': 'APARTADO DE CORREOS'
        }, {
            'code': 'APN',
            'desc': 'APARTADO DE CORREOS NACIONAL'
        }, {
            'code': 'ARR',
            'desc': 'RAVAL'
        }, {
            'code': 'ARR',
            'desc': 'ARRBL'
        }, {
            'code': 'AUT',
            'desc': 'AUT'
        }, {
            'code': 'AVD',
            'desc': 'AVDA'
        }, {
            'code': 'BCO',
            'desc': 'BRNCO'
        }, {
            'code': 'BDA',
            'desc': 'BDA'
        }, {
            'code': 'BDA',
            'desc': 'BJDA'
        }, {
            'code': 'BDA',
            'desc': 'BXDA'
        }, {
            'code': 'BL',
            'desc': 'BLQ'
        }, {
            'code': 'BO',
            'desc': 'BARRI'
        }, {
            'code': 'BO',
            'desc': 'BO'
        }, {
            'code': 'CAS',
            'desc': 'CSRIO'
        }, {
            'code': 'CAS',
            'desc': 'CAS'
        }, {
            'code': 'CH',
            'desc': 'CHALET'
        }, {
            'code': 'CJN',
            'desc': 'CRO'
        }, {
            'code': 'CJN',
            'desc': 'CXON'
        }, {
            'code': 'CJN',
            'desc': 'RUELA'
        }, {
            'code': 'CJN',
            'desc': 'CJA'
        }, {
            'code': 'CJN',
            'desc': 'CJON'
        }, {
            'code': 'CJT',
            'desc': 'CJTO'
        }, {
            'code': 'CL',
            'desc': 'CLLZO'
        }, {
            'code': 'CL',
            'desc': 'KALE'
        }, {
            'code': 'CL',
            'desc': 'PAGO'
        }, {
            'code': 'CL',
            'desc': 'RIERA'
        }, {
            'code': 'CL',
            'desc': 'RUA'
        }, {
            'code': 'CL',
            'desc': 'TRANS'
        }, {
            'code': 'CL',
            'desc': 'TSRA'
        }, {
            'code': 'CL',
            'desc': 'VENAT'
        }, {
            'code': 'CL',
            'desc': 'VREDA'
        }, {
            'code': 'CL',
            'desc': 'ALDEA'
        }, {
            'code': 'CM',
            'desc': 'CMNO'
        }, {
            'code': 'CM',
            'desc': 'CMÑO'
        }, {
            'code': 'CM',
            'desc': 'CAMI'
        }, {
            'code': 'COL',
            'desc': 'CNIA'
        }, {
            'code': 'COM',
            'desc': 'COMPLEJO'
        }, {
            'code': 'COO',
            'desc': 'COOPERATIVA'
        }, {
            'code': 'CRA',
            'desc': 'CRA'
        }, {
            'code': 'CRA',
            'desc': 'CRRIL'
        }, {
            'code': 'CRA',
            'desc': 'ESTDA'
        }, {
            'code': 'CTA',
            'desc': 'CSTA'
        }, {
            'code': 'CTJ',
            'desc': 'CTJO'
        }, {
            'code': 'DIS',
            'desc': 'EXTR'
        }, {
            'code': 'EDF',
            'desc': 'EDIF'
        }, {
            'code': 'ENT',
            'desc': 'ENTRADA'
        }, {
            'code': 'FCA',
            'desc': 'FINCA'
        }, {
            'code': 'GPO',
            'desc': 'GRUP'
        }, {
            'code': 'GPO',
            'desc': 'GRUPO'
        }, {
            'code': 'GTA',
            'desc': 'GLTA'
        }, {
            'code': 'GV',
            'desc': 'GRAN VIA'
        }, {
            'code': 'LUG',
            'desc': 'LLOC'
        }, {
            'code': 'LUG',
            'desc': 'LUGAR'
        }, {
            'code': 'MAS',
            'desc': 'MASIA'
        }, {
            'code': 'MAS',
            'desc': 'MASO'
        }, {
            'code': 'MC',
            'desc': 'MERCADO'
        }, {
            'code': 'MLE',
            'desc': 'MUELLE'
        }, {
            'code': 'MN',
            'desc': 'MUNICIPIO'
        }, {
            'code': 'MZ',
            'desc': 'MANZANA'
        }, {
            'code': 'NUC',
            'desc': 'NUCLEO'
        }, {
            'code': 'PAT',
            'desc': 'PATIO'
        }, {
            'code': 'PDA',
            'desc': 'PTDA'
        }, {
            'code': 'PJE',
            'desc': 'PJE'
        }, {
            'code': 'PJE',
            'desc': 'PRJE'
        }, {
            'code': 'PJE',
            'desc': 'PSAXE'
        }, {
            'code': 'PJE',
            'desc': 'PTGE'
        }, {
            'code': 'POB',
            'desc': 'PBDO'
        }, {
            'code': 'POL',
            'desc': 'POLIG'
        }, {
            'code': 'PQE',
            'desc': 'PARC'
        }, {
            'code': 'PQE',
            'desc': 'PQUE'
        }, {
            'code': 'PRL',
            'desc': 'PROL'
        }, {
            'code': 'PSO',
            'desc': 'PASEO'
        }, {
            'code': 'PSO',
            'desc': 'PSEIG'
        }, {
            'code': 'PZA',
            'desc': 'PLAZA'
        }, {
            'code': 'PZA',
            'desc': 'PLAÇA'
        }, {
            'code': 'PZA',
            'desc': 'PRAZA'
        }, {
            'code': 'PZL',
            'desc': 'PCTA'
        }, {
            'code': 'PZL',
            'desc': 'PZLA'
        }, {
            'code': 'PZL',
            'desc': 'PZTA'
        }, {
            'code': 'RAM',
            'desc': 'RBLA'
        }, {
            'code': 'RDA',
            'desc': 'RONDA'
        }, {
            'code': 'ROT',
            'desc': 'ROTONDA'
        }, {
            'code': 'RSD',
            'desc': 'RESID'
        }, {
            'code': 'SD',
            'desc': 'SIN DEFINIR'
        }, {
            'code': 'SDA',
            'desc': 'PJDA'
        }, {
            'code': 'SDA',
            'desc': 'SBIDA'
        }, {
            'code': 'SDA',
            'desc': 'SENDA'
        }, {
            'code': 'TRV',
            'desc': 'TRAV'
        }, {
            'code': 'URB',
            'desc': 'URB'
        }, {
            'code': 'VIA',
            'desc': 'VIA'
        }, {
            'code': 'ZNA',
            'desc': 'ZONA'
        }
    ])
    .factory('addressNormalizerModalGrid', ['$filter',
        function($filter) {
            return {
                getOptions: function() {
                    var options = {
                        'datatype': 'local',
                        'multiselect': true,
                        'height': 'auto',
                        'colNames': [
                            $filter('translate')('mpAddressNormalizer.property'),
                            $filter('translate')('mpAddressNormalizer.field'),
                            $filter('translate')('mpAddressNormalizer.initialValue'),
                            $filter('translate')('mpAddressNormalizer.normalizedValue')
                        ],
                        'colModel': [{
                            'name': 'property',
                            'index': 'property',
                            'hidden': true
                        }, {
                            'name': 'field',
                            'index': 'field',
                            'align': 'left'
                        }, {
                            'name': 'initialValue',
                            'index': 'initialValue',
                            'align': 'left'
                        }, {
                            'name': 'normalizedValue',
                            'index': 'normalizedValue',
                            'align': 'left'
                        }],
                        'loadonce': true,
                        'mtype': 'GET',
                        'gridview': true,
                        'sortname': 'name',
                        'viewrecords': true,
                        'sortorder': 'asc',
                        'footerrow': false,
                        'autowidth': true,
                        'emptyrecords': $filter('translate')('mpAddressNormalizer.no_records_found')
                    };

                    return options;
                }
            };
        }
    ])
    .controller('AddressNormalizerModalCtrl', ['$scope', '$parse', '$filter', '$modalInstance', 'PROVINCIA', 'addressNormalizerModalGrid', 'modelBeforeNormalization', 'modelAfterLastSuggestionsApplied', 'normalization',
        function($scope, $parse, $filter, $modalInstance, PROVINCIA, addressNormalizerModalGrid, modelBeforeNormalization, modelAfterLastSuggestionsApplied, normalization) {

            function createAddressNormalizerModalGridData() {
                var gridData = [];

                if (normalization.tipoVia) {
                    gridData.push({
                        property: 'tipoVia',
                        field: $filter('translate')('mpAddressNormalizer.tipoVia'),
                        initialValue: modelBeforeNormalization.tipoVia,
                        normalizedValue: normalization.tipoVia
                    });
                }

                if (normalization.nombreVia) {
                    gridData.push({
                        property: 'nombreVia',
                        field: $filter('translate')('mpAddressNormalizer.nombre_via'),
                        initialValue: modelBeforeNormalization.nombreVia,
                        normalizedValue: normalization.nombreVia
                    });
                }

                if (normalization.numVia) {
                    gridData.push({
                        property: 'numVia',
                        field: $filter('translate')('mpAddressNormalizer.num_via'),
                        initialValue: modelBeforeNormalization.numVia,
                        normalizedValue: normalization.numVia
                    });
                }

                if (normalization.restoVia) {
                    gridData.push({
                        property: 'restoVia',
                        field: $filter('translate')('mpAddressNormalizer.resto_via'),
                        initialValue: modelBeforeNormalization.restoVia,
                        normalizedValue: normalization.restoVia
                    });
                }

                if (normalization.codigoPostal) {
                    gridData.push({
                        property: 'codigoPostal',
                        field: $filter('translate')('mpAddressNormalizer.codigoPostal'),
                        initialValue: modelBeforeNormalization.codigoPostal,
                        normalizedValue: normalization.codigoPostal
                    });
                }

                if (normalization.poblacion) {
                    gridData.push({
                        property: 'poblacion',
                        field: $filter('translate')('mpAddressNormalizer.poblacion'),
                        initialValue: modelBeforeNormalization.poblacion,
                        normalizedValue: normalization.poblacion
                    });
                }

                if (modelBeforeNormalization.provincia && normalization.provincia) {
                    gridData.push({
                        property: 'provincia',
                        field: $filter('translate')('mpAddressNormalizer.provincia'),
                        initialValue: PROVINCIA[modelBeforeNormalization.provincia] || '',
                        normalizedValue: PROVINCIA[normalization.provincia] || ''
                    });
                }

                return gridData;
            }

            $scope.grid = {
                data: createAddressNormalizerModalGridData(modelBeforeNormalization, normalization),
                options: addressNormalizerModalGrid.getOptions(),
                model: []
            };

            $scope.$on('addressNormalizerGridSet', function() {
                $scope.grid.model = _.filter($scope.grid.data, function(item) {
                    return angular.equals(modelAfterLastSuggestionsApplied[item.property], item.normalizedValue);
                });
            });

            function getAcceptedSuggestionsModel() {
                var allSuggestions = _.pluck($scope.grid.data, 'property'),
                    acceptedSuggestions = _.pluck($scope.grid.model, 'property'),
                    rejectedSuggestions = _.difference(allSuggestions, acceptedSuggestions),
                    acceptedSuggestionsModel = {};

                angular.forEach(acceptedSuggestions, function(property) {
                    acceptedSuggestionsModel[property] = normalization[property];
                });

                angular.forEach(rejectedSuggestions, function(property) {
                    acceptedSuggestionsModel[property] = modelBeforeNormalization[property];
                });

                return acceptedSuggestionsModel;
            }

            $scope.accept = function() {
                $modalInstance.close(getAcceptedSuggestionsModel());
            };
        }
    ])
    .factory('AddressNormalizerSrv', ['$q', 'HttpSrv',
        function($q, HttpSrv) {
            var addressUrl = 'api/normalize/address';

            function normalize(stringToNormalize) {
                var defer = $q.defer();

                HttpSrv.post(addressUrl, {
                    data: {
                        address: stringToNormalize
                    }
                })
                    .then(function(data) {
                        var obj = {};

                        angular.forEach(data, function(value, key) {
                            obj[key] = angular.isString(value) ? value.replace(/^\s+|\s+$/g, '') : value;
                        });

                        defer.resolve(obj);
                    }, defer.reject);

                return defer.promise;
            }

            return {
                normalize: normalize
            };
        }
    ])
    /**
     * @doc-component directive
     * @name gaiafrontend.directive.mpAddressNormalizer
     * @param {expression} mp-address-normalizer The result of the expression must be an object. The object will map internal variables with model variables.
     * @param {expression=} mp-address-normalizer-options The result of the expression must be an object. This object will configure the directive behaviour.
     * @description
     *
     * This directive allows you to normalize address information.
     *
     * The keys in the object map passed as mp-address-normalizer will be the internal variable names and its values will be the model expression they will be bound to.
     * These are all the internal variables that can be mapped:
     *
     * - `tipoVia` - (REQUIRED) Street type.
     * - `nombreVia` - (REQUIRED) Street name.
     * - `numVia` - (REQUIRED) Building number.
     * - `codigoPostal` - (REQUIRED) Postal code.
     * - `poblacion` - (REQUIRED) City name.
     * - `piso` - Floor.
     * - `puerta` - Door.
     * - `escalera` - ...
     * - `portal` - ...
     * - `restoVia` - Additional information for the address.
     * - `provincia` - State.
     * - `tip_situ_val` - Current situation of the normalization. Its values are: null (not normalized), '1' (normalization accepted) and '2' (normalization rejected)
     * - `normalize` - Method to request normalization.
     * - `openModal` - Method to open a model with the normalization response.
     * - `applyNormalization` - Method to apply normalization to the model.
     *
     * The `normalize` method will use `tipoVia`, `nombreVia`, `numVia`, `codigoPostal` and `poblacion` model values to request normalization.
     * It will return a promise. This promise will be resolved with normalization model.
     *
     * The `openModal` method will use normalization model as argument and will apply the normalization itself.
     *
     * The `applyNormalization` method will use normalizations to apply model and the normalization response model as arguments.
     *
     * These are all the available options for directive configuration:
     *
     * - `hide` - If truthy the directive will not render any DOM element. Defaults to falsy.
     * - `extendedInfo` - If truthy the directive will render `piso`, `puerta`, `escalera` and `portal` input elements. Defaults to falsy.
     * - `warn` - If truthy the directive will render an information icon with the current situation of the normalization when normalized at least once. If normalizable it can be clicked to open a modal window to manage normalization.
     * - `onBlur` - AngularJS expression to evaluate (usually normalization method) when `blur` event is triggered by the las `input` element visible (`apellido2` when physical person and `nombre` when corporate name).
     * - `sizes` - Object to extend default input length to capture by the directive.
     *     - `pais` defaults to 3 characters.
     *     - `tipoVia` defaults to 3 characters.
     *     - `nombreVia` defaults to 50 characters.
     *     - `numVia` defaults to 15 character.
     *     - `restoVia` defaults to 150 character.
     *     - `codigoPostal` defaults to 15 character.
     *     - `poblacion` defaults to 6 character.
     *     - `provincia` defaults to 5 character.
     *
     * If we desire to normalize an address when focusing out the input and then display suggestions in a modal after clicking the icon
     * this could be the mapping object...
     *
     *  ```js
     *  {
     *      'tipoVia': 'addressModel.tipoVia',
     *      'nombreVia': 'addressModel.nombreVia',
     *      'numVia': 'addressModel.numVia',
     *      'restoVia': 'addressModel.restoVia',
     *      'codigoPostal': 'addressModel.codigoPostal',
     *      'poblacion': 'addressModel.poblacion',
     *      'provincia': 'addressModel.provincia',
     *      'tip_situ_val': 'addressModel.normalizationStatus',
     *      'normalize': 'addressModel.requestAddressNormalization'
     *  }
     *  ```
     *
     * ... and this could be the options object.
     *
     *  ```js
     *  {
     *      'warn': true,
     *      'onBlur': 'addressModel.requestAddressNormalization()'
     *  }
     *  ```
     * Given these objects, the directive invocation will result in something like this:
     *
     *  ```js
     *  div(mp-address-normalizer='{'tipoVia': 'addressModel.tipoVia', 'nombreVia': 'addressModel.nombreVia', 'numVia': 'addressModel.numVia', 'restoVia': 'addressModel.restoVia', 'codigoPostal': 'addressModel.codigoPostal', 'poblacion': 'addressModel.poblacion', 'provincia': 'addressModel.provincia', 'tip_situ_val': 'addressModel.normalizationStatus', 'normalize': 'addressModel.requestAddressNormalization'}', mp-address-normalizer-options='{'warn': true, 'onBlur': 'addressModel.requestAddressNormalization()'}')
     *  ```
     *
     * @example
       <doc:example module='mpAddressNormalizer'>
        <doc:source>
        label The example is currently unavailable. If you want to try this component out, you can visit:
        a(href='http://vles044273-008:8081/issuestracker/login.html#/') Issuestracker
        h2 Log in
        h4 User: UGAIA1
        h4 Password: UGAIA1
        h4 Navigate to Normalizations submenu.
        </doc:source>
       </doc:example>
     */
    .directive('mpAddressNormalizer', ['$parse', '$q', '$filter', '$modal', 'Utils', 'PROVINCIA', 'TIPO_VIA', 'TIPO_VIA_DEYDE', 'AddressNormalizerSrv', 'Events',
        function($parse, $q, $filter, $modal, Utils, PROVINCIA, TIPO_VIA, TIPO_VIA_DEYDE, AddressNormalizerSrv, Events) {
            var defaultOptions = {
                    sizes: {
                        pais: 3, // CDC
                        tipoVia: 3, // CDC
                        nombreVia: 50, // CDC
                        numVia: 15, // CDC
                        restoVia: 150, // CDC
                        codigoPostal: 15, // CDC
                        poblacion: 60, // CDC
                        municipio: 40, // batch
                        provincia: 5, // CDC
                        varPob: 7, // batch
                        mujPob: 7, // batch
                        indica: 1, // batch
                        infia: 1 // batch
                    }
                },
                NO_NORMALIZADO = null,
                NORMALIZACION_RECHAZADA = '0',
                NORMALIZACION_ACEPTADA = '1';

            function validate(normalizationMap) {
                if (!angular.isObject(normalizationMap)) {
                    throw new Error('[mp-address-normalizer] must be an object');
                }

                if (!normalizationMap.tipoVia) {
                    throw new Error('[mp-address-normalizer] object must own \'tipoVia\' property');
                }

                if (!normalizationMap.nombreVia) {
                    throw new Error('[mp-address-normalizer] object must own \'nombreVia\' property');
                }

                if (!normalizationMap.numVia) {
                    throw new Error('[mp-address-normalizer] object must own \'numVia\' property');
                }

                if (!normalizationMap.codigoPostal) {
                    throw new Error('[mp-address-normalizer] object must own \'codigoPostal\' property');
                }

                if (!normalizationMap.poblacion) {
                    throw new Error('[mp-address-normalizer] object must own \'poblacion\' property');
                }
            }

            return {
                // scope: true, // because of ngInit in createAddressNormalizerSelectControlElement
                transclude: true,
                require: '^form',
                compile: function(cElement, cAttributes) {
                    var PAIS = {
                            'ESP': $filter('translate')('mpAddressNormalizer.espana')
                        },
                        PAIS_DEFAULT_VALUE = 'ESP',
                        normalizationMap = $parse(cAttributes.mpAddressNormalizer)(),
                        options = angular.extend(angular.copy(defaultOptions), $parse(cAttributes.mpAddressNormalizerOptions)());

                    function createAddressNormalizerInputControlElement(colSize, colOffset, labelSize, controlSize, labelText, ngModelExpression, maxlength, mpType, onBlurFn) {
                        var wrapper = angular.element('<div class="col-md-' + colSize + (colOffset ? ' col-md-offset-' + colOffset : '') + '"></div>'),
                            formGroup = angular.element('<div class="form-group"></div>'),
                            label = angular.element('<label class="col-sm-' + labelSize + ' control-label" for="' + ngModelExpression + '">' + labelText + '</label>'),
                            inputWrapper = angular.element('<div class="validable col-sm-' + controlSize + '"></div>'),
                            input = angular.element('<input type="text"' + (mpType ? ' mp-type="' + mpType + '"' : '') + ' id="' + ngModelExpression + '" name="' + ngModelExpression + '" maxlength="' + maxlength + '" class="form-control" mp-to-upper-case="" ng-model="' + ngModelExpression + '"' + (onBlurFn ? ' ng-blur="' + onBlurFn + '"' : '') + '></input>');

                        inputWrapper.append(input);
                        formGroup.append(label).append(inputWrapper);
                        wrapper.append(formGroup);

                        return wrapper;
                    }

                    // ngOptions expression model MUST be an scope variable if we want to save an object in the model and still display selected option properly
                    function createAddressNormalizerSelectControlElement(colSize, colOffset, labelSize, controlSize, labelText, ngModelExpression, ngInitExpression, ngOptionsExpression, onBlurFn) {
                        var wrapper = angular.element('<div class="col-md-' + colSize + (colOffset ? ' col-md-offset-' + colOffset : '') + '"></div>'),
                            formGroup = angular.element('<div class="form-group"></div>'),
                            label = angular.element('<label class="col-sm-' + labelSize + ' control-label" for="' + ngModelExpression + '">' + labelText + '</label>'),
                            inputWrapper = angular.element('<div class="validable col-sm-' + controlSize + '" ng-init="' + ngInitExpression + '"></div>'),
                            input = angular.element('<select id="' + ngModelExpression + '" name="' + ngModelExpression + '" class="form-control" mp-to-upper-case="" ng-model="' + ngModelExpression + '" ng-options="' + ngOptionsExpression + '"' + (onBlurFn ? ' ng-blur="' + onBlurFn + '"' : '') + '><option value="" selected="selected">' + $filter('translate')('select') + '</option></input>');

                        inputWrapper.append(input);
                        formGroup.append(label).append(inputWrapper);
                        wrapper.append(formGroup);

                        return wrapper;
                    }

                    function createAddressNormalizerWarnElement() {
                        var wrapper = angular.element('<div class="col-md-4 col-md-offset-1"></div>'),
                            img = angular.element('<img class="contact-normalizer-warn-img" src="gaiafrontend/img/icon/icon-detail.png"></img>'),
                            anchor = angular.element('<a class="contact-normalizer-warn-anchor" style="vertical-align: bottom; margin-left: 10px;">' + $filter('translate')('mpAddressNormalizer.results_suggested') + '</a>');

                        wrapper.append(img).append(anchor);

                        return wrapper;
                    }

                    function prepareDOM() {
                        var row = function() {
                                return angular.element('<div class="row"></div>');
                            },
                            paisElement = createAddressNormalizerSelectControlElement(3, 0, 4, 8, $filter('translate')('mpAddressNormalizer.pais'), normalizationMap.pais, '$PAIS=' + angular.toJson(PAIS).replace(/\"/g, '\''), 'code as desc for (code, desc) in $PAIS'),
                            tipoViaElement = createAddressNormalizerSelectControlElement(3, 0, 4, 8, $filter('translate')('mpAddressNormalizer.tipoVia'), normalizationMap.tipoVia, '$TIPO_VIA=' + angular.toJson(TIPO_VIA).replace(/\"/g, '\''), 'tipo as tipo.desc for tipo in $TIPO_VIA track by tipo.code', options.onBlur),
                            nombreViaElement = createAddressNormalizerInputControlElement(6, 0, 2, 10, $filter('translate')('mpAddressNormalizer.nombreVia'), normalizationMap.nombreVia, options.sizes.nombreVia || defaultOptions.sizes.nombreVia, null, options.onBlur),
                            numViaElement = createAddressNormalizerInputControlElement(3, 0, 4, 8, $filter('translate')('mpAddressNormalizer.numVia'), normalizationMap.numVia, options.sizes.numVia || defaultOptions.sizes.numVia, null, options.onBlur),
                            pisoElement = createAddressNormalizerInputControlElement(3, 0, 4, 8, $filter('translate')('mpAddressNormalizer.piso'), normalizationMap.piso, options.sizes.piso || defaultOptions.sizes.piso),
                            puertaElement = createAddressNormalizerInputControlElement(3, 0, 4, 8, $filter('translate')('mpAddressNormalizer.puerta'), normalizationMap.puerta, options.sizes.puerta || defaultOptions.sizes.puerta),
                            escaleraElement = createAddressNormalizerInputControlElement(3, 0, 4, 8, $filter('translate')('mpAddressNormalizer.escalera'), normalizationMap.escalera, options.sizes.escalera || defaultOptions.sizes.escalera),
                            portalElement = createAddressNormalizerInputControlElement(3, 0, 4, 8, $filter('translate')('mpAddressNormalizer.portal'), normalizationMap.portal, options.sizes.portal || defaultOptions.sizes.portal),
                            restoViaElement = createAddressNormalizerInputControlElement(12, 0, 1, 11, $filter('translate')('mpAddressNormalizer.restoVia'), normalizationMap.restoVia, options.sizes.restoVia || defaultOptions.sizes.restoVia),
                            codigoPostalElement = createAddressNormalizerInputControlElement(3, 0, 4, 8, $filter('translate')('mpAddressNormalizer.codigoPostal'), normalizationMap.codigoPostal, options.sizes.codigoPostal || defaultOptions.sizes.codigoPostal, 'number', options.onBlur),
                            poblacionElement = createAddressNormalizerInputControlElement(3, 0, 4, 8, $filter('translate')('mpAddressNormalizer.poblacion'), normalizationMap.poblacion, options.sizes.poblacion || defaultOptions.sizes.poblacion, null, options.onBlur),
                            provinciaElement = createAddressNormalizerSelectControlElement(3, 0, 4, 8, $filter('translate')('mpAddressNormalizer.provincia'), normalizationMap.provincia, '$PROVINCIA=' + angular.toJson(PROVINCIA).replace(/\"/g, '\''), 'code as desc for (code, desc) in $PROVINCIA'),
                            warnElement,
                            helpBlockElement;

                        cElement.append(row()
                            .append(paisElement));

                        cElement.append(row()
                            .append(tipoViaElement)
                            .append(nombreViaElement)
                            .append(numViaElement));

                        if (options.extendedInfo) {
                            cElement.append(row()
                                .append(pisoElement)
                                .append(puertaElement)
                                .append(escaleraElement)
                                .append(portalElement));
                        }

                        cElement.append(row()
                            .append(restoViaElement));

                        cElement.append(row()
                            .append(codigoPostalElement)
                            .append(poblacionElement)
                            .append(normalizationMap.provincia ? provinciaElement : undefined));

                        if (options.warn) {
                            warnElement = createAddressNormalizerWarnElement();

                            cElement.append(row()
                                .append(warnElement)
                                .hide());
                        }

                        helpBlockElement = angular.element('<div class="form-group"><div class="col-md-offset-1"><p class="help-block">' + $filter('translate')('mpAddressNormalizer.low_quality') +'</p></div></div>');

                        cElement.append(row()
                            .append(helpBlockElement)
                            .hide());
                    }

                    if (!options.hide && !cElement.contents().length) {
                        prepareDOM();
                    }

                    return function (scope, element, attributes, formCtrl, transcludeFn) {
                        var normalizationMap = $parse(attributes.mpAddressNormalizer)(),
                            options = angular.extend(angular.copy(defaultOptions), $parse(attributes.mpAddressNormalizerOptions)()),
                            normalizing,
                            normalizationStatus,
                            lastNormalization,
                            modelBeforeNormalization = {},
                            modelAfterLastSuggestionsApplied = {},
                            paisFormControl,
                            tipoViaFormControl,
                            nombreViaFormControl,
                            numViaFormControl,
                            pisoFormControl,
                            puertaFormControl,
                            escaleraFormControl,
                            portalFormControl,
                            restoViaFormControl,
                            codigoPostalFormControl,
                            poblacionFormControl,
                            provinciaFormControl,
                            deregisterLastNormalizationWatcher,
                            deregisterWarnElementOnClickListener,
                            deregisterControlWatcher,
                            deregisterPaisWatcher;

                        function saveNormalizationStatus(status) {
                            normalizationStatus = status; // NO_NORMALIZADO | NORMALIZACION_RECHAZADA | NORMALIZACION_ACEPTADA
                            if (normalizationMap.tip_situ_val) {
                                $parse(normalizationMap.tip_situ_val).assign(scope, status);
                            }
                        }

                        function createAddressNormalizerInputString() {
                            var addressNormalizerInputString = '';

                            addressNormalizerInputString += (($parse(normalizationMap.tipoVia)(scope) || {}).code || '').substring(0, options.sizes.tipoVia);
                            addressNormalizerInputString += ' ' + ($parse(normalizationMap.nombreVia)(scope) || '').substring(0, options.sizes.nombreVia);
                            addressNormalizerInputString += ' ' + ($parse(normalizationMap.numVia)(scope) || '').substring(0, options.sizes.numVia);
                            addressNormalizerInputString += ' ' + ($parse(normalizationMap.codigoPostal)(scope).toString() || '').substring(0, options.sizes.codigoPostal);
                            addressNormalizerInputString += ' ' + ($parse(normalizationMap.poblacion)(scope) || '').substring(0, options.sizes.poblacion);

                            return Utils.string.trim(Utils.string.replaceDiacritics(addressNormalizerInputString));
                        }

                        function setFormControlsDisablePropTo(value) {
                            paisFormControl.prop('disabled', value);
                            tipoViaFormControl.prop('disabled', value);
                            nombreViaFormControl.prop('disabled', value);
                            numViaFormControl.prop('disabled', value);
                            pisoFormControl.prop('disabled', value);
                            puertaFormControl.prop('disabled', value);
                            escaleraFormControl.prop('disabled', value);
                            portalFormControl.prop('disabled', value);
                            restoViaFormControl.prop('disabled', value);
                            codigoPostalFormControl.prop('disabled', value);
                            poblacionFormControl.prop('disabled', value);
                            provinciaFormControl.prop('disabled', value);
                        }

                        function disableNormalization() {
                            setFormControlsDisablePropTo(true);
                            normalizing = true;
                        }

                        function enableNormalization() {
                            setFormControlsDisablePropTo(false);
                            normalizing = false;
                        }

                        function saveModelAfterLastSuggestionsApplied() {
                            angular.forEach(normalizationMap, function(normalizationExpression, normalizationPropertyName) {
                                modelAfterLastSuggestionsApplied[normalizationPropertyName] = $parse(normalizationExpression)(scope);
                            });
                        }

                        function saveModelBeforeNormalization() {
                            angular.forEach(normalizationMap, function(normalizationExpression, normalizationPropertyName) {
                                modelBeforeNormalization[normalizationPropertyName] = $parse(normalizationExpression)(scope);
                            });
                        }

                        function applySuggestion(value, property) {
                            value = value || '';

                            if (property === 'tipoVia') {
                                // We need to reference TIPO_VIA so the select value will diplay properly
                                scope.$eval(normalizationMap[property] + '=$TIPO_VIA[' + _.findIndex(TIPO_VIA, function(via) {
                                    return via.code === value.code && via.desc === value.desc;
                                }) + ']');
                            } else if (normalizationMap[property]) {
                                var size = options.sizes[property] || defaultOptions.sizes[property];

                                if (!size) {
                                    $parse(normalizationMap[property]).assign(scope, value);
                                } else {
                                    if (value.toString().length <= size) {
                                        $parse(normalizationMap[property]).assign(scope, value);
                                    }
                                }
                            }
                        }

                        function applySuggestions(normalizationsToApply) {
                            angular.forEach(normalizationsToApply, applySuggestion);
                            saveModelAfterLastSuggestionsApplied();
                        }

                        function applyNormalization(normalizationsToApply) {
                            saveModelBeforeNormalization();
                            applySuggestions(normalizationsToApply);
                        }

                        if (normalizationMap.applyNormalization) {
                            $parse(normalizationMap.applyNormalization).assign(scope, applyNormalization);
                        }

                        function openAddressNormalizationModal(normalization) {
                            var modalOptions = {
                                size: 'lg',
                                backdrop: 'static',
                                keyboard: false,
                                scope: scope,
                                templateUrl: 'gaiafrontend/html/mpAddressNormalizerModal.html',
                                controller: 'AddressNormalizerModalCtrl',
                                resolve: {
                                    modelBeforeNormalization: function() {
                                        return modelBeforeNormalization;
                                    },
                                    modelAfterLastSuggestionsApplied: function() {
                                        return modelAfterLastSuggestionsApplied;
                                    },
                                    normalization: function() {
                                        return normalization;
                                    }
                                }
                            };

                            function areThereRejections(changesToRevert) {
                                var thereAreRejections = false;

                                angular.forEach(changesToRevert, function(value, property) {
                                    if (!angular.equals(lastNormalization[property], value)) {
                                        thereAreRejections = true;
                                    }
                                });

                                return thereAreRejections;
                            }

                            return $modal.open(modalOptions).result.then(function(changesToRevert) {
                                applySuggestions(changesToRevert);

                                if (areThereRejections(changesToRevert)) {
                                    saveNormalizationStatus(NORMALIZACION_RECHAZADA);
                                } else {
                                    saveNormalizationStatus(NORMALIZACION_ACEPTADA);
                                }
                            });
                        }

                        if (normalizationMap.openModal) {
                            $parse(normalizationMap.openModal).assign(scope, openAddressNormalizationModal);
                        }

                        function getMainControlsObject() {
                            var mainControlsObject = {};

                            angular.forEach(_.keys(normalizationMap), function(property) {
                                if (property === 'tipoVia' || property === 'nombreVia' || property === 'numVia' || property === 'codigoPostal' || property === 'poblacion') {
                                    mainControlsObject[property] = formCtrl[normalizationMap[property]];
                                }
                            });

                            return mainControlsObject;
                        }

                        function checkIfAnyControlIsInvalid(mainControlsObject) {
                            var isAnyControlInvalid = false;

                            angular.forEach(mainControlsObject, function(ngModelCtrl) {
                                if (!ngModelCtrl.$modelValue) {
                                    isAnyControlInvalid = true;
                                }
                            });

                            return isAnyControlInvalid;
                        }

                        function checkIfEveryControlIsDirty(mainControlsObject) {
                            var isEveryControlDirty = true;

                            angular.forEach(mainControlsObject, function(ngModelCtrl) {
                                if (!ngModelCtrl.$dirty) {
                                    isEveryControlDirty = false;
                                }
                            });

                            return isEveryControlDirty;
                        }

                        // TODO: Improve performance. Too many loops!
                        function validateControls() {
                            var mainControlsObject = getMainControlsObject(),
                                areControlsInvalid = checkIfAnyControlIsInvalid(mainControlsObject),
                                isEveryMainControlDirty = checkIfEveryControlIsDirty(mainControlsObject);

                            if (areControlsInvalid && isEveryMainControlDirty) {
                                angular.forEach(mainControlsObject, function(ngModelCtrl) {
                                    if (!ngModelCtrl.$modelValue) {
                                        scope.$broadcast(Events.$formControlError(formCtrl.$name + ngModelCtrl.$name), {
                                            normalization: 'Required for normalization.'
                                        });
                                    }
                                });
                            }

                            return !areControlsInvalid;
                        }

                        function hasModelChangedSinceLastNormalizationWasApplied() {
                            var modelValueHasChanged = false;

                            if (!_.isEmpty(modelAfterLastSuggestionsApplied)) {
                                angular.forEach(normalizationMap, function(normalizationExpression, normalizationPropertyName) {
                                    if ((normalizationPropertyName === 'tipoVia' || normalizationPropertyName === 'nombreVia' || normalizationPropertyName === 'numVia' || normalizationPropertyName === 'codigoPostal' || normalizationPropertyName === 'poblacion') && $parse(normalizationExpression)(scope) !== modelAfterLastSuggestionsApplied[normalizationPropertyName]) {
                                        modelValueHasChanged = true;
                                    }
                                });
                            }

                            return modelValueHasChanged;
                        }

                        function isNormalizable() {
                            return $parse(normalizationMap.pais)(scope) === PAIS_DEFAULT_VALUE && (normalizationStatus === NO_NORMALIZADO || hasModelChangedSinceLastNormalizationWasApplied());
                        }

                        function getTipoViaDeYdeCodeFromDesc(desc) {
                            return (_.find(TIPO_VIA_DEYDE, function(via) {
                                return via.desc === desc;
                            }) || {}).code || '';
                        }

                        function getProvinciaCodeFromDesc(desc) {
                            return _.findKey(PROVINCIA, function(dsc) {
                                return dsc === desc;
                            }) || '';
                        }

                        function removePaddingZeros(num) {
                            num = parseInt(num, 10);

                            if (isNaN(num)) {
                                return num;
                            }

                            return num.toString();
                        }

                        function parseNormalization(normalization) {
                            var normalizationsToApply = {},
                                parsedModel = {
                                    pais: Utils.string.trim(Utils.string.replaceDiacritics($parse(normalizationMap.pais)(scope))),
                                    tipoVia: Utils.string.trim(Utils.string.replaceDiacritics($parse(normalizationMap.tipoVia)(scope))),
                                    nombreVia: Utils.string.trim(Utils.string.replaceDiacritics($parse(normalizationMap.nombreVia)(scope))),
                                    numVia: Utils.string.trim(Utils.string.replaceDiacritics($parse(normalizationMap.numVia)(scope))),
                                    restoVia: Utils.string.trim(Utils.string.replaceDiacritics($parse(normalizationMap.restoVia)(scope) || '')),
                                    codigoPostal: Utils.string.trim(Utils.string.replaceDiacritics($parse(normalizationMap.codigoPostal)(scope))),
                                    poblacion: Utils.string.trim(Utils.string.replaceDiacritics($parse(normalizationMap.poblacion)(scope))),
                                    provincia: Utils.string.trim(Utils.string.replaceDiacritics($parse(normalizationMap.provincia)(scope) || ''))
                                },
                                parsedNormalization = {
                                    pais: Utils.string.trim(normalization.pais),
                                    tipoVia: Utils.string.trim(getTipoViaDeYdeCodeFromDesc(normalization.tipoVia)),
                                    nombreVia: Utils.string.trim(normalization.nombreVia),
                                    numVia: Utils.string.trim(removePaddingZeros(normalization.numVia)),
                                    restoVia: Utils.string.trim(normalization.restoVia),
                                    codigoPostal: +Utils.string.trim(normalization.codigoPostal), // plus sign to parse to integer
                                    poblacion: Utils.string.trim(normalization.poblacion),
                                    provincia: Utils.string.trim(getProvinciaCodeFromDesc(normalization.provincia)),
                                    varPob: Utils.string.trim(normalization.varPob),
                                    mujPob: Utils.string.trim(normalization.mujPob),
                                    indica: Utils.string.trim(normalization.indica),
                                    infia: Utils.string.trim(normalization.infia),
                                    interno: Utils.string.trim(normalization.interno)
                                };

                            if (parsedNormalization.pais && !angular.equals(parsedModel.pais, parsedNormalization.pais)) {
                                normalizationsToApply.pais = parsedNormalization.pais;
                            }

                            if (parsedModel.tipoVia && parsedModel.tipoVia.code && parsedNormalization.tipoVia && !angular.equals(parsedModel.tipoVia.code, parsedNormalization.tipoVia)) {
                                normalizationsToApply.tipoVia = parsedNormalization.tipoVia;
                            }

                            if (parsedModel.nombreVia && parsedNormalization.nombreVia && !angular.equals(parsedModel.nombreVia, parsedNormalization.nombreVia)) {
                                normalizationsToApply.nombreVia = parsedNormalization.nombreVia;
                            }

                            if (parsedModel.numVia && parsedNormalization.numVia && !angular.equals(parsedModel.numVia, parsedNormalization.numVia)) {
                                normalizationsToApply.numVia = parsedNormalization.numVia;
                            }

                            if (parsedNormalization.restoVia && !angular.equals(parsedModel.restoVia, parsedNormalization.restoVia)) {
                                normalizationsToApply.restoVia = parsedNormalization.restoVia;
                            }

                            if (parsedModel.codigoPostal && parsedNormalization.codigoPostal && !angular.equals(parsedModel.codigoPostal, parsedNormalization.codigoPostal)) {
                                normalizationsToApply.codigoPostal = parsedNormalization.codigoPostal;
                            }

                            if (parsedModel.poblacion && parsedNormalization.poblacion && !angular.equals(parsedModel.poblacion, parsedNormalization.poblacion)) {
                                normalizationsToApply.poblacion = parsedNormalization.poblacion;
                            }

                            if (parsedNormalization.provincia && !angular.equals(parsedModel.provincia, parsedNormalization.provincia)) {
                                normalizationsToApply.provincia = parsedNormalization.provincia;
                            }

                            normalizationsToApply.varPob = parsedNormalization.varPob;
                            normalizationsToApply.mujPob = parsedNormalization.mujPob;
                            normalizationsToApply.indica = parsedNormalization.indica;
                            normalizationsToApply.infia = parsedNormalization.infia;
                            normalizationsToApply.interno = parsedNormalization.interno;

                            return normalizationsToApply;
                        }

                        function displayNonReliableNormalizationAlert(display) {
                            var helpBlockRow = element.find('.help-block').closest('.row').show();

                            if (display) {
                                helpBlockRow.show();
                            } else {
                                helpBlockRow.hide();
                            }
                        }

                        function setMainControlsPristine() {
                            var mainControlsObject = getMainControlsObject();

                            angular.forEach(mainControlsObject, function(ngModelCtrl) {
                                ngModelCtrl.$setPristine();
                            });
                        }

                        function normalize() {
                            var deferred = $q.defer();

                            if (normalizing) {
                                deferred.reject();
                                return deferred.promise;
                            }

                            if (!validateControls()) {
                                deferred.reject();
                                return deferred.promise;
                            }

                            if (!isNormalizable()) {
                                deferred.reject();
                                return deferred.promise;
                            }

                            disableNormalization();
                            AddressNormalizerSrv.normalize(createAddressNormalizerInputString())
                                .then(function(normalization) {
                                    var normalizationsToApply = parseNormalization(normalization);
                                    setMainControlsPristine();
                                    displayNonReliableNormalizationAlert(+normalization.infia < 6);
                                    applyNormalization(normalizationsToApply);
                                    lastNormalization = normalizationsToApply;
                                    saveNormalizationStatus(NORMALIZACION_ACEPTADA);
                                    deferred.resolve(normalizationsToApply);
                                }, deferred.reject)['finally'](enableNormalization);

                            return deferred.promise;
                        }

                        if (normalizationMap.normalize) {
                            $parse(normalizationMap.normalize).assign(scope, normalize);
                        }

                        function listenWarnElementOnClick() {
                            var warnElements = element.find('a.contact-normalizer-warn-anchor,img.contact-normalizer-warn-img');

                            function onClickFn(event) {
                                openAddressNormalizationModal(lastNormalization);
                                event.preventDefault();
                            }

                            function preventDefaultFn(event) {
                                event.preventDefault();
                            }

                            warnElements.off('click', onClickFn);
                            warnElements.on('click', onClickFn);

                            return function() {
                                warnElements.off('click', preventDefaultFn);
                                warnElements.on('click', preventDefaultFn);
                            };
                        }

                        function hasAnyMainControlBeenNormalized(lastNormalization) {
                            var mainControlsObject = getMainControlsObject(),
                                anyMainControlHasBeenNormalized = false;

                            angular.forEach(lastNormalization, function(value, property) {
                                if (mainControlsObject[property]) {
                                    anyMainControlHasBeenNormalized = true;
                                }
                            });

                            return anyMainControlHasBeenNormalized;
                        }

                        function updateIncam() {
                            var mainControlsObject = getMainControlsObject(),
                                incam = {};

                            if (normalizationMap.incam) {
                                angular.forEach(mainControlsObject, function(ngModelCtrl, property) {
                                    if (lastNormalization) {
                                        incam[property] = angular.equals(ngModelCtrl.$modelValue, lastNormalization[property]);
                                    } else {
                                        incam[property] = false;
                                    }
                                });

                                $parse(normalizationMap.incam).assign(scope, incam);
                            }
                        }

                        function manageWarnRowVisibility() {
                            var warnRow = element.find('a.contact-normalizer-warn-anchor').closest('.row');

                            if (lastNormalization && !_.isEmpty(lastNormalization)) {
                                if (hasAnyMainControlBeenNormalized(lastNormalization) || (lastNormalization.provincia && modelAfterLastSuggestionsApplied.provincia && !angular.equals(modelAfterLastSuggestionsApplied.provincia, lastNormalization.provincia))) {
                                    warnRow.show();
                                } else {
                                    warnRow.hide();
                                }
                            } else {
                                warnRow.hide();
                            }
                        }

                        function watchLastNormalization() {
                            return scope.$watch(function() {
                                return lastNormalization;
                            }, function() {
                                updateIncam();
                                manageWarnRowVisibility();
                            });
                        }

                        function watchControlChanges() {
                            return scope.$watch(function() {
                                return hasModelChangedSinceLastNormalizationWasApplied();
                            }, function(hasModelChangedSinceLastNormalizationWasApplied) {

                                updateIncam();

                                if (hasModelChangedSinceLastNormalizationWasApplied && normalizationStatus !== NORMALIZACION_RECHAZADA) {
                                    saveNormalizationStatus(NORMALIZACION_RECHAZADA);
                                } else if (!hasModelChangedSinceLastNormalizationWasApplied && normalizationStatus === NORMALIZACION_RECHAZADA) {
                                    saveNormalizationStatus(NORMALIZACION_ACEPTADA);
                                }
                            });
                        }

                        function watchPaisChanges() {
                            return scope.$watch(normalizationMap.pais, function(pais) {
                                if (pais === PAIS_DEFAULT_VALUE) {
                                    codigoPostalFormControl.attr('maxlength', 5);
                                } else {
                                    codigoPostalFormControl.attr('maxlength', options.sizes.codigoPostal || defaultOptions.sizes.codigoPostal);
                                }
                            });
                        }

                        function deregisterWarnWatchersAndEventListeners() {
                            deregisterLastNormalizationWatcher();
                            deregisterWarnElementOnClickListener();
                        }

                        function deregisterWatchersAndEventListeners() {
                            deregisterControlWatcher();
                            deregisterPaisWatcher();
                        }

                        function watchWarnChangesAndListenEvents() {
                            deregisterLastNormalizationWatcher = watchLastNormalization();
                            deregisterWarnElementOnClickListener = listenWarnElementOnClick();
                        }

                        function watchChangesAndListenEvents() {
                            deregisterControlWatcher = watchControlChanges();
                            deregisterPaisWatcher = watchPaisChanges();
                        }

                        function watchAndListen() {
                            if (options.warn) {
                                watchWarnChangesAndListenEvents();
                            }

                            watchChangesAndListenEvents();
                        }

                        function stopWatchingAndListening() {
                            if (options.warn) {
                                deregisterWarnWatchersAndEventListeners();
                            }

                            deregisterWatchersAndEventListeners();
                        }

                        validate(normalizationMap);

                        transcludeFn(scope, function (clone) {
                            element.append(clone);
                        });

                        saveNormalizationStatus(NO_NORMALIZADO);

                        $parse(normalizationMap.pais).assign(scope, PAIS_DEFAULT_VALUE);

                        paisFormControl = element.find('[ng-model="' + normalizationMap.pais + '"]');
                        tipoViaFormControl = element.find('[ng-model="' + normalizationMap.tipoVia + '"]');
                        nombreViaFormControl = element.find('[ng-model="' + normalizationMap.nombreVia + '"]');
                        numViaFormControl = element.find('[ng-model="' + normalizationMap.numVia + '"]');
                        pisoFormControl = element.find('[ng-model="' + normalizationMap.piso + '"]');
                        puertaFormControl = element.find('[ng-model="' + normalizationMap.puerta + '"]');
                        escaleraFormControl = element.find('[ng-model="' + normalizationMap.escalera + '"]');
                        portalFormControl = element.find('[ng-model="' + normalizationMap.portal + '"]');
                        restoViaFormControl = element.find('[ng-model="' + normalizationMap.restoVia + '"]');
                        codigoPostalFormControl = element.find('[ng-model="' + normalizationMap.codigoPostal + '"]');
                        poblacionFormControl = element.find('[ng-model="' + normalizationMap.poblacion + '"]');
                        provinciaFormControl = element.find('[ng-model="' + normalizationMap.provincia + '"]');

                        watchAndListen();

                        element.on('$destroy', stopWatchingAndListening);
                    };
                }
            };
        }
    ]);

/*global angular */
angular.module('mpAlert', [])
    .constant('MpAlertConfig', {
        types: {
            success: 'success',
            info: 'info',
            warning: 'warning',
            danger: 'danger'
        }
    })
    .controller('MpAlertCtrl', ['$scope', '$attrs', 'MpAlertConfig', function ($scope, $attrs, MpAlertConfig) {
        $scope.defaultType = MpAlertConfig.types.warning;
        $scope.closeable = $attrs.hasOwnProperty('mpAlertClose');
        $scope.hasCodeToDisplay = $attrs.hasOwnProperty('mpAlertCode') && $scope.code();
    }])
    /**
        * @doc-component directive
        * @name gaiafrontend.directive.mpAlert
        * @description
        * This component has been migrated to "GAIA Site"
        * There you will find its documentation and several examples.
        * "GAIA Site" is an application created by the Architecture Area to learn and play with GAIA. Is available in RAS. Direct links are available below in this page.
        * @example
        <doc:example>
             <doc:source>
             label GAIA site direct links are:
             a(href='https://wportalinterno.es.mapfre.net/com.ibm.ram.repository.web/faces/_rlvid.jsp?_rap=!assetDetails&_rvip=/home.jsp&guid=13A33828-B921-8DC5-DEDA-8B8D7C0EBC81') Intranet /
             a(href='https://wportalinterno.mapfre.com/com.ibm.ram.repository.web/faces/_rlvid.jsp?_rap=!assetDetails&_rvip=/home.jsp&guid=13A33828-B921-8DC5-DEDA-8B8D7C0EBC81') Internet
             </doc:source>
        </doc:example>
    */
    .directive('mpAlert', function () {
        return {
            templateUrl: 'gaiafrontend/html/alert.html',
            controller: 'MpAlertCtrl',
            transclude: true,
            replace: true,
            scope: {
                type: '@mpAlert',
                close: '&mpAlertClose',
                code: '&mpAlertCode'
            }
        };
    });

/*    LET THIS COMMENT HERE UNTIL ERROR DATA MODEL HAS BEEN REVIEWED*/
/*    .directive('mpAlert', ['$window', 'AlertSrv',
        function($window, AlertSrv) {
            return {
                templateUrl: "gaiafrontend/html/alert.html",

                link: function(scope) {
                    scope.alert = AlertSrv.getAlert();
                    scope.removeAlert = AlertSrv.removeAlert;
                    scope.$watch('alert', function (alert) {
                        if (alert) {
                            $window.scrollTo(0, 0);
                        }
                    }, true);
                }
            };
        }])
    .directive('mpValidationError', function() {
        return {
            restrict: 'A',
            replace: true,
            template: '<a href=""></a>',
            link: function(scope, elem, attrs) {
                var errorText = attrs.mpValidationError,
                    formName = attrs.mpValidationErrorFormName,
                    inputName = attrs.mpValidationErrorInputName,
                    formElem = formName ? angular.element('form[name="' + formName + '"]') : undefined,
                    formScope = formElem && formElem.length ? formElem.scope() : undefined,
                    inputElem = formElem && formElem.length ? formElem.find('[name="' + inputName + '"]') : undefined;

                function forceFormValidationErrorBehaviour() {
                    formScope[formName][inputName].$setValidity('server', false);
                    angular.extend(formScope[formName][inputName], {$errorText: errorText});

                    inputElem.on('focus', function () {
                        scope.$apply(function () {
                            formScope[formName][inputName].$setValidity('server', true);
                        });
                    });
                }

                function addValidationErrorLinkBehaviour() {
                    elem.text(errorText)
                        .on('click', function(ev) {
                            ev.preventDefault();

                            if (inputElem && inputElem.length) {
                                inputElem.focus();
                            }
                        });
                }

                forceFormValidationErrorBehaviour();
                addValidationErrorLinkBehaviour();
            }
        };
    });
*/

/*global angular */
angular.module('mpAlerts', [])
    /**
     * @doc-component service
     * @name gaiafrontend.service.alertsSrv
     * @description
     * This service allows you to store alerts.
     *
     * This service is used by `mpAlert` directive to display alerts.
     * @example
       <doc:example>
        <doc:source>
        script
            function MyCtrl($scope, AlertsSrv) {
                $scope.addError = function () {
                    var alert = {
                        title: "Error",
                        description: "Validation error",
                        details: ["ZIP code is not valid."]
                    };

                    AlertsSrv.danger(alert, alert);
                };
            }
            MyCtrl.$inject = ["$scope", "AlertsSrv"];
        div(ng-controller="MyCtrl", ng-hide="hide")
            div(mp-alerts)
            p
                button.btn.btn-default(type="button", ng-click="addError()") Add error
        </doc:source>
       </doc:example>
     */
    .factory('AlertsSrv', ['MpAlertConfig', function (MpAlertConfig) {
        var alerts = [];

        function addAlert(alert) {
            alerts.unshift(alert);
        }

        /**
         * @doc-component method
         * @methodOf gaiafrontend.service.alertsSrv
         * @name gaiafrontend.service.alertsSrv#Alert
         * @param {string=} title Alert title.
         * @param {string=} description Alert description.
         * @param {array=} errors Error objects array. Each error object should have these properties: `form`, `formControl` and `description`
         * @return {object} An Alert instance with the following methods. `addError(description[, form, formControl])` Adds a validation error to the Alert. `form` is the form name. `formControl` is the control (input, textarea, select) name. `description` is the text to display. `clearErrors()` Clear the Alert errors.
         * @description
         * This is an Alert constructor.
         */
        function Alert(title, description) {
            this.title = title || '';
            this.description = description || '';
            this.errors = [];
        }
        Alert.prototype.addError = function (description, form, formControl) {
            var error = {
                form: form,
                formControl: formControl,
                description: description
            };

            this.errors.push(error);

            return error;
        };
        Alert.prototype.clearErrors = function () {
            return this.errors.splice(0, this.errors.length);
        };
        /**
         * @doc-component method
         * @methodOf gaiafrontend.service.alertsSrv
         * @name gaiafrontend.service.alertsSrv#success
         * @param {object} content Object containing the success alert content.
         * @param {expression=} code Expression that once evaluated will be displayed as code inside the alert box.
         * @description
         * This method adds a success alert.
         */
        function success(content, code) {
            var alert = {};
            alert.type = MpAlertConfig.types.success;
            alert.content = content;
            if (code) {
                alert.code = code;
            }

            addAlert(alert);
        }

        /**
         * @doc-component method
         * @methodOf gaiafrontend.service.alertsSrv
         * @name gaiafrontend.service.alertsSrv#info
         * @param {object} content Object containing the info alert content.
         * @param {expression=} code Expression that once evaluated will be displayed as code inside the alert box.
         * @description
         * This method adds an info alert.
         */
        function info(content, code) {
            var alert = {};
            alert.type = MpAlertConfig.types.info;
            alert.content = content;
            if (code) {
                alert.code = code;
            }

            addAlert(alert);
        }

        /**
         * @doc-component method
         * @methodOf gaiafrontend.service.alertsSrv
         * @name gaiafrontend.service.alertsSrv#warning
         * @param {object} content Object containing the warning alert content.
         * @param {expression=} code Expression that once evaluated will be displayed as code inside the alert box.
         * @description
         * This method adds a warning alert.
         */
        function warning(content, code) {
            var alert = {};
            alert.type = MpAlertConfig.types.warning;
            alert.content = content;
            if (code) {
                alert.code = code;
            }

            addAlert(alert);
        }


        /**
         * @doc-component method
         * @methodOf gaiafrontend.service.alertsSrv
         * @name gaiafrontend.service.alertsSrv#danger
         * @param {object} content Object containing the danger alert content.
         * @param {expression=} code Expression that once evaluated will be displayed as code inside the alert box.
         * @description
         * This method adds a danger alert.
         */
        function danger(content, code) {
            var alert = {};
            alert.type = MpAlertConfig.types.danger;
            alert.content = content;
            if (code) {
                alert.code = code;
            }

            addAlert(alert);
        }


        /**
         * @doc-component method
         * @methodOf gaiafrontend.service.alertsSrv
         * @name gaiafrontend.service.alertsSrv#get
         * @return {array} An array with the current alerts.
         * @description
         * This method returns an array with all the alerts stored.
         */
        function getAlerts() {
            return alerts;
        }

        /**
         * @doc-component method
         * @methodOf gaiafrontend.service.alertsSrv
         * @name gaiafrontend.service.alertsSrv#remove
         * @param {integer} index Index of the alert we want to remove
         * @description
         * This method removes the indicated alert from the stored alerts..
         */
        function removeAlert(index) {
            alerts.splice(index, 1);
        }

        /**
         * @doc-component method
         * @methodOf gaiafrontend.service.alertsSrv
         * @name gaiafrontend.service.alertsSrv#clear
         * @description
         * This method clear all alerts stored.
         */
        function clearAlerts() {
            alerts.splice(0, alerts.length);
        }

        return {
            Alert: Alert,
            success: success,
            info: info,
            warning: warning,
            danger: danger,
            error: danger,
            get: getAlerts,
            remove: removeAlert,
            clear: clearAlerts
        };
    }])
    /**
        * @doc-component directive
        * @name gaiafrontend.directive.mpAlerts
        * @description
        * This component has been migrated to "GAIA Site"
        * There you will find its documentation and several examples.
        * "GAIA Site" is an application created by the Architecture Area to learn and play with GAIA. Is available in RAS. Direct links are available below in this page.
        * @example
        <doc:example>
             <doc:source>
             label GAIA site direct links are:
             a(href='https://wportalinterno.es.mapfre.net/com.ibm.ram.repository.web/faces/_rlvid.jsp?_rap=!assetDetails&_rvip=/home.jsp&guid=13A33828-B921-8DC5-DEDA-8B8D7C0EBC81') Intranet /
             a(href='https://wportalinterno.mapfre.com/com.ibm.ram.repository.web/faces/_rlvid.jsp?_rap=!assetDetails&_rvip=/home.jsp&guid=13A33828-B921-8DC5-DEDA-8B8D7C0EBC81') Internet
             </doc:source>
        </doc:example>
    */
    .directive('mpAlerts', ['AlertsSrv', '$rootScope', 'Events', function (AlertsSrv, $rootScope, Events) {
        return {
            templateUrl: 'gaiafrontend/html/alerts.html',
            scope: true,
            link: function (scope, elem) {
                elem.addClass('mp-alerts');

                scope.alerts = AlertsSrv.get();

                scope.remove = AlertsSrv.remove;

                scope.clear = AlertsSrv.clear;

                scope.focusFormControl = function (form, formControl) {
                    if (form && formControl) {
                        $rootScope.$broadcast(Events.$formControlFocus(form + formControl));
                    }
                };

                scope.$on('$stateChangeSuccess', function() {
                    AlertsSrv.clear();
                });
            }
        };
    }]);

/*global angular, _ */
angular.module('mpAutoCompleteAddresses', [])
    /**
     * @doc-component service
     * @name gaiafrontend.service.autoCompleteAddressesFactory
     * @description
     * This service has been migrated to "GAIA Site"
     * There you will find its documentation and several examples.
     * "GAIA Site" is an application created by the Architecture Area to learn and play with GAIA. Is available in RAS. Direct links are available below in this page.
     */
    .factory('AutoCompleteAddressesFactory', ['$q', 'HttpSrv', function ($q, HttpSrv) {
        var url = 'api/autocomplete/address',
            cache = {};

        function AutoCompleteAddressesFactory() {
            var abortLastRequest = angular.noop;

            function isCityInCache(cache, address) {
                return !!_.find(cache, function(cityCache) {
                    return cityCache.nombreVia === address
                })
            }

            this.post = function post(address, postalCode, city) {
                var deferred = $q.defer(),
                    aborter = $q.defer();

                if (address && postalCode && !isCityInCache(cache, address)) {
                    abortLastRequest();
                    abortLastRequest = function () {
                        aborter.resolve();
                    };

                    HttpSrv.post(url, {address: address, postalCode: postalCode, city: city || null}, null, {timeout: aborter.promise})
                        .then(function (data) {
                            deferred.resolve(data);
                            cache = data.addresses;
                        }, function () {
                            deferred.resolve({addresses: []});
                        });
                } else {
                    deferred.resolve({addresses: []});
                }

                return deferred.promise;
            };
        }

        return AutoCompleteAddressesFactory;
    }])
    /**
     * @doc-component directive
     * @name gaiafrontend.directive.mpAutoCompleteAddresses
     * @param {expression} mpAutoCompleteAddressesModel Model that stores the address
     * @param {expression} mpAutoCompleteAddressesPostalCode Postal/Zip code required for service call
     * @param {expression} mpAutoCompleteAddressesCityCode City code optional for service call
     * @description
     * Input that allows auto complete addresses.
     * @example
       <doc:example module="mpAutoCompleteAddresses">
        <doc:source>
        label The example is currently unavailable. If you want to try this component out, you can visit:
        a(href='http://vles044273-008:8081/issuestracker/login.html#/') Issuestracker
        h2 Log in
        h4 User: UGAIA1
        h4 Password: UGAIA1
        h4 Navigate to Normalizations submenu.
        </doc:source>
       </doc:example>
     */
    .directive('mpAutoCompleteAddresses', ['$compile', 'AutoCompleteAddressesFactory', function ($compile, AutoCompleteAddressesFactory) {
        return {
            priority: 9999,
            terminal: true,
            scope: true,
            require: '^form',
            link: function (scope, element, attrs, formCtrl) {
                attrs.$set('bsTypeahead', attrs.mpAutoCompleteAddresses);
                attrs.$set('ngModel', attrs.mpAutoCompleteAddressesModel);
                attrs.$set('ngOptions', 'address.nombreVia as address.nombreVia for address in getAddresses($viewValue,' + attrs.mpAutoCompleteAddressesPostalCode + ',' + attrs.mpAutoCompleteAddressesCityCode + ')');
                angular.forEach(attrs.$attr, function (attr) {
                    if (attr.indexOf('mp-auto-complete-addresses') > -1) {
                        element.removeAttr(attr);
                    }
                });
                $compile(element)(scope);

                var suggester = new AutoCompleteAddressesFactory();

                scope.getAddresses = function (address, postalCode, city) {
                    if (formCtrl[attrs.name].$valid) {
                        return suggester.post(address, postalCode, city)
                        .then(function(res) {
                            return res.addresses;
                        });
                    }
                };
            }
        };
    }]);

/*global angular, _*/
angular.module('mpAutoCompleteCity', [])
    /**
     * @doc-component service
     * @name gaiafrontend.service.autoCompleteCitySrv
     * @description
     * This service has been migrated to "GAIA Site"
     * There you will find its documentation and several examples.
     * "GAIA Site" is an application created by the Architecture Area to learn and play with GAIA. Is available in RAS. Direct links are available below in this page.
     */
    .factory('AutoCompleteCitySrv', ['$q', 'HttpSrv', function ($q, HttpSrv) {
            var url = 'api/autocomplete/city/:postalCode',
                cache = {};

            function AutoCompleteCityFactory() {
                var abortLastRequest = angular.noop;

                function isCityInCache(cache, city) {
                    return !!_.find(cache, function(cityCache) {
                        return cityCache.poblacion === city
                    })
                }

                this.get = function get(postalCode, city) {
                    var deferred = $q.defer(),
                        aborter = $q.defer();

                    if (postalCode && city && !isCityInCache(cache, city)) {
                        abortLastRequest();
                        abortLastRequest = function () {
                            aborter.resolve();
                        };

                        HttpSrv.get(url, {postalCode: postalCode}, {params: {city: city}}, {timeout: aborter.promise})
                            .then(function (data) {
                                deferred.resolve(data);
                                cache = data.cities;
                            }, function () {
                                deferred.resolve({cities: []});
                            });
                    } else {
                        deferred.resolve({cities: []});
                    }
                    return deferred.promise;
                };
            }
            return AutoCompleteCityFactory;
        }])
    /**
     * @doc-component directive
     * @name gaiafrontend.directive.mpAutoCompleteCity
     * @param {expression} mpAutoCompleteCityModel Model that stores the locality
     * @param {expression} mpAutoCompleteCityPostalCode Postal/Zip code required for service call
     * @description
     * Input that allows auto complete locality.
     * @example
       <doc:example module="mpAutoCompleteCity">
        <doc:source>
        label The example is currently unavailable. If you want to try this component out, you can visit:
        a(href='http://vles044273-008:8081/issuestracker/login.html#/') Issuestracker
        h2 Log in
        h4 User: UGAIA1
        h4 Password: UGAIA1
        h4 Navigate to Normalizations submenu.
        </doc:source>
       </doc:example>
     */
    .directive('mpAutoCompleteCity', ['$compile', 'AutoCompleteCitySrv', function ($compile, AutoCompleteCitySrv) {
        return {
            priority: 9999,
            terminal: true,
            scope: true,
            require: '^form',
            link: function (scope, element, attrs, formCtrl) {
                attrs.$set('bsTypeahead', attrs.mpAutoCompleteCity);
                attrs.$set('ngModel', attrs.mpAutoCompleteCityModel);
                attrs.$set('ngOptions', 'city.poblacion as city.poblacion for city in getCities(' + attrs.mpAutoCompleteCityPostalCode + ', $viewValue)');
                angular.forEach(attrs.$attr, function (attr) {
                    if (attr.indexOf('mp-auto-complete-city') > -1) {
                        element.removeAttr(attr);
                    }
                });
                $compile(element)(scope);

                var suggester = new AutoCompleteCitySrv(),
                    cache = {};

                scope.getCities = function (postalCode, city) {
                    if (formCtrl[attrs.name].$valid) {
                        return suggester.get(postalCode, city)
                            .then(function(res) {
                                angular.forEach(res.cities, function (city) {
                                    cache[city.poblacion] = city.identificador;
                                });
                                return res.cities;
                            });
                    }
                };
                scope.$watch(attrs.ngModel, function (poblacion) {
                    if (poblacion) {
                        scope[attrs.mpAutoCompleteCityId] = cache[poblacion];
                        cache = {};
                    }
                });
            }
        };
    }]);

/*TODO: REVIEW*/
/**
 * @doc-component directive
 * @name gaiafrontend.directive.mpCarousel
 * @param {string} mpCarousel An array with the paths of the images of the carousel.
 * @description
 * This component is used to display a carousel with a collection of images.
 * @example
   <doc:example module="mpCarousel">
    <doc:source>
    json = '{"data" : ["resources/img/usercontent/flower1.jpg","resources/img/usercontent/flower2.jpg"]}'
    div(mp-carousel=json)
    </doc:source>
   </doc:example>
 */
/*global angular */
angular.module('mpCarousel', ['utils'])
    .directive('mpCarousel', function() {
        return {
            replace: true,
            templateUrl: 'gaiafrontend/html/carousel.html',
            link: function(scope, elm, attrs) {
                var loadedImages = angular.fromJson(attrs.mpCarousel);
                scope.images = loadedImages.data;
            }

        };
    })
    .directive('mpCarouselEnd', ['Loader',
        function(Loader) {
            var loadPlugin = Loader.load;

            return {
                restrict: 'A',
                link: function(scope, elm) {
                    function showCarousel() {
                        elm.parent().jcarousel({
                            'scroll': 1
                        });
                    }

                    if (scope.$last) {
                        loadPlugin('jquery.jcarousel.js').then(showCarousel);
                    }
                }

            };
        }]);

/**
* @doc-component directive
* @name gaiafrontend.directive.mpCarouselNavigator
* @param {object} mp-carousel-navigator-options           An object with the options to configure the carousel; posible options are: **visibleItems** and **responsive**. Further info look below
* @param {expression=} is-closed Allows Allows open or close the component since beginning.
*
* Is necessary to add the visibility options of the carousel in the controller. In visible items, is necesary to add the maximum number of items in screen. The parameter "visibleItems" must be equal to the paramter "items" for resolution of 1400, them, we can add the number of items we want to see in each resolution.
* **Items** from the array **mp-carousel-navigator-items** must have the following properties
*
* @param {[objects]} mp-carousel-navigator-items          An array with the items that the carousel will display.
*
* - `name`          : Text to display in the link.
* - `imgSrc`        : Default image in the link.
* - `imgActive`     : Image in active state.
* - `afterClickFn`  : A callback function that's is going to be called after a item is been marked as active ( if you plan to use is as a navigator, you may call the state service to change the current state path)
*   It receives the following as parameters `(event, currentActiveItem, OwlPluginInstance)`.
*
* @param {Number} mp-carousel-navigator-active-item-index - This variable / `ngModel` is binded to the current active item index. It will change if the you select a new item in the carousel
* , and it will change the carousel current active item if it's changed programmaticly triggering the `afterClickFn`
* Like the JavaScript onchange event which only triggers at the end of a change (usually, when the user leaves the form element or presses the return key).
*
* @description
* Component mp-carousel-navigator is a responsive, mobile featured (swipe, etc...) and fully customizable.
* @example
  <doc:example module="mpCarouselNavigator">
    <doc:source>
    script
        function MyCtrl($scope) {
            'use strict';
            $scope.items = [
                {
                    name        : 'Agrupaciones'
                    , imgSrc    : '/gaiafrontend/img/ico-navbar-bottom/mp-ico-agrupaciones.png'
                    , imgActive : '/gaiafrontend/img/ico-navbar-bottom/mp-ico-agrupaciones-big.png'
                    , afterClickFn : function() { console.log('Agrupaciones'); }
                }, {
                    name           : 'Selección'
                    , imgSrc       : '/gaiafrontend/img/ico-navbar-bottom/mp-ico-seleccion.png'
                    , imgActive    : '/gaiafrontend/img/ico-navbar-bottom/mp-ico-seleccion-big.png'
                    , afterClickFn : function() { console.log('Selección'); }
                }, {
                    name        : 'Datos anulación'
                    , imgSrc    : '/gaiafrontend/img/ico-navbar-bottom/mp-ico-anulaciones.png'
                    , imgActive : '/gaiafrontend/img/ico-navbar-bottom/mp-ico-anulaciones-big.png'
                    , afterClickFn : function() { console.log('Datos anulación'); }
                }, {
                    name        : 'Coaseguro'
                    , imgSrc    : '/gaiafrontend/img/ico-navbar-bottom/mp-ico-coaseguro.png'
                    , imgActive : '/gaiafrontend/img/ico-navbar-bottom/mp-ico-coaseguro-big.png'
                    , afterClickFn : function() { console.log( 'Coaseguro'); }
                }, {
                    name        : 'Garantías del contrato'
                    , imgSrc    : '/gaiafrontend/img/ico-navbar-bottom/mp-ico-garantias.png'
                    , imgActive : '/gaiafrontend/img/ico-navbar-bottom/mp-ico-garantias-big.png'
                    , afterClickFn : function() { console.log( 'Garantías del contrato'); }
                }, {
                    name        : 'Grupos'
                    , imgSrc    : '/gaiafrontend/img/ico-navbar-bottom/mp-ico-grupo.png'
                    , imgActive : '/gaiafrontend/img/ico-navbar-bottom/mp-ico-grupo-big.png'
                    , afterClickFn : function() { console.log( 'Grupos'); }
                }, {
                    name        : 'Movilizaciones'
                    , imgSrc    : '/gaiafrontend/img/ico-navbar-bottom/mp-ico-movilizaciones.png'
                    , imgActive : '/gaiafrontend/img/ico-navbar-bottom/mp-ico-movilizaciones-big.png'
                    , afterClickFn : function() { console.log( 'Movilizaciones'); }
                }, {
                    name        : 'Prestaciones y rescates'
                    , imgSrc    : '/gaiafrontend/img/ico-navbar-bottom/mp-ico-prestaciones.png'
                    , imgActive : '/gaiafrontend/img/ico-navbar-bottom/mp-ico-prestaciones-big.png'
                    , afterClickFn : function() { console.log( 'Prestaciones y rescates'); }
                }, {
                    name        : 'Productores'
                    , imgSrc    : '/gaiafrontend/img/ico-navbar-bottom/mp-ico-productores.png'
                    , imgActive : '/gaiafrontend/img/ico-navbar-bottom/mp-ico-productores-big.png'
                    , afterClickFn : function() { console.log( 'Productores'); }
                }, {
                    name        : 'Reajustes'
                    , imgSrc    : '/gaiafrontend/img/ico-navbar-bottom/mp-ico-reajustes.png'
                    , imgActive : '/gaiafrontend/img/ico-navbar-bottom/mp-ico-reajustes-big.png'
                    , afterClickFn : function() { console.log( 'Reajustes'); }
                }, {
                    name        : 'Renovación'
                    , imgSrc    : '/gaiafrontend/img/ico-navbar-bottom/mp-ico-renovacion.png'
                    , imgActive : '/gaiafrontend/img/ico-navbar-bottom/mp-ico-renovacion-big.png'
                    , afterClickFn : function() { console.log( 'Renovación'); }
                }, {
                    name        : 'Selección'
                    , imgSrc    : '/gaiafrontend/img/ico-navbar-bottom/mp-ico-seleccion.png'
                    , imgActive : '/gaiafrontend/img/ico-navbar-bottom/mp-ico-seleccion-big.png'
                    , afterClickFn : function() { console.log( 'Selección'); }
                }, {
                    name        : 'Textos'
                    , imgSrc    : '/gaiafrontend/img/ico-navbar-bottom/mp-ico-texto.png'
                    , imgActive : '/gaiafrontend/img/ico-navbar-bottom/mp-ico-texto-big.png'
                    , afterClickFn : function() { console.log( 'Textos'); }
                }, {
                    name        : 'Tomador'
                    , imgSrc    : '/gaiafrontend/img/ico-navbar-bottom/mp-ico-tomador.png'
                    , imgActive : '/gaiafrontend/img/ico-navbar-bottom/mp-ico-tomador-big.png'
                    , afterClickFn : function() { console.log( 'Tomador'); }
                }, {
                    name        : 'Primas y recibos'
                    , imgSrc    : '/gaiafrontend/img/ico-navbar-bottom/mp-ico-primas-recibos.png'
                    , imgActive : '/gaiafrontend/img/ico-navbar-bottom/mp-ico-primas-recibos-big.png'
                    , afterClickFn : function() { console.log( 'Primas y recibos'); }
                }
            ];
            $scope.options = {
                visibleItems: 9
                , responsive : {
                    0 : {
                      items:1
                    }
                    , 480:{
                      items:3
                    }
                    , 768:{
                      items:5
                    }
                    , 1028:{
                      items:7
                    }
                    , 1400:{
                      items:9
                    }
                }
            };

            $scope.to = function(ix) {
                $scope.activeItemIndex = ix;
                $scope.test = ix;
            };
        }
        MyCtrl.$inject = ["$scope"];

    div(ng-controller="MyCtrl")
        button(ng-click="to(2)") @@carousel_navigator_go_to 2
        button(ng-click="to(3)") @@carousel_navigator_go_to 3
        button(ng-click="to(9)") @@carousel_navigator_go_to 9
        button(ng-click="to(0)") @@carousel_navigator_go_to 0

        p @@carousel_navigator_change_input_text <input ng-init="activeItemIndex = 1" ng-model="activeItemIndex" />
        div(mp-carousel-navigator, mp-carousel-navigator-active-item-index="activeItemIndex", mp-carousel-navigator-options="options", mp-carousel-navigator-items="items")
    </doc:source>
  </doc:example>
*/
/*global angular, _*/
/*jshint laxcomma: true*/
angular.module('mpCarouselNavigator', []).directive('mpCarouselNavigator', ['$parse', '$timeout', 'Loader',
    function($parse, $timeout, Loader) {
        var loadPlugin = Loader.load;
        return {
            replace: true,
            templateUrl: 'gaiafrontend/html/carouselNavigator.html',
            link: function(scope, elem, attrs) {
                var items,
                    options,
                    jQitems,
                    jQinnerArrows,
                    jQoutterArrows,
                    itemsLength,
                    jQtoggleOpen,
                    isClosed = attrs.isClosed,
                    owl,
                    activeItemIndex = 0,
                    activeItemIndexSetter,
                    unWatchMpCarouselNavigatorActiveItemIndex,
                    unWatchMpCarouselNavigatorItems,
                    rendered = false,
                    unWatchMpCarouselNavigatorOptions;

                function onDestroy() {
                    // TODO: REVIEW! THESE OFF-EVENTs ARE NOT WORKING
                    jQtoggleOpen.off('click');
                    jQoutterArrows.next.off('click');
                    jQoutterArrows.prev.off('click');
                    jQinnerArrows.next.off('click');
                    jQinnerArrows.prev.off('click');
                    jQitems.off('changed.owl.carousel');
                    elem.off('click');
                    elem.off('changed.owl.carousel');
                    jQitems.off('initialized.owl.carousel');
                    jQitems.off('refreshed.owl.carousel');

                    unWatchMpCarouselNavigatorActiveItemIndex();
                    if (_.isFunction(unWatchMpCarouselNavigatorItems)) {
                        unWatchMpCarouselNavigatorItems();
                    }
                    if (_.isFunction(unWatchMpCarouselNavigatorOptions)) {
                        unWatchMpCarouselNavigatorOptions();
                    }
                    if (rendered) {
                        owl.trigger('destroy.owl.carousel');
                        rendered = false;
                    }
                }

                function itemOnClickFn(e) {
                    var activeItem = items[activeItemIndex];
                    if (activeItem && activeItem.afterClickFn && _.isFunction(activeItem.afterClickFn)) {
                        activeItem.afterClickFn.apply(this, arguments);
                    }
                    e.stopImmediatePropagation();
                }

                function getIndex(newActiveItem) {
                    var ix;
                    if (newActiveItem !== undefined) {
                        ix = Number(newActiveItem);
                        ix = (_.isNaN(newActiveItem) ? 0 : newActiveItem);
                    } else {
                        ix = activeItemIndex;
                    }
                    if (ix < 0) {
                        ix += itemsLength;
                    }
                    ix = ix % itemsLength;
                    return ix;
                }

                function updateActiveIndex() {
                    activeItemIndex = getIndex();
                    if (!scope.$$phase) {
                        scope.$apply(function() {
                            activeItemIndexSetter(scope, activeItemIndex);
                        });
                    }
                }

                function attachOnClickToItems(e) {
                    jQitems.find('[data-owlix]').on('click', function(event) {
                        var ix = angular.element(this).data('owlix');
                        activeItemIndex = ix;
                        updateActiveIndex();
                        event.stopImmediatePropagation();
                    });
                    e.stopImmediatePropagation();
                }

                function getOwlCarouselOptions() {
                    return {
                        items: options.visibleItems || 9,
                        loop: (typeof options.infiniteLoop === 'boolean' ? options.infiniteLoop : true),
                        center: true,
                        margin: 10,
                        //, callbacks     : true
                        responsive: options.responsive || {},
                        dots: false,
                        video: false,
                        mouseDrag: false,
                        touchDrag: false
                        //, onChanged     : onChangedFn
                        //, onInitialized : function() {
                        //attachOnClickToItems();
                        //}
                    };
                }

                function moveTo(ix, jump) {
                    var speed = (jump === undefined ? 300 : 0);
                    ix = (_.isNaN(ix) ? 0 : ix);
                    owl.trigger('to.owl.carousel', ix, speed);
                }

                function watchActiveItemIndex(newActiveItem) {
                    activeItemIndex = getIndex(newActiveItem);
                    moveTo(activeItemIndex);
                }

                function moveNext(event) {
                    activeItemIndex = getIndex(activeItemIndex + 1);
                    updateActiveIndex();
                    event.stopImmediatePropagation();
                }

                function movePrev(event) {
                    activeItemIndex = getIndex(activeItemIndex - 1);
                    updateActiveIndex();
                    event.stopImmediatePropagation();
                }

                function carouselVisibility(value) {
                    if (value) {
                        elem.removeClass('open');
                    } else {
                        elem.addClass('open');
                    }
                }

                function addExtraEvents() {
                    function onPrev(event) {
                        movePrev(event);
                    }
                    function onNext(event) {
                        moveNext(event);
                    }
                    function onOpen() {
                        isClosed = !isClosed;
                        carouselVisibility(isClosed);
                    }
                    if (!rendered) {
                        jQoutterArrows.prev.on('click', onPrev);
                        jQoutterArrows.next.on('click', onNext);
                        jQinnerArrows.prev.on('click', onPrev);
                        jQinnerArrows.next.on('click', onNext);
                        jQtoggleOpen.on('click', onOpen);
                        elem.on('changed.owl.carousel', itemOnClickFn);
                        jQitems.on('refreshed.owl.carousel', attachOnClickToItems);

                        unWatchMpCarouselNavigatorActiveItemIndex = scope.$watch(attrs.mpCarouselNavigatorActiveItemIndex, watchActiveItemIndex);
                    }
                }

                function initializePlugin() {
                    if (!rendered) {
                        // owl.carousel requires to attach initialized event before initializePlugin.
                        jQitems.on('initialized.owl.carousel', attachOnClickToItems);
                        owl = jQitems.owlCarousel(getOwlCarouselOptions());
                        activeItemIndex = activeItemIndex || 0;
                    }
                    moveTo(activeItemIndex, true);
                    // rendered = true;
                }

                function generateItemA(item) {
                    var imgEl, spanEl,
                        aEl = angular.element('<a></a>');

                    if (item.imgSrc) {
                        imgEl = angular.element('<img />');
                        imgEl.addClass('default');
                        imgEl.attr('src', item.imgSrc);
                        aEl.append(imgEl);
                    }
                    if (item.imgActive) {
                        imgEl = angular.element('<img />');
                        imgEl.addClass('big');
                        imgEl.attr('src', item.imgActive);
                        aEl.append(imgEl);
                    }
                    if (item.name) {
                        spanEl = angular.element('<span>');
                        spanEl.addClass('text');
                        spanEl.text(item.name);
                        aEl.append(spanEl);
                    }

                    return aEl;
                }

                function generateItem(item, ix) {
                    var el = angular.element('<div></div>');

                    el.attr('data-owlix', ix);
                    el.append(generateItemA(item, ix));
                    //generateItemAClick(el, item, ix);

                    return el;
                }

                function generateItems() {
                    angular.forEach(items, function(item, ix) {
                        jQitems.append(generateItem(item, ix));
                    });
                }

                function initializeElements() {
                    options = $parse(attrs.mpCarouselNavigatorOptions)(scope);
                    items = $parse(attrs.mpCarouselNavigatorItems)(scope);
                    itemsLength = (items ? (items.length || 0) : 0);
                    activeItemIndex = $parse(attrs.mpCarouselNavigatorActiveItemIndex)(scope);
                    activeItemIndexSetter = $parse(attrs.mpCarouselNavigatorActiveItemIndex).assign;
                    jQitems = elem.find('.mp-owl-carousel');
                    jQtoggleOpen = elem.find('.mp-toggle');
                    jQoutterArrows = {
                        prev: elem.find('.mp-arrows-outter').find('.prev'),
                        next: elem.find('.mp-arrows-outter').find('.next')
                    };
                    jQinnerArrows = {
                        prev: elem.find('a.inner.prev'),
                        next: elem.find('a.inner.next')
                    };
                }

                function hasItemsToRender() {
                    return (itemsLength > 0);
                }

                function paint() {
                    generateItems();
                    initializePlugin();
                    addExtraEvents();
                    rendered = true;
                    elem.on('$destroy', onDestroy);
                }

                function watchItemsAndOptions() {
                    unWatchMpCarouselNavigatorItems = scope.$watch(attrs.mpCarouselNavigatorItems, function() {
                        items = $parse(attrs.mpCarouselNavigatorItems)(scope);
                        itemsLength = (items ? (items.length || 0) : 0);
                        if (hasItemsToRender()) {
                            paint();
                        }
                    }, true);
                    unWatchMpCarouselNavigatorOptions = scope.$watch(attrs.mpCarouselNavigatorOptions, function() {
                        options = $parse(attrs.mpCarouselNavigatorOptions)(scope);
                        if (hasItemsToRender()) {
                            paint();
                        }
                    }, true);

                    isClosed = !!$parse(attrs.isClosed)(scope);
                    carouselVisibility(isClosed);
                }

                function main() {
                    initializeElements();
                    if (hasItemsToRender()) {
                        paint();
                    }
                    watchItemsAndOptions();
                }

                loadPlugin('owl.carousel.tweaked.js').then(main);
            }
        };
    }
    ]);

/*global angular, _*/
angular.module('mpCcc', [])
    /**
        * @doc-component directive
        * @name gaiafrontend.directive.mpCcc
        * @description
        * This component has been migrated to "GAIA Site"
        * There you will find its documentation and several examples.
        * "GAIA Site" is an application created by the Architecture Area to learn and play with GAIA. Is available in RAS. Direct links are available below in this page.
        * @example
        <doc:example>
             <doc:source>
             label GAIA site direct links are:
             a(href='https://wportalinterno.es.mapfre.net/com.ibm.ram.repository.web/faces/_rlvid.jsp?_rap=!assetDetails&_rvip=/home.jsp&guid=13A33828-B921-8DC5-DEDA-8B8D7C0EBC81') Intranet /
             a(href='https://wportalinterno.mapfre.com/com.ibm.ram.repository.web/faces/_rlvid.jsp?_rap=!assetDetails&_rvip=/home.jsp&guid=13A33828-B921-8DC5-DEDA-8B8D7C0EBC81') Internet
             </doc:source>
        </doc:example>
    */

    .factory('CCCSrv', function () {

        var pesos = [1, 2, 4, 8, 5, 10, 9, 7, 3, 6],
            DC_NO_INFORMADO = '**';

        function checkCCC(ccc, optionalDC) {
            function correctLengths(cc1, cc2, dc) {
                return (cc1.match(/^\d{8}$/) && cc2.match(/^\d{10}$/) && (dc.match(/^\d{2}$/) || dc.match(/^\*\*$/)));
            }

            function checkEmptyDC(dc) {
                return optionalDC && dc === DC_NO_INFORMADO;
            }

            function calculateDC(cc) {
                var i,
                    dc = 0,
                    lengthDif = pesos.length - cc.length;
                for (i = cc.length - 1; i >= 0; i -= 1) {
                    dc += pesos[i + lengthDif] * cc.charAt(i);
                }
                dc = 11 - (dc % 11);
                if (11 === dc) {
                    dc = 0;
                } else if (10 === dc) {
                    dc = 1;
                }
                return dc;
            }

            function checkDC(entidad, oficina, dc, numcuenta) {
                var cc1 = entidad + oficina,
                    cc2 = numcuenta,
                    dc1,
                    dc2;
                if (!correctLengths(cc1, cc2, dc)) {
                    return false;
                }
                if (checkEmptyDC(dc)) {
                    return true;
                }
                dc1 = calculateDC(cc1);
                dc2 = calculateDC(cc2);
                return ((10 * dc1 + dc2) === parseInt(dc, 10));
            }

            return checkDC(ccc.bankCode || '', ccc.branchCode || '', ccc.checkDigits || DC_NO_INFORMADO, ccc.accountNumber || '');
        }

        return {
            checkCCC: checkCCC
        };
    })
    .directive('mpCcc', ['CCCSrv',
        function (CCCSrv) {
            return {
                restrict: 'A',
                templateUrl: 'gaiafrontend/html/ccc.html',
                replace: true,
                scope: {
                    mpLabels: '@',
                    mpDcOptional: '@'
                },
                require: '?ngModel',
                link: function(scope, element, attrs, ngModelCtrl) {
                    var maxlength,
                        isRequired = attrs.required || false;

                    scope.singleField = attrs.mpSingleField ? true : false;

                    scope.model = {};


                    if (scope.singleField) {
                        scope.cccSingleField = attrs.mpCcc + 'CCC';
                    } else {
                        scope.bankCodeLabel = attrs.mpCcc + 'BankCode';
                        scope.branchCodeLabel = attrs.mpCcc + 'BranchCode';
                        scope.checkDigitsLabel = attrs.mpCcc + 'CheckDigits';
                        scope.accountNumberLabel = attrs.mpCcc + 'AccountNumber';
                    }

                    function isPristineObject(element) {
                        var isPristine = true;
                        isPristine = isPristine && element.hasClass('ng-pristine');
                        return isPristine;
                    }

                    function isEmptyObject(ccc) {
                        var empty = true;
                        angular.forEach(ccc, function(value) {
                            empty = empty && _.isEmpty(value);
                        });
                        return empty;
                    }

                    function joinModelStructure() {
                        var model = scope.model,
                            account = model.bankCode + model.branchCode + model.checkDigits + model.accountNumber;

                        return account;
                    }

                    function buildModelStructure() {
                        var cuenta = scope.model.cccSingleField === '' ? '' :  scope.model.cccSingleField || joinModelStructure();
                        scope.model = angular.extend(scope.model, {
                            bankCode: cuenta.substr(0, 4),
                            branchCode: cuenta.substr(4, 4),
                            checkDigits: cuenta.substr(8, 2),
                            accountNumber: cuenta.substr(10, 10)
                        });

                    }

                    function addFormatters() {
                        var toModel = function (modelValue) {
                            return modelValue;
                        };
                        var toView = function (viewValue) {
                            var model = _.pick(viewValue, ['bankCode', 'branchCode', 'checkDigits' , 'accountNumber']);
                            ngModelCtrl.$viewValue = viewValue;
                            ngModelCtrl.$render();
                            return model;
                        };

                        ngModelCtrl.$formatters.push(toModel);
                        ngModelCtrl.$parsers.push(toView);
                    }

                    scope.$watch('model', function(newValue) {
                        if (newValue) {
                            ngModelCtrl.$dirtify();
                        }

                        if (newValue && !isPristineObject(element)) {
                            ngModelCtrl.$setViewValue(newValue);
                            if (scope.singleField) {
                                buildModelStructure();
                            }

                            if (scope.mpDcOptional === 'true') {
                                ngModelCtrl.$setValidity('ccc', CCCSrv.checkCCC(scope.model, true));
                            } else {
                                ngModelCtrl.$setValidity('ccc', CCCSrv.checkCCC(scope.model));
                            }

                            if (isEmptyObject(newValue)) {
                                if (isRequired) {
                                    ngModelCtrl.$setValidity('required', false);
                                }
                                ngModelCtrl.$setValidity('ccc', true);
                            }
                        }
                    }, true);

                    if (ngModelCtrl) {
                        ngModelCtrl.$render = function() {
                            scope.model = ngModelCtrl.$viewValue || '';
                            if (scope.singleField && (scope.model.bankCode || scope.model.branchCode|| scope.model.accountNumber|| scope.model.checkDigits)) {
                                buildModelStructure();
                                angular.extend(scope.model, {cccSingleField: joinModelStructure()});
                            }
                        };
                    }

                    function interaction(element, attrs) {
                        var input = angular.element(element.find('input')),
                            isDcOptional = attrs.mpDcOptional;

                        if (isRequired) {
                            if (isDcOptional === 'true') {
                                angular.element(input[0]).attr('aria-required', true);
                                angular.element(input[1]).attr('aria-required', true);
                                angular.element(input[3]).attr('aria-required', true);
                                angular.element(input[0]).prop('required', true);
                                angular.element(input[1]).prop('required', true);
                                angular.element(input[3]).prop('required', true);
                            } else {
                                input.attr('aria-required', true);
                                input.prop('required', true);
                            }
                        }
                    }

                    interaction(element, attrs);

                    function keyUpHandler(e) {
                        var target = e.target || e.srcElement,
                            keyCode = e.which || e.keyCode;
                        maxlength = angular.element(target).attr('maxlength');
                        if (keyCode !== 9 && keyCode !== 16 && !e.shiftKey) {
                            if (angular.element(target).val().length === (parseInt(maxlength, 10))) {
                                angular.element(target).parent().next().find('input').focus();
                            }
                        }
                    }

                    element.find('input').on('keyup', keyUpHandler);

                    scope.$on('destroy', function () {
                        element.find('input').off('keyup', keyUpHandler);
                    });

                    addFormatters();

                }
            };
        }])

    .directive('numbersOnly',
        function() {
            return {
                require: 'ngModel',
                link: function (scope, element, attr, ngModelCtrl) {
                    function fromUser(text) {
                        var transformedInput = text.replace(/[^0-9]/g, '');
                        if (transformedInput !== text) {
                            ngModelCtrl.$setViewValue(transformedInput);
                            ngModelCtrl.$render();
                        }
                        return transformedInput;
                    }
                    ngModelCtrl.$parsers.push(fromUser);
                }
            };
        });

/*global angular */
angular.module('mpChange', [])
    /**
        * @doc-component directive
        * @name gaiafrontend.directive.mpChange
        * @description
        * This component has been migrated to "GAIA Site"
        * There you will find its documentation and several examples.
        * "GAIA Site" is an application created by the Architecture Area to learn and play with GAIA. Is available in RAS. Direct links are available below in this page.
        * @example
        <doc:example>
             <doc:source>
             label GAIA site direct links are:
             a(href='https://wportalinterno.es.mapfre.net/com.ibm.ram.repository.web/faces/_rlvid.jsp?_rap=!assetDetails&_rvip=/home.jsp&guid=13A33828-B921-8DC5-DEDA-8B8D7C0EBC81') Intranet /
             a(href='https://wportalinterno.mapfre.com/com.ibm.ram.repository.web/faces/_rlvid.jsp?_rap=!assetDetails&_rvip=/home.jsp&guid=13A33828-B921-8DC5-DEDA-8B8D7C0EBC81') Internet
             </doc:source>
        </doc:example>
    */
    .directive('mpChange', ['$parse', function($parse) {
        return {
            link: function(scope, element, attributes) {
                var onChangeFn = $parse(attributes.mpChange),
                    currentValue = element.val();

                function onFocusFn() {
                    currentValue = element.val();
                }

                // FIX. IE8 IS NOT TRIGGERING change EVENT
                function onBlurFn(event) {
                    scope.$apply(function() {
                        var newValue = element.val();
                        if (currentValue !== newValue) {
                            onChangeFn(scope, {
                                $event: event
                            });
                            currentValue = newValue;
                        }
                    });
                }

                element.on('focus', onFocusFn);
                element.on('blur', onBlurFn);
                element.on('$destroy', function() {
                    element.off('focus', onFocusFn);
                    element.off('blur', onBlurFn);
                });
            }
        };
    }]);

/*global angular, _ */
/**
    * @doc-component directive
    * @name gaiafrontend.directive.mpCharts
    * @description
    * This component has been migrated to "GAIA Site"
    * There you will find its documentation and several examples.
    * "GAIA Site" is an application created by the Architecture Area to learn and play with GAIA. Is available in RAS. Direct links are available below in this page.
    * @example
    <doc:example>
         <doc:source>
         label GAIA site direct links are:
         a(href='https://wportalinterno.es.mapfre.net/com.ibm.ram.repository.web/faces/_rlvid.jsp?_rap=!assetDetails&_rvip=/home.jsp&guid=13A33828-B921-8DC5-DEDA-8B8D7C0EBC81') Intranet /
         a(href='https://wportalinterno.mapfre.com/com.ibm.ram.repository.web/faces/_rlvid.jsp?_rap=!assetDetails&_rvip=/home.jsp&guid=13A33828-B921-8DC5-DEDA-8B8D7C0EBC81') Internet
         </doc:source>
    </doc:example>
*/
(function() {
    'use strict';
    function mpCharts(Loader, $parse, $q, $window, Utils) {
        return {
            scope: {
                mpChartsData: '=',
                mpChartsOptions: '='
            },
            link: function(scope, elem, attrs) {
                var plot,
                    opts = scope.mpChartsOptions,
                    loadPlugin = Loader.load('jquery.jqplot.min.js');

                /* -- Methods for chart resizing --*/
                angular.element($window).bind('resize', function() {
                    scope.width = $window.innerWidth;
                    opts.width = elem.parent().width() * 0.96;
                    scope.$digest();
                });

                if (Utils.platform.isTactile()) {
                    angular.element(window).on("orientationchange", function(event) {
                        resetLegend();
                        renderChart();
                        event.preventDefault();
                    });
                }

                function resetLegend() {
                    if (window.matchMedia('(max-width: 640px)').matches && !angular.isUndefined(opts.legend)) {
                        if (window.matchMedia("(orientation: portrait)").matches)
                            opts.legend.location = 's';
                            opts.legend.fontSize = '.4em';
                      /*  } else if (window.matchMedia("(orientation: landscape)").matches) {
                            opts.legend.location = 'e';
                            opts.legend.fontSize = '1em';
                        }*/
                    }
                }


                scope.$watch('width', function(newValue, oldValue) {
                    if (!angular.isUndefined(oldValue) && newValue !== oldValue && !angular.isUndefined(plot)) {
                        resetLegend();
                        plot.replot({
                            resetAxes: true,
                            rendererOptions: {
                                barPadding: 4,
                                barMargin: 5
                            }
                        });
                    }
                });
                /*--*/

                /*-- Render chart --*/
                function renderChart() {
                    var dataSerial = scope.mpChartsData;

                    if (angular.element.jqplot) {
                        elem.html('');

                        if (!angular.isArray(scope.mpChartsData)) {
                            throw 'No data to display';
                        }
                        if (!angular.isUndefined(scope.mpChartsOptions)) {

                            if (!angular.isUndefined(opts.seriesDefaults) && typeof opts.seriesDefaults.renderer === 'string')
                                opts.seriesDefaults.renderer = $parse(opts.seriesDefaults.renderer)(window.jQuery.jqplot);
                            if (!angular.isUndefined(opts.axes) && typeof opts.axes.xaxis.renderer === 'string')
                                opts.axes.xaxis.renderer = $parse(opts.axes.xaxis.renderer)(window.jQuery.jqplot);

                            if (!angular.isObject(opts)) {
                                throw 'Invalid mpCharts options attribute';
                            }
                            plot = angular.element.jqplot(attrs.id, [dataSerial], opts);

                        }
                    }
                }


                /*angular.element(elem).offsetParent()
                    .on("click", function(event) {
                        plot.destroy();
                        renderChart();
                        event.preventDefault();
                    })
                    .on('$destroy', function() {
                        angular.element(elem).offsetParent().off('click', renderChart);
                    });*/


                function setLibs(lib) {
                    return lib.substring(0, 1).toLowerCase() + lib.substring(1);
                }

                function getValues(obj, key) {
                    var objects = [],
                        libs = [];
                    for (var i in obj) {
                        if (!obj.hasOwnProperty(i)) continue;
                        if (typeof obj[i] === 'object') {
                            objects = objects.concat(getValues(obj[i], key));
                        } else if (i === key) {
                            objects.push(obj[i]);
                        }
                    }
                    return objects;
                }

                function getLibs() {
                    var promises = [],
                        promise;
                    _.forEach(getValues(scope.mpChartsOptions, 'renderer'), function(libs) {
                        promise = Loader.load('jqplot.' + setLibs(libs) + '.min.js');
                        promises.push(promise);
                    });
                    return $q.all(promises);
                }

                function loadCursor() {
                    return Loader.load('jqplot.cursor.min.js')
                }

                function loadHighlighter() {
                    return Loader.load('jqplot.highlighter.min.js')
                }

                loadPlugin
                    .then(loadCursor)
                    .then(loadHighlighter)
                    .then(getLibs)
                    .then(resetLegend)
                    .then(renderChart);
            }
        }
    }

    (angular.module('mpCharts', []))
    .directive('mpCharts', ['Loader', '$parse', '$q', '$window', 'Utils', mpCharts])
}());

/*global angular, _ */
/*jshint camelcase: false */
/*TODO: Refactor!! Clean code!! */
angular.module('mpContactNormalizer', [])
    .factory('contactNormalizerModalGrid', ['$filter',
        function($filter) {
            return {
                getOptions: function() {
                    var options = {
                        'datatype': 'local',
                        'multiselect': true,
                        'height': 'auto',
                        'colNames': [
                            $filter('translate')('mpContactNormalizer.property'),
                            $filter('translate')('mpContactNormalizer.field'),
                            $filter('translate')('mpContactNormalizer.initialValue'),
                            $filter('translate')('mpContactNormalizer.normalizedValue')
                        ],
                        'colModel': [{
                            'name': 'property',
                            'index': 'property',
                            'hidden': true
                        }, {
                            'name': 'field',
                            'index': 'field',
                            'align': 'left'
                        }, {
                            'name': 'initialValue',
                            'index': 'initialValue',
                            'align': 'left'
                        }, {
                            'name': 'normalizedValue',
                            'index': 'normalizedValue',
                            'align': 'left'
                        }],
                        'loadonce': true,
                        'mtype': 'GET',
                        'gridview': true,
                        'sortname': 'name',
                        'viewrecords': true,
                        'sortorder': 'asc',
                        'footerrow': false,
                        'autowidth': true,
                        'emptyrecords': $filter('translate')('mpContactNormalizer.no_records_found')
                    };
                    return options;
                }
            };
        }])
    .controller('ContactNormalizerModalCtrl', ['$scope', '$filter', '$modalInstance', 'contactNormalizerModalGrid', 'modelBeforeNormalization', 'modelAfterLastSuggestionsApplied', 'normalization',
        function($scope, $filter, $modalInstance, contactNormalizerModalGrid, modelBeforeNormalization, modelAfterLastSuggestionsApplied, normalization) {
            function createContactNormalizerModalGridData() {
                var gridData = [];

                if (normalization.nombre) {
                    gridData.push({
                        property: 'nombre',
                        field: (!modelBeforeNormalization.apellido1 && !modelBeforeNormalization.apellido2) ? $filter('translate')('mpContactNormalizer.razon_social') : $filter('translate')('mpContactNormalizer.nombre'),
                        initialValue: modelBeforeNormalization.nombre,
                        normalizedValue: normalization.nombre
                    });
                }

                if (normalization.apellido1) {
                    gridData.push({
                        property: 'apellido1',
                        field: $filter('translate')('mpContactNormalizer.apellido1'),
                        initialValue: modelBeforeNormalization.apellido1,
                        normalizedValue: normalization.apellido1
                    });
                }

                if (normalization.apellido2) {
                    gridData.push({
                        property: 'apellido2',
                        field: $filter('translate')('mpContactNormalizer.apellido2'),
                        initialValue: modelBeforeNormalization.apellido2,
                        normalizedValue: normalization.apellido2
                    });
                }

                if (normalization.sexo && modelBeforeNormalization.sexo && !angular.equals(normalization.sexo, modelBeforeNormalization.sexo)) {
                    gridData.push({
                        property: 'sexo',
                        field: $filter('translate')('mpContactNormalizer.sexo'),
                        initialValue: modelBeforeNormalization.sexo || '',
                        normalizedValue: normalization.sexo
                    });
                }

                return gridData;
            }

            $scope.grid = {
                data: createContactNormalizerModalGridData(),
                options: contactNormalizerModalGrid.getOptions(),
                model: []
            };

            $scope.$on('contactNormalizerGridSet', function() {
                $scope.grid.model = _.filter($scope.grid.data, function(item) {
                    return angular.equals(modelAfterLastSuggestionsApplied[item.property], item.normalizedValue);
                });
            });

            function getAcceptedSuggestionsModel() {
                var allSuggestions = _.pluck($scope.grid.data, 'property'),
                    acceptedSuggestions = _.pluck($scope.grid.model, 'property'),
                    rejectedSuggestions = _.difference(allSuggestions, acceptedSuggestions),
                    acceptedSuggestionsModel = {};

                angular.forEach(acceptedSuggestions, function(property) {
                    acceptedSuggestionsModel[property] = normalization[property];
                });

                angular.forEach(rejectedSuggestions, function(property) {
                    acceptedSuggestionsModel[property] = modelBeforeNormalization[property];
                });

                return acceptedSuggestionsModel;
            }
            $scope.accept = function() {
                $modalInstance.close(getAcceptedSuggestionsModel());
            };
        }])
    .factory('ContactNormalizerSrv', ['$q', 'HttpSrv',
        function($q, HttpSrv) {
            var contactUrl = 'api/normalize/contact';

            function normalize(stringToNormalize) {
                var deferred = $q.defer();

                HttpSrv.post(contactUrl, {
                    data: {
                        contact: stringToNormalize
                    }
                }).then(function(data) {
                    var obj = {};

                    angular.forEach(data, function(value, key) {
                        if (key === 'apelldio2') {
                            key = 'apellido2';
                        }
                        obj[key] = angular.isString(value) ? value.replace(/^\s+|\s+$/g, '') : value;
                    });

                    deferred.resolve(obj);
                }, deferred.reject);
                return deferred.promise;
            }
            return {
                normalize: normalize
            };
        }])
    /**
     * @doc-component directive
     * @name gaiafrontend.directive.mpContactNormalizer
     * @param {expression} mp-contact-normalizer The result of the expression must be an object. The object will map internal variables with model variables.
     * @param {expression=} mp-contact-normalizer-options The result of the expression must be an object. This object will configure the directive behaviour.
     * @description
     *
     * This directive allows you to normalize contact information. A contact might be a physical person or a corporation.
     *
     * The keys in the object map passed as mp-contact-normalizer will be the internal variable names and its values will be the model expression they will be bound to.
     * These are all the internal variables that can be mapped:
     *
     * - `nombre` - (REQUIRED) The name of the physical person/corporate name.
     * - `apellido1` - The first surname of the physical person.
     * - `apellido2` - The second surname of the physical person.
     * - `sexo` - The gender of the of the physical person.
     * - `tip_situ_val` - Current situation of the normalization. Its values are: null (not normalized), '1' (normalization accepted) and '2' (normalization rejected)
     * - `normalize` - Method to request normalization.
     * - `openModal` - Method to open a model with the normalization response.
     * - `applyNormalization` - Method to apply normalization to the model.
     *
     * If `apellido1` and `apellido2` are not mapped the directive will display only one input for corporate name.
     * If they both are mapped the directive will display several inputs for physical person.
     *
     * The `normalize` method will use `nombre` model (and `apellido1` model and `apellido2` model when physical person) to request normalization.
     * It will return a promise. This promise will be resolved with normalization model.
     *
     * The `openModal` method will use normalization model as argument and will apply the normalization itself.
     *
     * The `applyNormalization` method will use normalizations to apply model and the normalization response model as arguments.
     *
     * These are all the available options for directive configuration:
     *
     * - `hide` - If truthy the directive will not render any DOM element. Defaults to falsy.
     * - `sexo` - If truthy the directive will render the gender select element. Defaults to falsy.
     * - `warn` - If truthy the directive will render an information icon with the current situation of the normalization when normalized at least once. If normalizable it can be clicked to open a modal window to manage normalization.
     * - `onBlur` - AngularJS expression to evaluate (usually normalization method) when `blur` event is triggered by the las `input` element visible (`apellido2` when physical person and `nombre` when corporate name).
     * - `sizes` - Object to extend default input length to capture by the directive.
     *     - `nombre` defaults to 150 characters.
     *     - `apellido1` defaults to 30 characters.
     *     - `apellido2` defaults to 30 characters.
     *     - `sexo` defaults to 1 character.
     *
     * If we desire to normalize a corporate name when focusing out the input and then display suggestions in a modal after clicking the icon
     * this could be the mapping object...
     *
     *  ```js
     *  {
     *      "nombre": "contactModel.personaJuridica",
     *      "tip_situ_val": "contactModel.normalizationStatus",
     *      "normalize": "contactModel.requestContactNormalization"
     *  }
     *  ```
     *
     * ... and this could be the options object.
     *
     *  ```js
     *  {
     *      "warn": true,
     *      "onBlur": "contactModel.requestContactNormalization()"
     *  }
     *  ```
     * Given these objects, the directive invocation will result in something like this:
     *
     *  ```js
     *  div(mp-contact-normalizer="{'nombre': 'contactModel.personaJuridica', 'tip_situ_val': 'contactModel.normalizationStatus', 'normalize': 'contactModel.requestContactNormalization'}", mp-contact-normalizer-options="{'warn': true, 'onBlur': 'contactModel.requestContactNormalization()'}")
     *  ```
     *
     * The example is currently unavailable. If you want to try this component out, you can visit: [http://vles044273-008:8081/issuestracker/login.html#/](http://vles044273-008:8081/issuestracker/login.html#/) log in (user: UGAIA1 /password: UGAIA1) and navigate to Normalizations submenu.
     *
     * @example
       <doc:example module="mpContactNormalizer">
        <doc:source>
        label The example is currently unavailable. If you want to try this component out, you can visit:
        a(href='http://vles044273-008:8081/issuestracker/login.html#/') Issuestracker
        h2 Log in
        h4 User: UGAIA1
        h4 Password: UGAIA1
        h4 Navigate to Normalizations submenu.
        </doc:source>
       </doc:example>
     */
    .directive('mpContactNormalizer', ['$parse', '$q', '$filter', '$modal', 'Utils', 'ContactNormalizerSrv', 'Events',
        function($parse, $q, $filter, $modal, Utils, ContactNormalizerSrv, Events) {
            var defaultOptions = {
                    sizes: {
                        nombre: 150, // CDC
                        apellido1: 30, // CDC
                        apellido2: 30, // CDC
                        sexo: 1 // CDC
                    }
                },
                NO_NORMALIZADO = null,
                NORMALIZACION_RECHAZADA = '0',
                NORMALIZACION_ACEPTADA = '1';

            function isPersonaFisica(normalizationMap) {
                return normalizationMap.hasOwnProperty('nombre') && normalizationMap.hasOwnProperty('apellido1') && normalizationMap.hasOwnProperty('apellido2');
            }

            function isPersonaJuridica(normalizationMap) {
                return normalizationMap.hasOwnProperty('nombre') && !normalizationMap.hasOwnProperty('apellido1') && !normalizationMap.hasOwnProperty('apellido2');
            }

            function validate(normalizationMap) {
                if (!angular.isObject(normalizationMap)) {
                    throw new Error('[mp-contact-normalizer] must be an object');
                }

                if (!normalizationMap.nombre) {
                    throw new Error('[mp-contact-normalizer] object must own \'nombre\' property');
                }
            }
            return {
                require: '^form',
                compile: function(cElement, cAttributes) {
                    var normalizationMap = $parse(cAttributes.mpContactNormalizer)(),
                        options = angular.extend(angular.copy(defaultOptions), $parse(cAttributes.mpContactNormalizerOptions)());

                    function createContactNormalizerElement(colSize, labelText, ngModelExpression, maxlength, onBlurFn) {
                        var wrapper = angular.element('<div class="col-md-' + colSize + '"></div>'),
                            formGroup = angular.element('<div class="form-group"></div>'),
                            label = angular.element('<label class="col-sm-6 control-label" for="' + ngModelExpression + '">' + labelText + '</label>'),
                            inputWrapper = angular.element('<div class="validable col-sm-6"></div>'),
                            input = angular.element('<input type="text" id="' + ngModelExpression + '" name="' + ngModelExpression + '" maxlength="' + maxlength + '" class="form-control" mp-to-upper-case="" ng-model="' + ngModelExpression + '"' + (onBlurFn ? ' ng-blur="' + onBlurFn + '"' : '') + '></input>');

                        inputWrapper.append(input);
                        formGroup.append(label).append(inputWrapper);
                        wrapper.append(formGroup);

                        return wrapper;
                    }

                    function createContactNormalizerSexoElement(colSize, labelText, ngModelExpression) {
                        var wrapper = angular.element('<div class="col-md-' + colSize + '"></div>'),
                            formGroup = angular.element('<div class="form-group"></div>'),
                            label = angular.element('<label class="col-sm-6 control-label" for="' + ngModelExpression + '">' + labelText + '</label>'),
                            inputWrapper = angular.element('<div class="validable col-sm-6"></div>'),
                            input = angular.element('<select id="' + ngModelExpression + '" name="' + ngModelExpression + '" class="form-control" mp-to-upper-case="" ng-model="' + ngModelExpression + '" ng-options="sexo.code as sexo.description for sexo in [{code: \'V\', description: \'' + $filter('translate')('mpContactNormalizer.varon') + '\'}, {code: \'M\', description: \'' + $filter('translate')('mpContactNormalizer.mujer') + '\'}, {code: \'X\', description: \'' + $filter('translate')('mpContactNormalizer.indeterminado') + '\'}]"><option value="" selected="selected">' + $filter('translate')('select') + '</option></input>');

                        inputWrapper.append(input);
                        formGroup.append(label).append(inputWrapper);
                        wrapper.append(formGroup);

                        return wrapper;
                    }

                    function createContactNormalizerWarnElement(colOffset) {
                        var wrapper = angular.element('<div class="col-md-4 col-md-offset-' + colOffset + '"></div>'),
                            img = angular.element('<img class="contact-normalizer-warn-img" src="gaiafrontend/img/icon/icon-detail.png"></img>'),
                            anchor = angular.element('<a class="contact-normalizer-warn-anchor" style="vertical-align: bottom; margin-left: 10px;">' + $filter('translate')('mpContactNormalizer.results_suggested') + '</a>');

                        wrapper.append(img).append(anchor);

                        return wrapper;
                    }

                    function preparePersonaJuridicaDOM() {
                        var row = angular.element('<div class="row"></div>'),
                            razonSocialElement = createContactNormalizerElement(8, $filter('translate')('mpContactNormalizer.razon_social'), normalizationMap.nombre, options.sizes.nombre || defaultOptions.sizes.nombre, options.onBlur),
                            warnRow,
                            warnElement;

                        row.append(razonSocialElement);
                        cElement.append(row);

                        if (options.warn) {
                            warnRow = angular.element('<div class="row" style="display: none;"></div>');
                            warnElement = createContactNormalizerWarnElement(4);
                            warnRow.append(warnElement);
                            cElement.append(warnRow);
                        }
                    }

                    function preparePersonaFisicaDOM() {
                        var row = angular.element('<div class="row"></div>'),
                            nombreElement = createContactNormalizerElement(4, $filter('translate')('mpContactNormalizer.nombre'), normalizationMap.nombre, options.sizes.nombre || defaultOptions.sizes.nombre, options.onBlur),
                            apellido1Element = createContactNormalizerElement(4, $filter('translate')('mpContactNormalizer.apellido1'), normalizationMap.apellido1, options.sizes.apellido1 || defaultOptions.sizes.apellido1, options.onBlur),
                            apellido2Element = createContactNormalizerElement(4, $filter('translate')('mpContactNormalizer.apellido2'), normalizationMap.apellido2, options.sizes.apellido2 || defaultOptions.sizes.apellido2, options.onBlur),
                            sexoElement = createContactNormalizerSexoElement(4, $filter('translate')('mpContactNormalizer.sexo'), normalizationMap.sexo),
                            warnRow,
                            warnElement;

                        row.append(nombreElement).append(apellido1Element).append(apellido2Element);

                        if (options.sexo) {
                            row.append(sexoElement);
                        }

                        cElement.append(row);

                        if (options.warn) {
                            warnRow = angular.element('<div class="row" style="display: none;"></div>');
                            warnElement = createContactNormalizerWarnElement(2);
                            warnRow.append(warnElement);
                            cElement.append(warnRow);
                        }
                    }
                    if (!options.hide && !cElement.contents().length) {
                        if (isPersonaFisica(normalizationMap)) {
                            preparePersonaFisicaDOM();
                        } else if (isPersonaJuridica(normalizationMap)) {
                            preparePersonaJuridicaDOM();
                        }
                    }
                    return function(scope, element, attributes, formCtrl) {
                        var normalizationMap = $parse(attributes.mpContactNormalizer)(),
                            options = angular.extend(angular.copy(defaultOptions), $parse(attributes.mpContactNormalizerOptions)()),
                            normalizing,
                            normalizationStatus,
                            lastNormalization,
                            modelBeforeNormalization = {},
                            modelAfterLastSuggestionsApplied = {},
                            nombreFormControl,
                            apellido1FormControl,
                            apellido2FormControl,
                            sexoFormControl,
                            deregisterLastNormalizationWatcher,
                            deregisterWarnElementOnClickListener,
                            deregisterControlChangesWatcher;

                        function saveNormalizationStatus(status) {
                            normalizationStatus = status; // NO_NORMALIZADO | NORMALIZACION_RECHAZADA | NORMALIZACION_ACEPTADA
                            if (normalizationMap.tip_situ_val) {
                                $parse(normalizationMap.tip_situ_val).assign(scope, status);
                            }
                        }

                        function createContactNormalizerInputString() {
                            var contactNormalizerInputString = '';

                            contactNormalizerInputString += ($parse(normalizationMap.nombre)(scope) || '').substr(0, options.sizes.nombre);

                            if (normalizationMap.apellido1) {
                                contactNormalizerInputString += ' ' + ($parse(normalizationMap.apellido1)(scope) || '').substr(0, options.sizes.apellido1);
                            }

                            if (normalizationMap.apellido2) {
                                contactNormalizerInputString += ' ' + ($parse(normalizationMap.apellido2)(scope) || '').substr(0, options.sizes.apellido2);
                            }

                            return Utils.string.trim(Utils.string.replaceDiacritics(contactNormalizerInputString));
                        }

                        function setFormControlsDisablePropTo(value) {
                            nombreFormControl.prop('disabled', value);
                            apellido1FormControl.prop('disabled', value);
                            apellido2FormControl.prop('disabled', value);
                            sexoFormControl.prop('disabled', value);
                        }

                        function disableNormalization() {
                            setFormControlsDisablePropTo(true);
                            normalizing = true;
                        }

                        function enableNormalization() {
                            setFormControlsDisablePropTo(false);
                            normalizing = false;
                        }

                        function saveModelAfterLastSuggestionsApplied() {
                            angular.forEach(normalizationMap, function(normalizationExpression, normalizationPropertyName) {
                                modelAfterLastSuggestionsApplied[normalizationPropertyName] = $parse(normalizationExpression)(scope);
                            });
                        }

                        function saveModelBeforeNormalization() {
                            angular.forEach(normalizationMap, function(normalizationExpression, normalizationPropertyName) {
                                modelBeforeNormalization[normalizationPropertyName] = $parse(normalizationExpression)(scope);
                            });
                        }

                        function applySuggestion(value, property) {
                            value = value || '';

                            if (normalizationMap[property] && value.length <= (options.sizes[property] || defaultOptions.sizes[property])) {
                                $parse(normalizationMap[property]).assign(scope, value);
                            }
                        }

                        function applySuggestions(normalizationsToApply) {
                            angular.forEach(normalizationsToApply, applySuggestion);
                            saveModelAfterLastSuggestionsApplied();
                        }

                        function applyNormalization(normalizationsToApply) {
                            saveModelBeforeNormalization();
                            applySuggestions(normalizationsToApply);
                        }
                        if (normalizationMap.applyNormalization) {
                            $parse(normalizationMap.applyNormalization).assign(scope, applyNormalization);
                        }

                        function openContactNormalizationModal(normalization) {
                            var modalOptions = {
                                size: 'lg',
                                backdrop: 'static',
                                keyboard: false,
                                scope: scope,
                                templateUrl: 'gaiafrontend/html/mpContactNormalizerModal.html',
                                controller: 'ContactNormalizerModalCtrl',
                                resolve: {
                                    modelBeforeNormalization: function() {
                                        return modelBeforeNormalization;
                                    },
                                    modelAfterLastSuggestionsApplied: function() {
                                        return modelAfterLastSuggestionsApplied;
                                    },
                                    normalization: function() {
                                        return normalization;
                                    }
                                }
                            };

                            function areThereRejections(changesToRevert) {
                                var thereAreRejections = false;

                                angular.forEach(changesToRevert, function(value, property) {
                                    if (!angular.equals(lastNormalization[property], value)) {
                                        thereAreRejections = true;
                                    }
                                });

                                return thereAreRejections;
                            }

                            return $modal.open(modalOptions).result.then(function(changesToRevert) {
                                applySuggestions(changesToRevert);

                                if (areThereRejections(changesToRevert)) {
                                    saveNormalizationStatus(NORMALIZACION_RECHAZADA);
                                } else {
                                    saveNormalizationStatus(NORMALIZACION_ACEPTADA);
                                }
                            });
                        }
                        if (normalizationMap.openModal) {
                            $parse(normalizationMap.openModal).assign(scope, openContactNormalizationModal);
                        }

                        function getMainControlsObject() {
                            var mainControlsObject = {};

                            angular.forEach(_.keys(normalizationMap), function(property) {
                                if ((property === 'nombre' || property === 'apellido1' || property === 'apellido2')) {
                                    mainControlsObject[property] = formCtrl[normalizationMap[property]];
                                }
                            });

                            return mainControlsObject;
                        }

                        function checkIfAnyControlIsInvalid(mainControlsObject) {
                            var isAnyControlInvalid = false;

                            angular.forEach(mainControlsObject, function(ngModelCtrl) {
                                if (!ngModelCtrl.$modelValue) {
                                    isAnyControlInvalid = true;
                                }
                            });

                            return isAnyControlInvalid;
                        }

                        function checkIfEveryControlIsDirty(mainControlsObject) {
                            var isEveryControlDirty = true;

                            angular.forEach(mainControlsObject, function(ngModelCtrl) {
                                if (!ngModelCtrl.$dirty) {
                                    isEveryControlDirty = false;
                                }
                            });

                            return isEveryControlDirty;
                        }

                        // TODO: Improve performance. Too many loops!
                        function validateControls() {
                            var mainControlsObject = getMainControlsObject(),
                                areControlsInvalid = checkIfAnyControlIsInvalid(mainControlsObject),
                                isEveryMainControlDirty = checkIfEveryControlIsDirty(mainControlsObject);

                            if (areControlsInvalid && isEveryMainControlDirty) {
                                angular.forEach(mainControlsObject, function(ngModelCtrl) {
                                    if (!ngModelCtrl.$modelValue) {
                                        scope.$broadcast(Events.$formControlError(formCtrl.$name + ngModelCtrl.$name), {
                                            normalization: 'Required for normalization.'
                                        });
                                    }
                                });
                            }

                            return !areControlsInvalid;
                        }

                        function hasModelChangedSinceLastNormalizationWasApplied() {
                            var modelValueHasChanged = false;

                            if (!_.isEmpty(modelAfterLastSuggestionsApplied)) {
                                angular.forEach(normalizationMap, function(normalizationExpression, normalizationPropertyName) {
                                    if ((normalizationPropertyName === 'nombre' || normalizationPropertyName === 'apellido1' || normalizationPropertyName === 'apellido2') && $parse(normalizationExpression)(scope) !== modelAfterLastSuggestionsApplied[normalizationPropertyName]) {
                                        modelValueHasChanged = true;
                                    }
                                });
                            }
                            return modelValueHasChanged;
                        }

                        function isNormalizable() {
                            return (normalizationStatus === NO_NORMALIZADO) || hasModelChangedSinceLastNormalizationWasApplied();
                        }

                        function parseNormalization(normalization) {
                            var normalizationsToApply = {},
                                parsedModel = {
                                    nombre: Utils.string.trim(Utils.string.replaceDiacritics($parse(normalizationMap.nombre)(scope) || '')),
                                    apellido1: Utils.string.trim(Utils.string.replaceDiacritics($parse(normalizationMap.apellido1)(scope) || '')),
                                    apellido2: Utils.string.trim(Utils.string.replaceDiacritics($parse(normalizationMap.apellido2)(scope) || '')),
                                    sexo: Utils.string.trim(Utils.string.replaceDiacritics($parse(normalizationMap.sexo)(scope) || ''))
                                },
                                parsedNormalization = {
                                    nombre: Utils.string.trim(normalization.nombre),
                                    apellido1: Utils.string.trim(normalization.nexosApellido1 + ' ' + normalization.apellido1),
                                    apellido2: Utils.string.trim(normalization.nexosApellido2 + ' ' + normalization.apellido2),
                                    sexo: Utils.string.trim(normalization.sexo)
                                };

                            function validateGenre() {
                                var isValidGenre = true;

                                if (isPersonaFisica(normalizationMap) && parsedNormalization.sexo === 'E') {
                                    isValidGenre = false;
                                } else if (isPersonaJuridica(normalizationMap)) {
                                    if (parsedNormalization.sexo === 'V' || parsedNormalization.sexo === 'M') {
                                        isValidGenre = false;
                                    }
                                }

                                return isValidGenre;
                            }

                            if (parsedModel.nombre && parsedNormalization.nombre && !angular.equals(parsedModel.nombre, parsedNormalization.nombre)) {
                                normalizationsToApply.nombre = parsedNormalization.nombre;
                            }

                            if (parsedModel.apellido1 && parsedNormalization.apellido1 && !angular.equals(parsedModel.apellido1, parsedNormalization.apellido1)) {
                                normalizationsToApply.apellido1 = parsedNormalization.apellido1;
                            }

                            if (parsedModel.apellido2 && parsedNormalization.apellido2 && !angular.equals(parsedModel.apellido2, parsedNormalization.apellido2)) {
                                normalizationsToApply.apellido2 = parsedNormalization.apellido2;
                            }

                            if (parsedNormalization.sexo && !angular.equals(parsedModel.sexo, parsedNormalization.sexo)) {
                                if (validateGenre()) {
                                    normalizationsToApply.sexo = parsedNormalization.sexo;
                                } else {
                                    normalizationsToApply.sexo = parsedModel.sexo;
                                }
                            }

                            return normalizationsToApply;
                        }

                        function setMainControlsPristine() {
                            var mainControlsObject = getMainControlsObject();

                            angular.forEach(mainControlsObject, function(ngModelCtrl) {
                                ngModelCtrl.$setPristine();
                            });
                        }

                        function normalize() {
                            var deferred = $q.defer();

                            if (normalizing) {
                                deferred.reject();
                                return deferred.promise;
                            }

                            if (!validateControls()) {
                                deferred.reject();
                                return deferred.promise;
                            }

                            if (!isNormalizable()) {
                                deferred.reject();
                                return deferred.promise;
                            }

                            disableNormalization();

                            ContactNormalizerSrv.normalize(createContactNormalizerInputString()).then(function(normalization) {
                                var normalizationsToApply = parseNormalization(normalization);
                                setMainControlsPristine();
                                applyNormalization(normalizationsToApply);
                                lastNormalization = normalizationsToApply;
                                saveNormalizationStatus(NORMALIZACION_ACEPTADA);
                                deferred.resolve(normalizationsToApply);
                            }, deferred.reject)['finally'](enableNormalization);
                            return deferred.promise;
                        }

                        if (normalizationMap.normalize) {
                            $parse(normalizationMap.normalize).assign(scope, normalize);
                        }

                        function listenWarnElementOnClick() {
                            var warnElements = element.find('a.contact-normalizer-warn-anchor,img.contact-normalizer-warn-img');

                            warnElements.off('click');
                            warnElements.on('click', function(event) {
                                openContactNormalizationModal(lastNormalization);
                                event.preventDefault();
                            });

                            return function() {
                                warnElements.off('click');
                                warnElements.on('click', function(event) {
                                    event.preventDefault();
                                });
                            };
                        }

                        function updateIncam() {
                            var mainControlsObject = getMainControlsObject(),
                                incam = {};

                            if (normalizationMap.incam) {
                                angular.forEach(mainControlsObject, function(ngModelCtrl, property) {
                                    if (lastNormalization) {
                                        incam[property] = angular.equals(ngModelCtrl.$modelValue, lastNormalization[property]);
                                    } else {
                                        incam[property] = false;
                                    }
                                });

                                $parse(normalizationMap.incam).assign(scope, incam);
                            }
                        }

                        function manageWarnRowVisibility() {
                            var warnRow = element.find('a.contact-normalizer-warn-anchor').closest('.row');

                            if (lastNormalization && !_.isEmpty(lastNormalization)) {
                                // If only gender is normalized and no gender were selected we will not show the pop-up link
                                if (_.keys(lastNormalization).length === 1 && lastNormalization.sexo && !modelBeforeNormalization.sexo && !angular.equals(modelBeforeNormalization.sexo, lastNormalization.sexo)) {
                                    warnRow.hide();
                                } else {
                                    warnRow.show();
                                }
                            } else {
                                warnRow.hide();
                            }
                        }

                        function watchLastNormalization() {
                            return scope.$watch(function() {
                                return lastNormalization;
                            }, function() {
                                updateIncam();
                                manageWarnRowVisibility();
                            });
                        }

                        function watchControlChanges() {
                            return scope.$watch(function() {
                                return hasModelChangedSinceLastNormalizationWasApplied();
                            }, function(hasModelChangedSinceLastNormalizationWasApplied) {

                                updateIncam();

                                if (hasModelChangedSinceLastNormalizationWasApplied && normalizationStatus !== NORMALIZACION_RECHAZADA) {
                                    var warnRow = element.find('a.contact-normalizer-warn-anchor').closest('.row');
                                    saveNormalizationStatus(NORMALIZACION_RECHAZADA);
                                    warnRow.hide();
                                } else if (!hasModelChangedSinceLastNormalizationWasApplied && normalizationStatus === NORMALIZACION_RECHAZADA) {
                                    saveNormalizationStatus(NORMALIZACION_ACEPTADA);
                                }
                            });
                        }

                        function deregisterWatchersAndEventListeners() {
                            deregisterLastNormalizationWatcher();
                            deregisterWarnElementOnClickListener();
                            deregisterControlChangesWatcher();
                        }

                        function watchChangesAndListenEvents() {
                            deregisterLastNormalizationWatcher = watchLastNormalization();
                            deregisterWarnElementOnClickListener = listenWarnElementOnClick();
                            deregisterControlChangesWatcher = watchControlChanges();
                            element.on('$destroy', deregisterWatchersAndEventListeners);
                        }

                        validate(normalizationMap);

                        saveNormalizationStatus(NO_NORMALIZADO);

                        if (isPersonaJuridica(normalizationMap)) {
                            $parse(normalizationMap.sexo).assign(scope, 'E');
                        }

                        nombreFormControl = element.find('[ng-model="' + normalizationMap.nombre + '"]');
                        apellido1FormControl = element.find('[ng-model="' + normalizationMap.apellido1 + '"]');
                        apellido2FormControl = element.find('[ng-model="' + normalizationMap.apellido2 + '"]');
                        sexoFormControl = element.find('[ng-model="' + normalizationMap.sexo + '"]');

                        if (options.warn) {
                            watchChangesAndListenEvents();
                        } else {
                            deregisterControlChangesWatcher = watchControlChanges();
                            element.on('$destroy', function() {
                                deregisterControlChangesWatcher();
                            });
                        }
                    };
                }
            };
        }]);

/* global angular */
/*DEPRECATED*/
angular.module('mpDefaultValueList', [])
   /**
     * @doc-component directive
     * @name gaiafrontend.directive.mpDefaultValueList
     * @description
     * DEPRECATED
     * Use mpValuesList instead
     */
    .directive('mpDefaultValueList', ['Utils', '$filter', function (Utils, $filter) {
        return {
            templateUrl: 'gaiafrontend/html/mpDefaultValueList.html',
            require: '^form',
            scope: {
                mpDefaultValueListModel: '=',
                mpDefaultValueListConfig: '=',
                mpDefaultValueListCodeName: '@',
                mpDefaultValueListCodeModel: '=',
                mpDefaultValueListDescName: '@',
                mpDefaultValueListDescModel: '=',
                mpDefaultValueListData: '='
            },
            link: function(scope, element, attrs, formCtrl) {
                // Returns the last sequence of the Nam or Val string
                var getCodeAndName = function(attribute) {
                    return $filter('limitTo')(attribute, attribute.length, (attribute.lastIndexOf('.') + 1));
                }

                // Needed to apply validations properly (to display the tooltip)
                scope[formCtrl.$name] = formCtrl;

                scope.onClick = function () {
                    scope.$parent.$eval(attrs.mpDefaultValueListClick);
                }

                scope.$watch('mpDefaultValueListCodeModel', function (mpDefaultValueListCodeModel) {
                    if (mpDefaultValueListCodeModel && mpDefaultValueListCodeModel.cnf && mpDefaultValueListCodeModel.cnf.fldT && mpDefaultValueListCodeModel.cnf.fldT[getCodeAndName(attrs.mpDefaultValueListCodeModel)]) {
                        scope.mpDefaultValueListCodeRqr = mpDefaultValueListCodeModel.cnf.fldT[getCodeAndName(attrs.mpDefaultValueListCodeModel)].rqr;
                        scope.mpDefaultValueListCodeDis = mpDefaultValueListCodeModel.cnf.fldT[getCodeAndName(attrs.mpDefaultValueListCodeModel)].mdf;
                    }
                }, true);

                scope.$watch('mpDefaultValueListDescModel', function (mpDefaultValueListDescModel) {
                    if (mpDefaultValueListDescModel && mpDefaultValueListDescModel.cnf && mpDefaultValueListDescModel.cnf.fldT && mpDefaultValueListDescModel.cnf.fldT[getCodeAndName(attrs.mpDefaultValueListDescModel)]) {
                        scope.mpDefaultValueListDescRqr = mpDefaultValueListDescModel.cnf.fldT[getCodeAndName(attrs.mpDefaultValueListDescModel)].rqr;
                        scope.mpDefaultValueListDescDis = mpDefaultValueListDescModel.cnf.fldT[getCodeAndName(attrs.mpDefaultValueListDescModel)].mdf;
                    }
                }, true);
            }
        };
    }]);

/* global angular */
angular.module('mpDefaultValuesList', [])
    .directive('mpDefaultValuesList', ['$parse', '$compile', 'Utils', function ($parse, $compile, Utils) {
        return {
            template: function (element, attrs) {
                function createCodeElement() {
                    var codeElement = angular.element('<input class="form-control"></input>'),
                        codeAttributes = $parse(attrs.mpDefaultValuesListCodeAttributes)(element.scope());

                    angular.forEach(codeAttributes, function (value, attr) {
                        codeElement.attr(Utils.string.toHyphens(attr), value);
                    });

                    return codeElement;
                }

                function createCodeWrapperElement() {
                    var codeWrapperElement = angular.element('<div></div>'),
                        codeAttributes = $parse(attrs.mpDefaultValuesListCodeAttributes)(element.scope());

                    if (codeAttributes && codeAttributes.type === 'hidden') codeWrapperElement.addClass('ng-hidden');
                    else codeWrapperElement.addClass('col-sm-2');

                    return codeWrapperElement;
                }

                function createDescElement() {
                    var descElement = angular.element('<input class="form-control"></input>'),
                        descAttributes = $parse(attrs.mpDefaultValuesListDescAttributes)(element.scope());

                    angular.forEach(descAttributes, function (value, attr) {
                        descElement.attr(Utils.string.toHyphens(attr), value);
                    });

                    return descElement;
                }

                function createValuesListWrapperElement() {
                    return angular.element('<span class="input-group-btn"></span>');
                }

                function createDescWrapperElement() {
                    var descWrapperElement = angular.element('<div class="validable input-group"></div>'),
                        codeAttributes = $parse(attrs.mpDefaultValuesListCodeAttributes)(element.scope());

                    if (codeAttributes && codeAttributes.type === 'hidden') descWrapperElement.addClass('col-sm-12');
                    else descWrapperElement.addClass('col-sm-10');

                    return descWrapperElement;
                }

                return angular.element('<div></div>')
                        .append(
                            createCodeWrapperElement().append(createCodeElement())
                        ).append(
                            createDescWrapperElement().append(createDescElement()).append(createValuesListWrapperElement())
                        ).html();
            },
            link: function (scope, element, attrs) {
                var valuesListAttributes = scope.$eval(attrs.mpDefaultValuesListButtonAttributes),
                    map = $parse(attrs.mpDefaultValuesListMap)(),
                    childScope = scope.$new();

                function createValuesList() {
                    var valuesListElement = angular.element('<button></button>');

                    angular.forEach(valuesListAttributes, function (value, attr) {
                        valuesListElement.attr(Utils.string.toHyphens(attr), value)
                    });

                    valuesListElement.attr('mp-values-list', attrs.mpDefaultValuesList);
                    valuesListElement.attr('mp-values-list-model', 'model');
                    valuesListElement.attr('mp-values-list-config', 'config');
                    valuesListElement.attr('mp-values-list-filter', 'filter($scope)');

                    return valuesListElement;
                }

                childScope.$watch('model', function (valuesListModel) {
                    if (!_.isEmpty(valuesListModel)) {
                        angular.forEach(map, function (valueExpression, keyExpression) {
                            var configValueExpression = $parse(valueExpression)(childScope.config);
                            $parse(keyExpression).assign(scope, $parse(configValueExpression || valueExpression)(childScope.model));
                        });
                    }
                });

                element.find('.input-group > span.input-group-btn').append($compile(createValuesList())(childScope));

                childScope.filter = function (valuesListScope) {
                    valuesListScope.model = {};

                    angular.forEach(map, function (valueExpression, keyExpression) {
                        var configValueExpression = $parse(valueExpression)(valuesListScope.config);
                        $parse(configValueExpression || valueExpression).assign(valuesListScope.model, $parse(keyExpression)(scope));
                    });
                };
            }
        };
    }]);

/**
 * @doc-component directive
 * @name gaiafrontend.directive.mpDocumentValidator
 * @restrict C
 * @param {string} mpDocumentValidator receives a string with the type of validation.
 * @description
 * Directive at level of input that implements the DocumentValidator service.
 * @example
   <doc:example module="mpDocumentValidator">
    <doc:source>
    input.form-control(type="text", name="dni", mp-document-validator="'nif'", placeholder="00000000X", ng-model="documentValidator.dni", required)
    </doc:source>
   </doc:example>
 */
/*global angular*/
angular.module('mpDocumentValidator', [])

    .directive('mpDocumentValidator', ['DocumentValidator', function (DocumentValidator) {
            return {
                scope: {
                    typeDocument: '=mpDocumentValidator'
                },
                require: 'ngModel',
                link: function (scope, element, attrs, ngModelCtrl) {

                    function validateDocument(value) {
                        return DocumentValidator[scope.typeDocument](value);
                    }
                    scope.$watch(function () {
                        return ngModelCtrl.$modelValue;
                    }, function (newValue) {
                        if (!angular.isUndefined(newValue)) {
                            ngModelCtrl.$setValidity('document', validateDocument(newValue));
                        }
                    });
                }
            };
        }]);

/*global angular, _ */
/*DEPRECATED*/
angular.module('mpFancytree', ['utils'])
    /**
     * @doc-component directive
     * @name gaiafrontend.directive.mpFancytree
     * @description
     * DEPRECATED
     * If you need this component ask for it through the UX department
     */
    .directive('mpFancytree', ['Loader',
        function(Loader) {
            var loadPlugin = Loader.load;

            function writeJsonList(currentElement, listElements, text) {
                var i = 0;
                for (i = 0; i < listElements.length; i = i + 1) {
                    if (listElements[i].li.ul) {
                        currentElement.append('<li><a href="">' + listElements[i].li.ul[0].li + '</a><ul></ul></li>');
                        writeJsonList(currentElement.find('li ul'), listElements[i].li.ul, listElements[i].li.ul[0].li);
                    } else {
                        if (listElements[i].li !== text) {
                            text = '';
                            if (listElements[i]['class'] && listElements[i].href) {
                                currentElement.append('<li class=' + listElements[i]['class'] + '><a href=' + listElements[i].href + '>' + listElements[i].li + '</a> </li>');
                            } else if (listElements[i]['class']) {
                                currentElement.append('<li class=' + listElements[i]['class'] + '><a href="">' + listElements[i].li + '</a> </li>');
                            } else if (listElements[i].href) {
                                currentElement.append('<li><a href=' + listElements[i].href + '>' + listElements[i].li + '</a> </li>');
                            } else {
                                currentElement.append('<li><a href="">' + listElements[i].li + '</a> </li>');
                            }
                        }
                    }
                }
            }

            function readJsonListElements(currentElement, argument) {
                _.each(argument, function(datos) {
                    writeJsonList(currentElement, datos);
                });
            }

            return {
                templateUrl: 'gaiafrontend/html/fancyTree.html',
                link: function(scope, elm, attrs) {
                    var treeElements = attrs.mpFancytree;

                    elm.find('.treextra').append('<ul></ul>');
                    angular.forEach(angular.fromJson(treeElements), function(datos) {
                        readJsonListElements(elm.find('.treextra ul'), datos);
                    });

                    function drawTree() {
                        elm.find('.treextra').fancytree({
                            checkbox: false,
                            activate: function(e, data) {
                                elm.find('div#statusLine').text('Active node: ' + data.node);
                            }
                        });
                    }

                    loadPlugin('jquery.fancytree.js').then(drawTree);
                }
            };
        }]);

/*global angular */
/*DEPRECATED*/
angular.module('mpGenie', [])
    /**
     * @doc-component directive
     * @name gaiafrontend.directive.mpGenie
     * @description
     * DEPRECATED
     * If you need this component ask for it through UX department
    */
    .directive('mpGenie', ['Loader',
        function(Loader) {
            var loadPlugin = Loader.load,
                genie = 'genie.js',
                html2Canvas = 'html2canvas.js',
                jQueryGenie = 'jquery.genie.js';
            return {
                link: function(scope, element) {
                    function initGenie() {
                        element.on('click', function() {
                            angular.element('body').htmlGenieCollapse(element, ['bottom']);
                        });

                        element.on('$destroy', function() {
                            element.off('click');
                        });
                    }

                    loadPlugin(html2Canvas).then(function() {
                        loadPlugin(genie).then(function() {
                            loadPlugin(jQueryGenie).then(initGenie);
                        });
                    });
                }
            };
        }]);

/*TODO: REVIEW*/
/**
 * @doc-component directive
 * @name gaiafrontend.directive.mpGraph
 * @param {string} mpGraph receive a JSON containing an array with the data in the graph. Each subrray defines the X and Y coordinates of a point.
 * @description
 * This component draws a basic graph.
 * This component is DEPRECATED. Please use mpCharts instead.
 */
/*global angular */
angular.module('mpGraph', ['utils'])
    .directive('mpGraph', ['Loader',
        function(Loader) {
            var loadPlugin = Loader.load;

            return {
                replace: true,
                link: function(scope, elm, attrs) {
                    var dataGraph = angular.fromJson(attrs.mpGraph);

                    function drawGraph() {
                        angular.element.plot(elm, [{
                            data: dataGraph.data,
                            lines: {
                                show: true,
                                fill: true
                            }
                        }]);
                    }

                    loadPlugin('jquery.flot.js').then(drawGraph);
                }
            };
        }]);

/*TODO: REVIEW*/
/**
 * @doc-component directive
 * @name gaiafrontend.directive.mpGraphBar
 * @param {string} mpGraphBar receive a JSON containing an array with the data in the graph. Each subrray defines the X and Y coordinates of a point.
 * @description
 * This component draws a bar graph.
 * This component is DEPRECATED. Please use mpCharts instead.
 */
/*global angular */
angular.module('mpGraphBar', ['utils'])
    .directive('mpGraphBar', ['Loader',
        function(Loader) {
            var loadPlugin = Loader.load;

            return {
                replace: true,
                link: function(scope, elm, attrs) {
                    var dataGraph = angular.fromJson(attrs.mpGraphBar);

                    function drawGraph() {
                        angular.element.plot(elm, [{
                            data: dataGraph.data,
                            bars: {
                                show: true
                            }
                        }]);
                    }

                    loadPlugin('jquery.flot.js').then(drawGraph);
                }
            };
        }]);

/*TODO: REVIEW*/
/**
 * @doc-component directive
 * @name gaiafrontend.directive.mpGraphPie
 * @param {string} mpGraphPie receive a JSON containing an array with the data in the graph.Each JSON array within the portion of the pie. The JSON propiedadlabel each defines the label to describe a portion. The JSON data property defines the portion size with a number from 1 to 100.
 * @description
 * This component draws a pie graph.
 * This component is DEPRECATED. Please use mpCharts instead.
 */
/*global angular */
angular.module('mpGraphPie', ['utils'])
    .directive('mpGraphPie', ['Loader',
        function(Loader) {
            var loadPlugin = Loader.load;

            return {
                replace: true,
                link: function(scope, elm, attrs) {
                    var dataGraph = angular.fromJson(attrs.mpGraphPie);

                    /* Draws the graph using the plugin */

                    function drawGraph() {
                        angular.element.plot(elm, dataGraph.data, {
                            series: {
                                pie: {
                                    show: true
                                }
                            }
                        });
                    }

                    loadPlugin('jquery.flot.js').then(function() {
                        loadPlugin('jquery.flot.pie.js').then(drawGraph);
                    });
                }
            };
        }]);

/*global angular, _ */
angular.module('mpGrid', ['utils'])
    /**
     * @doc-component directive
     * @name gaiafrontend.directive.mpGrid
     * @param {string} mp-grid The grid id. Applied to the generated `table` where jqGrid plugin is going to be initialized.
     * @param {string=} mp-grid-pager The grid pager id. Apply to the generated `div` where the initialized jqGrid will display its pager. Notice this attribute overwrites `pager` property of jqGrid options Object.
     * @param {expression} mp-grid-options The result of the expression must be the jqGrid options Object. Visit [jqGrid official Wiki](http://www.trirand.com/jqgridwiki/doku.php?id=wiki:options "jqGrid options") for info.
     * @param {expression} mp-grid-model String expression to compile. The selected/s row/s will be assigned to the result of the expression.
     * @param {expression} mp-grid-data The result of the expression must be a collection. It will be applied as `data` property in jqGrid options Object.
     * @param {expression=} mp-grid-context The result of the expression will be the context where the cellContnt will be $compiled against. It is the current Scope by default.
     * @param {expression=} mp-grid-disabled Boolean var if grid must be disabled
     * @description
     *
     * This directive allows you to display a grid that provides solutions for representing and manipulating tabular data.
     *
     * This directive creates a `table` that is wrapped with the [jqGrid jQuery plugin](http://www.trirand.com/blog/ "jqGrid").
     *
     * Every time jqGrid plugin is initiated an event is triggered with the grid element passed as argument.
     * The event name is the mpGrid id (mpGrid passed as string) suffixed with "Set".
     * So if our mpGrid id is `myGrid`, the event name $emit-ted will be `myGridSet`.
     * There are some jqGrid functionalities that can only be applied **after** the plugin initialization so this is useful to execute this methods.
     *
     * Following there is an example of how to execute this methods inside a controller.
     *
     *  ```js
     *  $scope.$on('myGridSet', function (event, myGrid) {
     *      myGrid.jqGrid('filterToolbar', {searchOperators : true});
     *      event.stopPropagation(); // Good practice
     *  });
     *  ```
     *
     * Some times we will need to re-use a jqGrid options Object. For this matter we highly recommed to *save* this Objects in Angular services.
     *
     * If our application is multi-language we have to keep in mind that we would like to apply internationalization to our grid column headers.
     *
     * To solve this the `translate` filter needs to be executed every time jqGrid options Object is requested.
     *
     * So it is recommended to return the jqGrid options Object in a service method as follows.
     *
     *  ```js
     *  (appModule.lazy || appModule)
     *     .factory('grid', ['$filter',
     *         function($filter) {
     *             // IMPORTANT! Returned as method to translate colNames every time jqGrid options Object is requested.
     *             return {
     *                 getOptions: function() {
     *                     var options = {
     *                         "datatype": "local",
     *                         "height": 160,
     *                         "colNames": [
     *                             $filter('translate')('grids_title_one'),
     *                             $filter('translate')('grids_title_two'),
     *                             $filter('translate')('grids_title_three'),
     *                             $filter('translate')('grids_title_four'),
     *                             $filter('translate')('grids_title_five')
     *                         ],
     *                         "colModel": [{
     *                             "name": "one",
     *                             "index": "one",
     *                             "align": "left"
     *                         }, {
     *                             "name": "two",
     *                             "index": "two"
     *                         }, {
     *                             "name": "three",
     *                             "index": "three"
     *                         }, {
     *                             "name": "four",
     *                             "index": "four"
     *                         }, {
     *                             "name": "five",
     *                             "index": "five",
     *                             "hidden": true
     *                         }],
     *                         "rowNum": 5,
     *                         "rowTotal": 2000,
     *                         "rowList": [
     *                             5,
     *                             10,
     *                             15
     *                         ],
     *                         "loadonce": true,
     *                         "mtype": "GET",
     *                         "gridview": true,
     *                         "sortname": "name",
     *                         "viewrecords": true,
     *                         "sortorder": "asc",
     *                         "footerrow": false,
     *                         "autowidth": true,
     *                         "emptyrecords": "No records found"
     *                     };
     *                     return options;
     *                 }
     *             };
     *         }]);
     *  ```
     *
     * When mpGridData/mpGridOptions expression result changes, the mpGrid refreshes. This means that a new `table` is created, jqGrid plugin is initiated again with the result of compiling the current mpGridOptions and mpGridData expressions and every method inside the event listener will execute again.
     *
     * @example
       <doc:example module="mpGrid">
        <doc:source>
        script
            function MyCtrl($scope) {
                $scope.options = {'datatype':'local','height':160,'colNames':['ID','Date','CD','Amount'],'colModel':[{'name':'item_id','index':'item_id'},{'name':'item_date','index':'item_date'},{'name':'item_cd','index':'item_cd'},{'name':'amount','index':'amount'}],'rowNum':4,'rowTotal':2000,'rowList':[5,10,15],'loadonce':true,'mtype':'GET','gridview':true,'sortname':'name','viewrecords':true,'sortorder':'asc','footerrow':false,'autowidth':true,'emptyrecords':'No records found'};
                $scope.data = [{'item_id':'1','item_date':'2012-05-24','item_cd':'test1','amount':'1700'},{'item_id':'2','item_date':'2012-05-24','item_cd':'test2','amount':'1700'},{'item_id':'3','item_date':'2012-05-24','item_cd':'test3','amount':'1700'},{'item_id':'4','item_date':'2012-05-24','item_cd':'test4','amount':'1700'},{'item_id':'5','item_date':'2012-05-24','item_cd':'test5','amount':'1700'},{'item_id':'6','item_date':'2012-05-24','item_cd':'test6','amount':'1700'},{'item_id':'7','item_date':'2012-05-24','item_cd':'test7','amount':'1700'},{'item_id':'8','item_date':'2012-05-24','item_cd':'test8','amount':'1700'},{'item_id':'9','item_date':'2012-05-24','item_cd':'test9','amount':'1700'},{'item_id':'10','item_date':'2012-05-24','item_cd':'test10','amount':'1700'},{'item_id':'11','item_date':'2012-05-24','item_cd':'test11','amount':'1700'},{'item_id':'12','item_date':'2012-05-24','item_cd':'test12','amount':'1700'},{'item_id':'13','item_date':'2012-05-24','item_cd':'test13','amount':'1700'},{'item_id':'14','item_date':'2012-05-24','item_cd':'test14','amount':'1700'},{'item_id':'15','item_date':'2012-05-24','item_cd':'test15','amount':'1700'},{'item_id':'16','item_date':'2012-05-24','item_cd':'test16','amount':'1700'},{'item_id':'17','item_date':'2012-05-24','item_cd':'test17','amount':'1700'},{'item_id':'18','item_date':'2012-05-24','item_cd':'test18','amount':'1700'}, {'item_id':'19','item_date':'2012-05-25','item_cd':'test19','amount':'8000'},{'item_id':'20','item_date':'2012-05-24','item_cd':'test20','amount':'1700'}, {'item_id':'21','item_date':'2012-05-25','item_cd':'test21','amount':'8000'},{'item_id':'22','item_date':'2012-05-24','item_cd':'test22','amount':'1700'}, {'item_id':'23','item_date':'2012-05-25','item_cd':'test23','amount':'8000'}];
            }
            MyCtrl.$inject = ['$scope'];
        div(ng-controller="MyCtrl")
            div
                div(mp-grid="grid_id", mp-grid-pager="grid_pager_id", mp-grid-model="selectedElement", mp-grid-options="options", mp-grid-data="data")
                p
                    button.btn.btn-default(type="button", ng-click='data.push({"item_id":"0","item_date":"2012-05-24","item_cd":"Modified Test","amount":"1700"})') Change data
                pre Selected: {{selectedElement | json}}
                pre Data: {{data | json}}
        </doc:source>
       </doc:example>
     */
    .directive('mpGrid', ['Loader', 'Language', '$parse', '$compile',
        function (Loader, Language, $parse, $compile) {
            return {
                link: function (scope, elem, attrs) {
                    var loadPlugin = Loader.load,
                        lang = Language.get().languageId,
                        localeFile = 'i18n/grid.locale-' + lang + '.js',
                        jqGridPluginFile = 'jquery.jqGrid.src.js',
                        resizePluginFile = 'jquery.resize.tweaked.js',
                        mpGrid = attrs.mpGrid,
                        mpGridPager = attrs.mpGridPager,
                        mpGridModel = attrs.mpGridModel,
                        mpGridOptions = attrs.mpGridOptions,
                        mpGridData = attrs.mpGridData,
                        mpGridContext = attrs.mpGridContext,
                        mpGridDisabled = attrs.mpGridDisabled,
                        grid,
                        pager,
                        gridDataHadIds,
                        onResizeElem;

                    function isVisible(elem) {
                        return elem.get(0).offsetWidth > 0 || elem.get(0).offsetHeight > 0;
                    }

                    function newGrid() {
                        return angular.element('<table>').attr('id', mpGrid);
                    }

                    function newPager() {
                        return angular.element('<div>').attr('id', mpGridPager);
                    }

                    function getFilters(filters) {
                        var values = [];

                        if (filters.length > 0) {
                            angular.forEach(filters, function (filter) {
                                values.push(filter.value);
                            });
                        }
                        return values;
                    }

                    function setFilters(values) {
                        var filters = angular.element('.frozen-div .ui-search-table .ui-search-input').find('input');

                        if (filters.length > 0) {
                            for (var i = 0; i < filters.length; i++) {
                                filters.eq(i).val(values[i]);
                            }
                        }

                        filters = null;
                    }

                    function setGridWidth() {
                        if (!isVisible(elem)) {
                            return;
                        }

                        var gridOptions,
                            groupHeader,
                            filters,
                            searchs,
                            frozenColumns,
                            gridState;

                        function hasFrozenColumns(colModel) {
                            return !!_.find(colModel, function (col) {
                                return col.frozen;
                            });
                        }

                        gridOptions = angular.copy($parse(mpGridOptions)(scope));
                        searchs = angular.element('.frozen-div .ui-search-table .ui-search-input').find('input');
                        groupHeader = grid.jqGrid('getGridParam', 'groupHeader');
                        frozenColumns = hasFrozenColumns(grid.jqGrid('getGridParam', 'colModel'));
                        gridState = grid.jqGrid('getGridParam', 'gridstate');

                        if (groupHeader) {
                            grid.jqGrid('destroyGroupHeader');
                        }


                        if (frozenColumns) {
                            if (searchs.length > 0) {
                                filters = getFilters(searchs);
                            }
                            grid.jqGrid('destroyFrozenColumns');
                        }

                        if (!gridOptions.width) { // RESIZE ONLY IF WIDTH PROPERTY IS NOT PROVIDED BY jqGrdid OPTIONS OBJECT
                            grid.jqGrid('setGridWidth', elem.width());
                        }

                        if (groupHeader) {
                            grid.jqGrid('setGroupHeaders', groupHeader);
                        }

                        if (frozenColumns) {
                            if (gridState === 'visible') {
                                grid.jqGrid('setFrozenColumns');
                                grid.trigger('reloadGrid', [{
                                    current: true
                                }]);
                            }
                            if (searchs.length > 0) {
                                setFilters(filters);
                            }
                        }

                        // scope.$emit(mpGrid + 'Set', grid);
                    }

                    function isDataOk(data) {
                        return data && _.every(data, function (element) {
                            return !!element;
                        });
                    }

                    function addOddClass() {
                        var rows = elem.find('[role="row"]');

                        angular.forEach(rows, function (row, key) {
                            if (key % 2 !== 0) {
                                angular.element(row).addClass('oddRow');
                            }
                        });
                    }

                    function getLocalRow(rowId) {
                        var localRow = angular.copy(grid.jqGrid('getLocalRow', rowId));

                        if (!gridDataHadIds) {
                            delete localRow.id;
                        }

                        return localRow || {};
                    }

                    function getDataItem(rowId) {
                        var localRow = grid.jqGrid('getLocalRow', rowId) || {},
                            localIndex = _.findIndex(grid.jqGrid('getGridParam', 'data'), function (i) {
                                return angular.equals(i, localRow);
                            });

                        return $parse(mpGridData)(scope)[localIndex] || {};
                    }

                    function bindSelectedElement(rowId) {
                        var multiselect = grid.jqGrid('getGridParam', 'multiselect');

                        if (multiselect) {
                            scope.$apply(function () {
                                var currentModel = $parse(mpGridModel)(scope) || [],
                                    currentPageRowIds = grid.jqGrid('getDataIDs'),
                                    currentPageRows = [],
                                    selectedRowIds = grid.jqGrid('getGridParam', 'selarrrow'),
                                    selectedRows = [];

                                // TODO: Optimize
                                angular.forEach(currentPageRowIds, function (rowId) {
                                    currentPageRows.push(attrs.mpGridModelReferenced ? getDataItem(rowId) : getLocalRow(rowId));
                                });

                                angular.forEach(selectedRowIds, function (rowId) {
                                    selectedRows.push(attrs.mpGridModelReferenced ? getDataItem(rowId) : getLocalRow(rowId));
                                });

                                angular.forEach(currentPageRows, function (row) {
                                    var rowInCurrentModelIndex = _.findIndex(currentModel, row),
                                        rowInSelectedRowsIndex = _.findIndex(selectedRows, row);

                                    if (rowInCurrentModelIndex === -1 && rowInSelectedRowsIndex > -1) {
                                        currentModel.push(row);
                                    }

                                    if (rowInCurrentModelIndex > -1 && rowInSelectedRowsIndex === -1) {
                                        currentModel.splice(rowInCurrentModelIndex, 1);
                                    }

                                });

                                if (currentPageRowIds.length === selectedRows.length) {
                                    grid.closest('.ui-jqgrid-view').find('.ui-jqgrid-hdiv .cbox').prop('checked', true);
                                } else {
                                    grid.closest('.ui-jqgrid-view').find('.ui-jqgrid-hdiv .cbox').prop('checked', false);
                                }

                                $parse(mpGridModel).assign(scope, currentModel);
                            });
                        } else {
                            scope.$apply(function () {
                                $parse(mpGridModel).assign(scope, attrs.mpGridModelReferenced ? getDataItem(rowId) : getLocalRow(rowId));
                            });
                        }
                    }

                    function isSelected(rowId) {
                        var multiselect = grid.jqGrid('getGridParam', 'multiselect'),
                            selected = false;

                        if (multiselect) {
                            selected = !!_.find(grid.jqGrid('getGridParam', 'selarrrow'), function (selectedRowId) {
                                return rowId === selectedRowId;
                            });
                        } else {
                            selected = rowId === grid.jqGrid('getGridParam', 'selrow');
                        }

                        return selected;
                    }

                    function isRowInModel(rowId, model) {
                        var multiselect = grid.jqGrid('getGridParam', 'multiselect'),
                            rowInModel = false;

                        if (multiselect) {
                            rowInModel = !!_.find(model, function (modelItem) {
                                return angular.equals(attrs.mpGridModelReferenced ? getDataItem(rowId) : getLocalRow(rowId), modelItem);
                            });
                        } else {
                            rowInModel = angular.equals(model, attrs.mpGridModelReferenced ? getDataItem(rowId) : getLocalRow(rowId));
                        }

                        return rowInModel;
                    }

                    function updateSelectedRow(model) {
                        if (!grid) return;

                        var currentPageRowIds = grid.jqGrid('getDataIDs');

                        if (angular.isArray(model) && model.length) {
                            var selectedRows = 0;

                            angular.forEach(currentPageRowIds, function (rowId) {
                                if (isRowInModel(rowId, model) && !isSelected(rowId)) {
                                    grid.jqGrid('setSelection', rowId, false);
                                    selectedRows += 1;
                                } else if (!isRowInModel(rowId, model) && isSelected(rowId)) {
                                    grid.jqGrid('setSelection', rowId, false);
                                } else if (attrs.mpGridModelReferenced && isRowInModel(rowId, model) && isSelected(rowId)) {
                                    grid.jqGrid('setRowData', rowId, angular.extend(getLocalRow(rowId), getDataItem(rowId)));
                                }
                            });

                            if (currentPageRowIds.length === selectedRows) {
                                grid.closest('.ui-jqgrid-view').find('.ui-jqgrid-hdiv .cbox').prop('checked', true);
                            }
                        } else if (angular.isObject(model) && !_.isEmpty(model)) {
                            angular.forEach(currentPageRowIds, function (rowId) {
                                if (isRowInModel(rowId, model) && !isSelected(rowId)) {
                                    grid.jqGrid('setSelection', rowId, false);
                                } else if (!isRowInModel(rowId, model) && isSelected(rowId)) {
                                    grid.jqGrid('setSelection', rowId, false);
                                } else if (attrs.mpGridModelReferenced && isRowInModel(rowId, model) && isSelected(rowId)) {
                                    grid.jqGrid('setRowData', rowId, angular.extend(getLocalRow(rowId), getDataItem(rowId)));
                                }
                            });
                        } else {
                            grid.jqGrid('resetSelection');
                        }
                    }

                    // function getRealId(pagActual, rowId, rowNum) {
                    //     return ((pagActual * rowNum) - rowNum) + parseInt(rowId);
                    // }

                    function addGridEventHandlers(config) {
                        var gridCompleteFn = config.gridComplete || angular.noop,
                            onSelectAllFn = config.onSelectAll || angular.noop,
                            onSelectRowFn = config.onSelectRow || angular.noop,
                            ondblClickRowFn = config.ondblClickRow || angular.noop,
                            beforeSelectRowFn = config.beforeSelectRow || angular.noop;

                        angular.extend(config, {
                            gridComplete: function () {
                                // FIX: WE NEED TO COMPILE SO ANGULARJS DIRECTIVES USED AS ROW CONTENT WORK PROPERLY
                                // IF ISOLATED SCOPE THEN USE THE PARENT SCOPE
                                if (angular.isDefined(mpGridContext)) {
                                    $compile(grid)($parse(mpGridContext)(scope));
                                } else {
                                    $compile(grid)(scope);
                                }
                                // FIX: UPDATE SELECTIONS WITH MODEL VALUES
                                updateSelectedRow($parse(mpGridModel)(scope));
                                addOddClass();
                                gridCompleteFn.apply(this, arguments);
                            },
                            onSelectAll: function () {
                                if (!$parse(mpGridDisabled)(scope)) {
                                    bindSelectedElement.apply(this, arguments);
                                }
                                onSelectAllFn.apply(this, arguments);
                            },
                            onSelectRow: function () {
                                // var gridOptions = $parse(mpGridOptions)(scope);

                                if (!$parse(mpGridDisabled)(scope)) {
                                    bindSelectedElement.apply(this, arguments);
                                }
                                onSelectRowFn.apply(this, arguments);
                            },
                            ondblClickRow: function () {
                                if (!$parse(mpGridDisabled)(scope)) {
                                    bindSelectedElement.apply(this, arguments);
                                }
                                ondblClickRowFn.apply(this, arguments);
                            },
                            beforeSelectRow: function () {
                                var beforeSelectRowReturnValue = beforeSelectRowFn.apply(this, arguments);
                                return $parse(mpGridDisabled)(scope) ? false : angular.isDefined(beforeSelectRowReturnValue) ? beforeSelectRowReturnValue : true;
                            }
                        });

                        if ($parse(mpGridDisabled)(scope)) {
                            angular.extend(config, {
                                beforeSelectRow: function () {
                                    beforeSelectRowFn.apply(this, arguments);
                                    return false;
                                }
                            });
                        }

                        // FIX: RESPONSIVE BUG
                        onResizeElem = onResizeElem || elem.bind('resize', setGridWidth);

                        // FIX: MEMORY LEAK ISSUE
                        elem.on('$destroy', function () {
                            if (onResizeElem) {
                                onResizeElem.off('resize', setGridWidth);
                            }
                            onResizeElem = null;
                        });

                        // FIX: FROZEN COLUMNS BUG
                        // http://stackoverflow.com/questions/16516356/how-to-make-jqgrid-frozen-column-word-wrap
                        grid.triggerHandler('jqGridAfterGridComplete');
                    }

                    function addIds(gridData) {
                        var collection = angular.copy(gridData);

                        _.each(collection, function (element, index) {
                            element.id = element.id || index + 1;
                        });

                        return collection;
                    }

                    // IMPORTANT! WE NEED TO ADD ID PROPERTY TO OUR LOCAL DATA IN ORDER TO HAVE UNIQUE ROWIDs
                    // IF ANY ELEMENT OF DATA SOURCE IS 'FALSY' AN EMPTY ARRAY IS USED AS DATA SOURCE
                    function createOptionsData(gridData) {
                        var optionsData = [];

                        if (isDataOk(gridData)) {
                            // Fix this. Key can be configured via colModel
                            gridDataHadIds = gridData.length ? !!gridData[0].id : false;
                            optionsData = !gridDataHadIds ? addIds(gridData) : gridData;
                        }

                        return optionsData;
                    }

                    function setGridOptions() {
                        var gridOptions = $parse(mpGridOptions)(scope),
                            gridData = $parse(mpGridData)(scope),
                            options = angular.copy(gridOptions) || {};

                        options.data = createOptionsData(gridData);

                        if (pager) {
                            options.pager = mpGridPager;
                        }

                        addGridEventHandlers(options);

                        grid.jqGrid(options);

                        if ($parse(mpGridDisabled)(scope) && options.multiselect) {
                            grid.find('[type="checkbox"][class="cbox"]').attr('disabled', 'disabled');
                        }

                        scope.$emit(mpGrid + 'Set', grid);
                    }

                    function prepareGridDOM() {
                        elem.empty();

                        grid = newGrid();
                        elem.append(grid);

                        if (mpGridPager) {
                            pager = newPager();
                            elem.append(pager);
                        }
                    }

                    function updateGrid(newGridOptions, oldGridOptions) {
                        if (newGridOptions && oldGridOptions && (newGridOptions.refreshGrid === oldGridOptions.refreshGrid)) {
                            prepareGridDOM();
                            setGridOptions();
                        }
                    }

                    function updateGridData(data) {
                        var gridOptions = angular.extend({}, {
                            refreshGrid: true
                        }, $parse(mpGridOptions)(scope));
                        // jqGrid method setGridParam({data: data}) does not work here
                        // it deep-extends (with jQuery) the options object (grid[0].p)
                        // so if the old data contents 5 items and the new data contents 3
                        // the final data will have 5 items with the first 3 items modified
                        // We want the new data to be the final data.

                        if (grid[0]) grid[0].p.data = createOptionsData(data);
                        if (gridOptions.refreshGrid) {
                            grid.trigger('reloadGrid');
                        }
                    }

                    function watchOptions() {
                        scope.$watch(mpGridOptions, updateGrid, true);
                    }

                    function watchData() {
                        // scope.$watchCollection(mpGridData, updateGrid);
                        scope.$watch(mpGridData, updateGridData, true);
                    }

                    function watchModel() {
                        scope.$watch(mpGridModel, updateSelectedRow, true);
                    }

                    function initGrid() {
                        watchModel();
                        watchOptions();
                        watchData();
                    }

                    function checkAttributesValues() {
                        if (!mpGridModel) {
                            throw new Error('[mp-grid-model] attribute is mandatory for [mp-grid] directive to work properly');
                        }

                        if (!mpGridOptions) {
                            throw new Error('[mp-grid-options] attribute is mandatory for [mp-grid] directive to work properly');
                        }

                        if (!mpGridData) {
                            throw new Error('[mp-grid-data] attribute is mandatory for [mp-grid] directive to work properly');
                        }
                    }

                    checkAttributesValues();

                    loadPlugin(localeFile).then(function () {
                        loadPlugin(jqGridPluginFile).then(function () {
                            loadPlugin(resizePluginFile).then(initGrid);
                        });
                    });
                }
            };
        }
    ]);

/**
    * @doc-component directive
    * @name gaiafrontend.directive.mpGridActions
    * @description
    * This component has been migrated to "GAIA Site"
    * There you will find its documentation and several examples.
    * "GAIA Site" is an application created by the Architecture Area to learn and play with GAIA. Is available in RAS. Direct links are available below in this page.
    * @example
    <doc:example>
         <doc:source>
         label GAIA site direct links are:
         a(href='https://wportalinterno.es.mapfre.net/com.ibm.ram.repository.web/faces/_rlvid.jsp?_rap=!assetDetails&_rvip=/home.jsp&guid=13A33828-B921-8DC5-DEDA-8B8D7C0EBC81') Intranet /
         a(href='https://wportalinterno.mapfre.com/com.ibm.ram.repository.web/faces/_rlvid.jsp?_rap=!assetDetails&_rvip=/home.jsp&guid=13A33828-B921-8DC5-DEDA-8B8D7C0EBC81') Internet
         </doc:source>
    </doc:example>
*/
(function() {
    'use strict';

    function mpGridActions() {
        return {
            restrict: 'A',
            templateUrl: 'gaiafrontend/html/gridActions.html',
            scope: {
                mpGrid: '@mpGridActions',
                gridPager: '@mpGridActionsPager',
                gridModel: '=mpGridActionsModel',
                gridOptions: '=mpGridActionsOptions',
                gridData: '=mpGridActionsData'
            },
            transclude: true,
            controller: 'mpGridActionsCtrl',
            link: function(scope, element) {
                var addButton = angular.element('#add'),
                    copyButton = angular.element('#copy'),
                    pasteButton = angular.element('#paste');

                scope.newData = {};

                function setActions(data, cell) {
                    var actionButtons = "<button id='edit_" + cell.rowId + "' type='button' class='btn action actionEdit' title='Edit row' onclick=\"angular.element('#" + scope.mpGrid + "').editRow('" + cell.rowId + "');\"></button>" +
                        "<button id='save_" + cell.rowId + "' type='button' class='btn btn-success action actionSave' title='Save changes' ng-click=\"saveRow(" + cell.rowId + ");\"></button>" +
                        "<button id='res_" + cell.rowId + "' type='button' class='btn btn-warning action actionDiscard' title='Restore row' onclick=\"angular.element('#" + scope.mpGrid + "').restoreRow('" + cell.rowId + "');\"></button>" +
                        "<button id='del_" + cell.rowId + "' type='button' class='btn btn-danger action actionDelete' title='Delete row' ng-click=\"delRow(" + cell.rowId + ");\"></button>";


                    return actionButtons;
                }

                scope.gridOptions.colNames.splice(0, 0, '');
                scope.gridOptions.colModel.splice(0, 0, {
                    name: 'act',
                    index: 'act',
                    width: 100,
                    sortable: false,
                    align: 'center',
                    formatter: setActions
                });

                function unlisten(element, event, listener) {
                    element.off(event, listener);
                }

                function listen(element, event, listener) {
                    element.on(event, listener);
                    return function() {
                        unlisten(element, event, listener);
                    }
                }

                function getRowSelected() {
                    return angular.element('#' + scope.mpGrid).jqGrid('getGridParam', 'selrow');
                }

                /* Reloads the data in the grid after pasting a row */
                function reloadGrid() {
                    var grid = angular.element('#' + scope.mpGrid);

                    //grid.jqGrid('clearGridData');
                    grid.jqGrid('setGridParam', {
                        data: scope.gridData
                    });
                    grid.trigger('reloadGrid');
                }

                function addRow() {
                    var grid = angular.element('#' + scope.mpGrid),
                        numRows = scope.gridData.length;

                    grid.addRowData(numRows + 1, scope.newData, 'last');
                    grid.trigger("reloadGrid", [{
                        page: grid.getGridParam('lastpage')
                    }]);
                    grid.editRow(numRows + 1)
                }

                function copyRow() {
                    pasteButton.removeClass('disabled');
                    pasteButton.removeAttr('disabled');
                }

                function pasteRow() {
                    var grid = angular.element('#' + scope.mpGrid),
                        lastsel = parseInt(getRowSelected(), 10),
                        rowSel,
                        copyRow = {};

                    copyRow = angular.extend({}, scope.gridData[lastsel - 1]);

                    scope.gridData.push(copyRow);
                    reloadGrid();

                    rowSel = scope.gridData.length;
                    grid.trigger("reloadGrid", [{
                        page: grid.getGridParam('lastpage')
                    }]);
                    grid.setSelection(lastsel, true);
                    grid.editRow(rowSel);
                    grid.restoreRow(rowSel);

                    angular.element('#copy').attr('disabled', 'disabled');
                    angular.element('#paste').addClass('disabled');
                }

                var unlistenAddRow = listen(addButton, 'click', addRow),
                    unlistenCopyRow = listen(copyButton, 'click', copyRow),
                    unlistenPasteRow = listen(pasteButton, 'click', pasteRow);

                element.on('$destroy', function() {
                    unlistenAddRow();
                    unlistenCopyRow();
                    unlistenPasteRow();
                });
            }
        }
    }

    function mpGridActionsCtrl($scope, $modal, $timeout) {

        var copyButton = angular.element('#copy');

        $scope.$on($scope.mpGrid + 'Set', function(event, grid) {
            var oldSelectRow = grid.jqGrid('getGridParam').onSelectRow;

            grid.jqGrid('setGridParam', {
                onSelectRow: function(id) {
                    oldSelectRow.apply(this, arguments);
                    //$scope.rowId = id;
                    copyButton.removeClass('disabled');
                    copyButton.removeAttr('disabled');
                }
            })
        })

        function createModel(model, index) {
            var newModel = {};

            angular.forEach(_.keys(model[index - 1]), function(key) {
                if (key !== 'id') {
                    newModel[key] = model[index - 1][key];
                }
            });
            return newModel;
        }

        $scope.saveRow = function(rowId) {
            $timeout(function() {
                var grid = angular.element('#' + $scope.mpGrid);

                grid.jqGrid('saveRow', rowId);
                $scope.gridModel = createModel(grid.jqGrid('getGridParam', 'data'), rowId);
                $scope.gridData[rowId - 1] = angular.extend({}, $scope.gridModel);
            });
        }

        $scope.delRow = function(rowId) {
            var grid = angular.element('#' + $scope.mpGrid),
                gridData = $scope.gridData,
                currentPage = grid.getGridParam('page'),
                modalInstance = $modal.open({
                    backdrop: false,
                    templateUrl: 'gaiafrontend/html/mpGridActionsModal.html',
                    controller: ['$scope', '$modalInstance', '$filter',
                        function($scope, $modalInstance) {
                            $scope.ok = function() {
                                gridData.splice((rowId - 1), 1);

                                grid.jqGrid('setGridParam', {
                                    data: gridData
                                });
                                $modalInstance.close();
                            };
                            $scope.cancel = function() {
                                $modalInstance.close();
                            }
                        }
                    ]
                });

            modalInstance.result
                .then(function() {
                    grid.trigger("reloadGrid", [{
                        page: currentPage
                    }]);
                });
        }
    }
    (angular.module('mpGridActions', []))
    .directive('mpGridActions', mpGridActions)
        .controller('mpGridActionsCtrl', ['$scope', '$modal', '$timeout', mpGridActionsCtrl]);
}());

/*global angular, _ */
angular.module('mpGridCrud', [])
    .controller('MpGridCrudCtrl', ['$scope', '$parse', '$timeout', '$attrs',
        function($scope, $parse, $timeout, $attrs) {
            var itemToModifyIndex,
                removedItems,
                unregisterTempModelWatcher,
                defaultCrudOptions = {
                    'create': true,
                    'read': true,
                    'update': true,
                    'copy': true,
                    'delete': true
                };

            function isPromise(promise) {
                return promise && angular.isFunction(promise.then) && angular.isFunction(promise['catch']) && angular.isFunction(promise['finally']);
            }

            function clearRemovedItems() {
                removedItems = undefined;
            }

            function clearTempModel() {
                if (angular.isDefined(itemToModifyIndex)) itemToModifyIndex = undefined;

                $scope.tempModel = undefined;
            }

            function clearModel() {
                $scope.model = undefined;
            }

            function returnTrue() {
                return true;
            }

            // Execute the function in the next digest cycle
            // http://stackoverflow.com/a/18996042
            function applyLater(fn) {
                $timeout(fn);
            }

            $scope.editionMode = false;

            this.isAnyRowSelected = function() {
                return angular.isArray($scope.model) ? !!$scope.model.length : !!$scope.model;
            };

            this.isOnlyOneRowSelected = function() {
                return angular.isArray($scope.model) ? $scope.model.length !== 1 : !$scope.model;
            };

            this.create = function() {
                function createFn() {
                    $scope.editionMode = true;

                    $scope.tempModel = {};

                    applyLater(function () {
                        onCreateFn($scope.$parent, {
                            $model: $scope.model,
                            $tempModel: $scope.tempModel
                        });
                    });
                }

                var beforeCreateFn = $attrs.mpGridCrudBeforeCreate ? $parse($attrs.mpGridCrudBeforeCreate) : returnTrue,
                    beforeCreateFnReturn,
                    onCreateFn = $parse($attrs.mpGridCrudOnCreate);

                beforeCreateFnReturn = beforeCreateFn($scope.$parent, {
                    $model: $scope.model,
                    $tempModel: $scope.tempModel
                });

                if (isPromise(beforeCreateFnReturn)) beforeCreateFnReturn.then(createFn);
                else if (beforeCreateFnReturn !== false) createFn();
            };

            this.read = function() {
                function readFn() {
                    $scope.editionMode = false;
                    selectedItem = angular.isArray($scope.model) ? $scope.model[0] : $scope.model;
                    $scope.tempModel = angular.copy(selectedItem);

                    applyLater(function () {
                        onReadFn($scope.$parent, {
                            $model: $scope.model,
                            $tempModel: $scope.tempModel
                        });
                    });
                }

                if ($scope.model) {
                    var beforeReadFn = $attrs.mpGridCrudBeforeRead ? $parse($attrs.mpGridCrudBeforeRead) : returnTrue,
                        beforeReadFnReturn,
                        onReadFn = $parse($attrs.mpGridCrudOnRead),
                        selectedItem;

                    beforeReadFnReturn = beforeReadFn($scope.$parent, {
                        $model: $scope.model,
                        $tempModel: $scope.tempModel
                    });

                    if (isPromise(beforeReadFnReturn)) beforeReadFnReturn.then(readFn);
                    else if (beforeReadFnReturn !== false) readFn();
                }
            };

            this.update = function() {
                function updateFn() {
                    $scope.editionMode = true;

                    selectedItem = angular.isArray($scope.model) ? $scope.model[0] : $scope.model;
                    itemToModifyIndex = _.findIndex($scope.data, function(item) {
                        return _.isEqual(selectedItem, item);
                    });
                    $scope.tempModel = angular.copy(selectedItem);

                    applyLater(function () {
                        onUpdateFn($scope.$parent, {
                            $model: $scope.model,
                            $tempModel: $scope.tempModel
                        });
                    });
                }
                if ($scope.model) {
                    var beforeUpdateFn = $attrs.mpGridCrudBeforeUpdate ? $parse($attrs.mpGridCrudBeforeUpdate) : returnTrue,
                        beforeUpdateFnReturn,
                        onUpdateFn = $parse($attrs.mpGridCrudOnUpdate),
                        selectedItem;

                    beforeUpdateFnReturn = beforeUpdateFn($scope.$parent, {
                        $model: $scope.model,
                        $tempModel: $scope.tempModel
                    });

                    if (isPromise(beforeUpdateFnReturn)) beforeUpdateFnReturn.then(updateFn);
                    else if (beforeUpdateFnReturn !== false) updateFn();
                }
            };

            this['delete'] = function() {
                function deleteFn() {
                    $scope.editionMode = false;

                    angular.forEach(angular.isArray($scope.model) ? $scope.model : [$scope.model], function(selectedItem) {
                        var selectedItemIndex = _.findIndex($scope.data, function(item) {
                            return _.isEqual(selectedItem, item);
                        });

                        if (selectedItemIndex > -1) Array.prototype.push.apply(removedItems, $scope.data.splice(selectedItemIndex, 1));
                    });

                    applyLater(function () {
                        onDeleteFn($scope.$parent, {
                            $model: $scope.model,
                            $tempModel: $scope.tempModel,
                            $removedItems: removedItems
                        });
                    });

                    clearModel();
                }

                if ($scope.model) {
                    var beforeDeleteFn = $attrs.mpGridCrudBeforeDelete ? $parse($attrs.mpGridCrudBeforeDelete) : returnTrue,
                        beforeDeleteFnReturn,
                        onDeleteFn = $parse($attrs.mpGridCrudOnDelete);

                    clearRemovedItems();
                    removedItems = [];

                    beforeDeleteFnReturn = beforeDeleteFn($scope.$parent, {
                        $model: $scope.model,
                        $tempModel: $scope.tempModel,
                        $removedItems: removedItems
                    });

                    if (isPromise(beforeDeleteFnReturn)) beforeDeleteFnReturn.then(deleteFn);
                    else if (beforeDeleteFnReturn !== false) deleteFn();
                }
            };

            this.copy = function() {
                function copyFn() {
                    $scope.editionMode = true;

                    selectedItem = angular.isArray($scope.model) ? $scope.model[0] : $scope.model;
                    $scope.tempModel = angular.copy(selectedItem);

                    applyLater(function () {
                        onCopyFn($scope.$parent, {
                            $model: $scope.model,
                            $tempModel: $scope.tempModel
                        });
                    });
                }

                if ($scope.model) {
                    var beforeCopyFn = $attrs.mpGridCrudBeforeCopy ? $parse($attrs.mpGridCrudBeforeCopy) : returnTrue,
                        beforeCopyFnReturn,
                        onCopyFn = $parse($attrs.mpGridCrudOnCopy),
                        selectedItem;

                    beforeCopyFnReturn = beforeCopyFn($scope.$parent, {
                        $model: $scope.model,
                        $tempModel: $scope.tempModel
                    });

                    if (isPromise(beforeCopyFnReturn)) beforeCopyFnReturn.then(copyFn);
                    else if (beforeCopyFnReturn !== false) copyFn();
                }
            };

            this.cancel = function() {
                function cancelFn() {
                    $scope.editionMode = false;

                    applyLater(function () {
                        onCancelFn($scope.$parent, locals);
                    });
                    clearTempModel();
                    clearRemovedItems();
                }

                if ($scope.tempModel) {
                    var beforeCancelFn = $attrs.mpGridCrudBeforeCancel ? $parse($attrs.mpGridCrudBeforeCancel) : returnTrue,
                        beforeCancelFnReturn,
                        onCancelFn = $parse($attrs.mpGridCrudOnCancel),
                        locals = {
                            $model: $scope.model,
                            $tempModel: $scope.tempModel
                        };

                    if (removedItems) {
                        angular.extend(locals, {
                            $removedItems: removedItems
                        });
                    }

                    beforeCancelFnReturn = beforeCancelFn($scope.$parent, locals);

                    if (isPromise(beforeCancelFnReturn)) beforeCancelFnReturn.then(cancelFn);
                    else if (beforeCancelFnReturn !== false) cancelFn();
                }
            };

            this.confirm = function() {
                function confirmFn() {
                    $scope.editionMode = false;

                    // Adding
                    if (!_.isEmpty($scope.tempModel)) {
                        if (angular.isUndefined(itemToModifyIndex)) {
                            $scope.data.push($scope.tempModel);
                            // Modifying
                        } else if (itemToModifyIndex > -1) {
                            $scope.data.splice(itemToModifyIndex, 1, $scope.tempModel);
                        }
                    }

                    applyLater(function () {
                        onConfirmFn($scope.$parent, locals);
                    });

                    $scope.model = angular.isArray($scope.model) ? [$scope.tempModel] : $scope.tempModel;
                    clearTempModel();
                    clearRemovedItems();
                }

                if ($scope.tempModel) {
                    var beforeConfirmFn = $attrs.mpGridCrudBeforeConfirm ? $parse($attrs.mpGridCrudBeforeConfirm) : returnTrue,
                        beforeConfirmFnReturn,
                        onConfirmFn = $parse($attrs.mpGridCrudOnConfirm),
                        locals = {
                            $model: $scope.model,
                            $tempModel: $scope.tempModel
                        };

                    if (removedItems) {
                        angular.extend(locals, {
                            $removedItems: removedItems
                        });
                    }

                    beforeConfirmFnReturn = beforeConfirmFn($scope.$parent, locals);

                    if (isPromise(beforeConfirmFnReturn)) beforeConfirmFnReturn.then(confirmFn);
                    else if (beforeConfirmFnReturn !== false) confirmFn();
                }
            };

            $scope.options.crud = angular.extend(defaultCrudOptions, $scope.options.crud);

            $scope.$on($scope.id + 'Set', function(event, grid) {
                var isMultiselect = grid.jqGrid('getGridParam', 'multiselect');

                if (isMultiselect) {
                    // Avoid uneeded watchers
                    if (unregisterTempModelWatcher) {
                        unregisterTempModelWatcher();
                    }
                    // Disable selection checkboxes
                    unregisterTempModelWatcher = $scope.$watch('editionMode', function(tempModel) {
                        if (tempModel) {
                            grid.find('[type="checkbox"][class="cbox"]').attr('disabled', 'disabled');
                        } else {
                            grid.find('[type="checkbox"][class="cbox"]').removeAttr('disabled');
                        }
                    }, true);
                }
                // Block row selection if tempModel has value
                grid.jqGrid('setGridParam', {
                    beforeSelectRow: function() {
                        return !$scope.editionMode;
                    }
                });
            });
        }])
    /**
     * @doc-component directive
     * @name gaiafrontend.directive.mpGridCrud
     * @param {string} mp-grid-crud The grid id. Applied to the generated `table` where jqGrid plugin is going to be initialized.
     * @param {string=} mp-grid-crud-pager The grid pager id. Apply to the generated `div` where the initialized jqGrid will display its pager. Notice this attribute overwrites `pager` property of jqGrid options Object.
     * @param {expression} mp-grid-crud-options The result of the expression must be the jqGrid options Object. Visit [jqGrid official Wiki](http://www.trirand.com/jqgridwiki/doku.php?id=wiki:options "jqGrid options") for info. It can be extended with `crud` property to extend default `mpGridCrud` behaviour.
     * @param {expression} mp-grid-crud-model The selected/s row/s will be assigned to the result of the expression.
     * @param {expression} mp-grid-crud-temp-model When creating/updating an item it will be assigned to the result of the expression.
     * @param {expression} mp-grid-crud-data The result of the expression must be a collection. It will be applied as `data` property in jqGrid options Object.
     * @param {expression=} mp-grid-crud-disabled Buttons will display enabled or disabled depending on the result of this expression.
     * @param {expression=} mp-grid-crud-before-create Expression to evaluate when clicking on Add(Create) button, before creating the `$tempModel`. This expression has to return a 'truthy' value to let the execution flow continue. Model is available as `$model`. Temp model is available as `$tempModel`.
     * @param {expression=} mp-grid-crud-on-create Expression to evaluate when clicking on Add(Create) button, after creating the `$tempModel`. Model is available as `$model`. Temp model is available as `$tempModel`.
     * @param {expression=} mp-grid-crud-before-read Expression to evaluate when clicking on Detail(Read) button. Model is available as `$model`. This expression has to return a 'truthy' value to let the execution flow continue. Temp model is available as `$tempModel`.
     * @param {expression=} mp-grid-crud-on-read Expression to evaluate when clicking on Detail(Read) button. Model is available as `$model`. Temp model is available as `$tempModel`.
     * @param {expression=} mp-grid-crud-before-update Expression to evaluate when clicking on Modify(Update) button, before creating the `$tempModel`. This expression has to return a 'truthy' value to let the execution flow continue. Model is available as `$model`. Temp model is available as `$tempModel`.
     * @param {expression=} mp-grid-crud-on-update Expression to evaluate when clicking on Modify(Update) button. Model is available as `$model`. Temp model is available as `$tempModel`.
     * @param {expression=} mp-grid-crud-before-delete Expression to evaluate when clicking on Remove(Delete) button, before removing and creating the `$removedItems`. This expression has to return a 'truthy' value to let the execution flow continue. Model is available as `$model`. Temp model is available as `$tempModel`. Removed items are available as `$removedItems`.
     * @param {expression=} mp-grid-crud-on-delete Expression to evaluate when clicking on Remove(Delete) button. Model is available as `$model`. Temp model is available as `$tempModel`. Removed items are available as `$removedItems`.
     * @param {expression=} mp-grid-crud-before-copy Expression to evaluate when clicking on Copy button, before creating the `$tempModel`. This expression has to return a 'truthy' value to let the execution flow continue. Model is available as `$model`. Temp model is available as `$tempModel`.
     * @param {expression=} mp-grid-crud-on-copy Expression to evaluate when clicking on Copy button. Model is available as `$model`. Temp model is available as `$tempModel`.
     * @param {expression=} mp-grid-crud-before-cancel Expression to evaluate when clicking on Cancel button, before cancelling changes. This expression has to return a 'truthy' value to let the execution flow continue. Model is available as `$model`. Temp model is available as `$tempModel`. If there are removed items they will be available as `$removedItems`.
     * @param {expression=} mp-grid-crud-on-cancel Expression to evaluate when clicking on Cancel button. Model is available as `$model`. Temp model is available as `$tempModel`. If there are removed items they will be available as `$removedItems`.
     * @param {expression=} mp-grid-crud-before-confirm Expression to evaluate when clicking on Confirm button, before applying the changes. This expression has to return a 'truthy' value to let the execution flow continue. Model is available as `$model`. Temp model is available as `$tempModel`. If there are removed items they will be available as `$removedItems`.
     * @param {expression=} mp-grid-crud-on-confirm Expression to evaluate when clicking on Confirm button. Model is available as `$model`. Temp model is available as `$tempModel`. If there are removed items they will be available as `$removedItems`.
     * @description
     *
     * This directive extends `mpGrid` adding CRUD behaviour.
     *
     * This component displays Add (Create), Detail (Read), Modify (Update), Remove (Delete), Copy, Cancel and Confirm buttons by default.
     *
     * - Add (Create) button will add a new entry to the data displayed in the grid (it will push a new item into `mpGridCrudData` collection). Once clicked you can change `mpGridCrudTempModel` properties. If you want this new item to be added, you can do it by clicking on `Confirm` button. You can click on `Cancel` otherwise.
     * - Detail (Read) button will expose the selected item from `mpGridCrudData` collection.
     * - Modify (Update) button will modify the selected item from `mpGridCrudData` collection. Once clicked you can change `mpGridCrudTempModel` properties. If you want these changes to take effect you can commit them by clicking on `Confirm` button. You can click on `Cancel` otherwise.
     * - Remove (Delete) button will remove the selected/s item/s from `mpGridCrudData` collection.
     * - Copy button will create a copy of the selected item, let you modify its properties and then add it as a new entry to the data displayed in the grid (it will push the copy into `mpGridCrudData` collection). Once clicked you can change `mpGridCrudTempModel` properties. Once modified, if you want these changes to take effect, you can commit them by clicking on `Confirm` button. You can click on `Cancel` otherwise.
     * - Cancel button will only appear if one of Add(Create), Modify(Update) or Copy button is displayed. It will be enabled when Creating,  Updating or Copying an item. It will discard any change.
     * - Confirm button will only appear if one of Add(Create), Modify(Update) or Copy button is displayed. It will be enabled Creating,  Updating or Copying an item. It will commit the changes.
     *
     * Component behaviour can be extended/modified by properties defined inside `crud` property in `mpGridCrudOptions` parsed expression object. Following are the described the allowed options with their default values:
     *
     *  ```js
     *  {
     *     "create": true,
     *     "read": true,
     *     "update": true,
     *     "copy": true,
     *     "delete": true
     *  }
     *  ```
     *
     * When mpGridCrudData/mpGridCrudOptions expression result changes, the mpGridCrud refreshes. This means that a new `table` is created, jqGrid plugin is initiated again with the result of compiling the current mpGridCrudOptions and mpGridCrudData expressions and every method inside the event listener will execute again.
     *
     * @example
       <doc:example module="mpGridCrud">
        <doc:source>
        script
            function MyCtrl($scope) {
                $scope.crud = {
                    options: {'datatype':'local','height':160,'colNames':['ID','Date','CD','Amount'],'colModel':[{'name':'item_id','index':'item_id'},{'name':'item_date','index':'item_date'},{'name':'item_cd','index':'item_cd'},{'name':'amount','index':'amount'}],'rowNum':4,'rowTotal':2000,'rowList':[5,10,15],'loadonce':true,'mtype':'GET','gridview':true,'sortname':'name','viewrecords':true,'sortorder':'asc','footerrow':false,'autowidth':true,'emptyrecords':'No records found'},
                    data: [{'item_id':'1','item_date':'2012-05-24','item_cd':'test1','amount':'1700'},{'item_id':'2','item_date':'2012-05-24','item_cd':'test2','amount':'1700'},{'item_id':'3','item_date':'2012-05-24','item_cd':'test3','amount':'1700'},{'item_id':'4','item_date':'2012-05-24','item_cd':'test4','amount':'1700'},{'item_id':'5','item_date':'2012-05-24','item_cd':'test5','amount':'1700'},{'item_id':'6','item_date':'2012-05-24','item_cd':'test6','amount':'1700'},{'item_id':'7','item_date':'2012-05-24','item_cd':'test7','amount':'1700'},{'item_id':'8','item_date':'2012-05-24','item_cd':'test8','amount':'1700'},{'item_id':'9','item_date':'2012-05-24','item_cd':'test9','amount':'1700'},{'item_id':'10','item_date':'2012-05-24','item_cd':'test10','amount':'1700'},{'item_id':'11','item_date':'2012-05-24','item_cd':'test11','amount':'1700'},{'item_id':'12','item_date':'2012-05-24','item_cd':'test12','amount':'1700'},{'item_id':'13','item_date':'2012-05-24','item_cd':'test13','amount':'1700'},{'item_id':'14','item_date':'2012-05-24','item_cd':'test14','amount':'1700'},{'item_id':'15','item_date':'2012-05-24','item_cd':'test15','amount':'1700'},{'item_id':'16','item_date':'2012-05-24','item_cd':'test16','amount':'1700'},{'item_id':'17','item_date':'2012-05-24','item_cd':'test17','amount':'1700'},{'item_id':'18','item_date':'2012-05-24','item_cd':'test18','amount':'1700'}, {'item_id':'19','item_date':'2012-05-25','item_cd':'test19','amount':'8000'},{'item_id':'20','item_date':'2012-05-24','item_cd':'test20','amount':'1700'}, {'item_id':'21','item_date':'2012-05-25','item_cd':'test21','amount':'8000'},{'item_id':'22','item_date':'2012-05-24','item_cd':'test22','amount':'1700'}, {'item_id':'23','item_date':'2012-05-25','item_cd':'test23','amount':'8000'}]
                }
            }
            MyCtrl.$inject = ['$scope'];
        div(ng-controller="MyCtrl")
            div
                div(mp-grid-crud="crud_id", mp-grid-crud-pager="crud_pager_id", mp-grid-crud-model="crud.model", mp-grid-crud-temp-model="crud.tempModel", mp-grid-crud-options="crud.options", mp-grid-crud-data="crud.data")
                p
                    button.btn.btn-default(type="button", ng-click='data.push({"item_id":"0","item_date":"2012-05-24","item_cd":"Modified Test","amount":"1700"})') Add data
                pre Selected: {{crud.model | json}}
                pre Data: {{crud.data | json}}
        </doc:source>
       </doc:example>
     */
    .directive('mpGridCrud', [
        function() {
            return {
                templateUrl: 'gaiafrontend/html/mpGridCrud.html',
                scope: {
                    id: '@mpGridCrud',
                    pagerId: '@mpGridCrudPager',
                    model: '=mpGridCrudModel',
                    tempModel: '=mpGridCrudTempModel',
                    data: '=mpGridCrudData',
                    options: '=mpGridCrudOptions',
                    disabled: '=mpGridCrudDisabled'// ,
                    // onCreateFn: '&mpGridCrudOnCreate',
                    // onReadFn: '&mpGridCrudOnRead',
                    // onUpdateFn: '&mpGridCrudOnUpdate',
                    // onDeleteFn: '&mpGridCrudOnDelete',
                    // onCopyFn: '&mpGridCrudOnCopy',
                    // onCancelFn: '&mpGridCrudOnCancel',
                    // onConfirmFn: '&mpGridCrudOnConfirm'
                },
                controller: 'MpGridCrudCtrl',
                controllerAs: 'MpGridCrud'
            };
        }
    ]);

/*global angular, _ */
/*DEPRECATED*/
angular.module('mpGridCrudMultiple', [])
    .controller('MpGridCrudMultipleCtrl', ['$scope', '$parse', '$timeout', '$attrs',
        function($scope, $parse, $timeout, $attrs) {
            var itemsToModfyIndexes,
                itemsToRemoveIndexes,
                unregisterTempModelWatcher,
                defaultCrudOptions = {
                    'create': true,
                    'read': true,
                    'update': true,
                    'copy': true,
                    'delete': true
                },
                MpGridCrudMultiple = this;

            function isPromise(promise) {
                return promise && angular.isFunction(promise.then) && angular.isFunction(promise['catch']) && angular.isFunction(promise['finally']);
            }

            function isMultiselect() {
                return !!($scope.options && $scope.options.multiselect);
            }

            function clearVariables() {
                itemsToModfyIndexes = undefined;
                itemsToRemoveIndexes = undefined;
                $scope.tempModel = undefined;
            }

            function returnTrue() {
                return true;
            }

            // Execute the function in the next digest cycle
            // http://stackoverflow.com/a/18996042
            function applyLater(fn) {
                $timeout(fn);
            }

            MpGridCrudMultiple.editionMode = false;

            MpGridCrudMultiple.isAnyRowSelected = function() {
                return isMultiselect() ? !!$scope.model && $scope.model.length : !!$scope.model;
            };

            MpGridCrudMultiple.create = function() {
                function createFn() {
                    MpGridCrudMultiple.editionMode = true;

                    $scope.tempModel = isMultiselect() ? [{}] : {};

                    applyLater(function () {
                        onCreateFn($scope.$parent, {
                            $model: $scope.model,
                            $tempModel: $scope.tempModel
                        });
                    });
                }

                var beforeCreateFn = $attrs.mpGridCrudMultipleBeforeCreate ? $parse($attrs.mpGridCrudMultipleBeforeCreate) : returnTrue,
                    beforeCreateFnReturn,
                    onCreateFn = $parse($attrs.mpGridCrudMultipleOnCreate);

                beforeCreateFnReturn = beforeCreateFn($scope.$parent, {
                    $model: $scope.model,
                    $tempModel: $scope.tempModel
                });

                if (isPromise(beforeCreateFnReturn)) beforeCreateFnReturn.then(createFn);
                else if (beforeCreateFnReturn !== false) createFn();
            };

            MpGridCrudMultiple.read = function() {
                function readFn() {
                    MpGridCrudMultiple.editionMode = false;
                    $scope.tempModel = angular.copy($scope.model);

                    applyLater(function () {
                        onReadFn($scope.$parent, {
                            $model: $scope.model,
                            $tempModel: $scope.tempModel
                        });
                    });
                }

                if ($scope.model) {
                    var beforeReadFn = $attrs.mpGridCrudMultipleBeforeRead ? $parse($attrs.mpGridCrudMultipleBeforeRead) : returnTrue,
                        beforeReadFnReturn,
                        onReadFn = $parse($attrs.mpGridCrudMultipleOnRead);

                    beforeReadFnReturn = beforeReadFn($scope.$parent, {
                        $model: $scope.model,
                        $tempModel: $scope.tempModel
                    });

                    if (isPromise(beforeReadFnReturn)) beforeReadFnReturn.then(readFn);
                    else if (beforeReadFnReturn !== false) readFn();
                }
            };

            MpGridCrudMultiple.update = function() {
                function updateFn() {
                    MpGridCrudMultiple.editionMode = true;

                    if (isMultiselect()) {
                        itemsToModfy = [];
                        angular.forEach($scope.model, function(selectedItem) {
                            selectedItemIndex = _.findIndex($scope.data, function(item) {
                                return _.isEqual(selectedItem, item);
                            });

                            itemsToModfyIndexes.push(selectedItemIndex);
                            itemsToModfy.push(angular.copy($scope.data[selectedItemIndex]));
                        });
                    } else {
                        selectedItemIndex = _.findIndex($scope.data, function(item) {
                            return _.isEqual($scope.model, item);
                        });

                        itemsToModfyIndexes.push(selectedItemIndex);
                        itemsToModfy = angular.copy($scope.data[selectedItemIndex]);
                    }

                    $scope.tempModel = itemsToModfy;

                    applyLater(function () {
                        onUpdateFn($scope.$parent, {
                            $model: $scope.model,
                            $tempModel: $scope.tempModel
                        });
                    });
                }
                if ($scope.model) {
                    var beforeUpdateFn = $attrs.mpGridCrudMultipleBeforeUpdate ? $parse($attrs.mpGridCrudMultipleBeforeUpdate) : returnTrue,
                        beforeUpdateFnReturn,
                        onUpdateFn = $parse($attrs.mpGridCrudMultipleOnUpdate),
                        selectedItemIndex,
                        itemsToModfy;

                    itemsToModfyIndexes = [];

                    beforeUpdateFnReturn = beforeUpdateFn($scope.$parent, {
                        $model: $scope.model,
                        $tempModel: $scope.tempModel
                    });

                    if (isPromise(beforeUpdateFnReturn)) beforeUpdateFnReturn.then(updateFn);
                    else if (beforeUpdateFnReturn !== false) updateFn();
                }
            };

            MpGridCrudMultiple['delete'] = function() {
                function deleteFn() {
                    MpGridCrudMultiple.editionMode = true;

                    if (isMultiselect()) {
                        itemsToRemove = [];
                        angular.forEach(isMultiselect() ? $scope.model : [$scope.model], function(selectedItem) {
                            selectedItemIndex = _.findIndex($scope.data, function(item) {
                                return _.isEqual(selectedItem, item);
                            });

                            itemsToRemoveIndexes.push(selectedItemIndex);
                            itemsToRemove.push(angular.copy($scope.data[selectedItemIndex]));
                            // Array.prototype.push.apply(itemsToRemove, $scope.data.splice(selectedItemIndex, 1));
                        });
                    } else {
                        selectedItemIndex = _.findIndex($scope.data, function(item) {
                            return _.isEqual($scope.model, item);
                        });

                        itemsToRemoveIndexes.push(selectedItemIndex);
                        itemsToRemove = angular.copy($scope.data[selectedItemIndex]);
                    }

                    $scope.tempModel = itemsToRemove;

                    applyLater(function () {
                        onDeleteFn($scope.$parent, {
                            $model: $scope.model,
                            $tempModel: $scope.tempModel
                        });
                    });
                }

                if ($scope.model) {
                    var beforeDeleteFn = $attrs.mpGridCrudMultipleBeforeDelete ? $parse($attrs.mpGridCrudMultipleBeforeDelete) : returnTrue,
                        beforeDeleteFnReturn,
                        onDeleteFn = $parse($attrs.mpGridCrudMultipleOnDelete),
                        selectedItemIndex,
                        itemsToRemove;

                    itemsToRemoveIndexes = []

                    beforeDeleteFnReturn = beforeDeleteFn($scope.$parent, {
                        $model: $scope.model,
                        $tempModel: $scope.tempModel
                    });

                    if (isPromise(beforeDeleteFnReturn)) beforeDeleteFnReturn.then(deleteFn);
                    else if (beforeDeleteFnReturn !== false) deleteFn();
                }
            };

            MpGridCrudMultiple.copy = function() {
                function copyFn() {
                    MpGridCrudMultiple.editionMode = true;

                    $scope.tempModel = angular.copy($scope.model);

                    applyLater(function () {
                        onCopyFn($scope.$parent, {
                            $model: $scope.model,
                            $tempModel: $scope.tempModel
                        });
                    });
                }

                if ($scope.model) {
                    var beforeCopyFn = $attrs.mpGridCrudMultipleBeforeCopy ? $parse($attrs.mpGridCrudMultipleBeforeCopy) : returnTrue,
                        beforeCopyFnReturn,
                        onCopyFn = $parse($attrs.mpGridCrudMultipleOnCopy);

                    beforeCopyFnReturn = beforeCopyFn($scope.$parent, {
                        $model: $scope.model,
                        $tempModel: $scope.tempModel
                    });

                    if (isPromise(beforeCopyFnReturn)) beforeCopyFnReturn.then(copyFn);
                    else if (beforeCopyFnReturn !== false) copyFn();
                }
            };

            MpGridCrudMultiple.cancel = function() {
                function cancelFn() {
                    MpGridCrudMultiple.editionMode = false;

                    applyLater(function () {
                        onCancelFn($scope.$parent, {
                            $model: $scope.model,
                            $tempModel: $scope.tempModel
                        });
                        clearVariables();
                    });
                }

                if ($scope.tempModel) {
                    var beforeCancelFn = $attrs.mpGridCrudMultipleBeforeCancel ? $parse($attrs.mpGridCrudMultipleBeforeCancel) : returnTrue,
                        beforeCancelFnReturn,
                        onCancelFn = $parse($attrs.mpGridCrudMultipleOnCancel);

                    beforeCancelFnReturn = beforeCancelFn($scope.$parent, {
                        $model: $scope.model,
                        $tempModel: $scope.tempModel
                    });

                    if (isPromise(beforeCancelFnReturn)) beforeCancelFnReturn.then(cancelFn);
                    else if (beforeCancelFnReturn !== false) cancelFn();
                }
            };

            function clearModel() {
                $scope.model = undefined;
            }

            function sortDesc(arr) {
                return arr.sort(function (a, b) {
                    return b - a;
                });
            }

            function hasContent(obj) {
                return !(_.isEmpty(obj) || (_.keys(obj).length === 1 && obj.$$hashKey))
            }

            MpGridCrudMultiple.confirm = function() {
                function confirmFn() {
                    MpGridCrudMultiple.editionMode = false;

                     // Adding
                    if (angular.isUndefined(itemsToModfyIndexes) && angular.isUndefined(itemsToRemoveIndexes)) {
                        if (isMultiselect()) {
                            angular.forEach(angular.isArray($scope.tempModel) ? $scope.tempModel : [$scope.tempModel], function (tempModel) {
                                if (hasContent(tempModel)) $scope.data.push(angular.copy(tempModel));
                            });
                        } else {
                            $scope.data.push(angular.copy($scope.tempModel));
                        }
                    // Modifying
                    } else if (angular.isDefined(itemsToModfyIndexes)) {
                        if (isMultiselect()) {
                            angular.forEach(itemsToModfyIndexes, function (itemToModfyIndex, i) {
                                $scope.data.splice(itemToModfyIndex, 1,  angular.copy($scope.tempModel[i]));
                                $scope.model[i] = angular.copy($scope.tempModel[i]);
                            });
                        } else {
                            $scope.data.splice(itemsToModfyIndexes[0], 1, angular.copy($scope.tempModel));
                            $scope.model = angular.copy($scope.tempModel);
                        }
                    // Deleting
                    } else if (angular.isDefined(itemsToRemoveIndexes)) {
                        if (isMultiselect()) {
                            angular.forEach(sortDesc(itemsToRemoveIndexes), function (itemToRemoveIndex) {
                                Array.prototype.push.apply(removedItems, angular.copy($scope.data.splice(itemToRemoveIndex, 1)));
                            });
                        } else {
                            Array.prototype.push.apply(removedItems, angular.copy($scope.data.splice(itemsToRemoveIndexes[0], 1)));
                        }

                        clearModel();
                    }

                    applyLater(function () {
                        onConfirmFn($scope.$parent, {
                            $model: $scope.model,
                            $tempModel: $scope.tempModel
                        });

                        $scope.model = $scope.tempModel;
                        clearVariables();
                    });
                }

                if ($scope.tempModel) {
                    var beforeConfirmFn = $attrs.mpGridCrudMultipleBeforeConfirm ? $parse($attrs.mpGridCrudMultipleBeforeConfirm) : returnTrue,
                        beforeConfirmFnReturn,
                        onConfirmFn = $parse($attrs.mpGridCrudMultipleOnConfirm),
                        removedItems = [];

                    beforeConfirmFnReturn = beforeConfirmFn($scope.$parent, {
                        $model: $scope.model,
                        $tempModel: $scope.tempModel
                    });

                    if (isPromise(beforeConfirmFnReturn)) beforeConfirmFnReturn.then(confirmFn);
                    else if (beforeConfirmFnReturn !== false) confirmFn();
                }
            };

            $scope.options.crud = angular.extend(defaultCrudOptions, $scope.options.crud);

            $scope.$on($scope.id + 'Set', function (event, grid) {
                var isMultiselect = grid.jqGrid('getGridParam', 'multiselect');

                if (isMultiselect) {
                    // AUnregister old watcher
                    if (unregisterTempModelWatcher) unregisterTempModelWatcher();
                    // Disable selection checkboxes
                    unregisterTempModelWatcher = $scope.$watch(function () {
                        return MpGridCrudMultiple.editionMode;
                    }, function (editionMode) {
                        var cboxes = grid.closest('#gview_' + $scope.id).find('[type="checkbox"][class="cbox"]');
                        if (editionMode) {
                            cboxes.attr('disabled', 'disabled');
                        } else {
                            cboxes.removeAttr('disabled');
                        }
                    }, true);
                }
                // Block row selection if tempModel has value
                grid.jqGrid('setGridParam', {
                    beforeSelectRow: function() {
                        return !MpGridCrudMultiple.editionMode;
                    }
                });
            });
        }])
    /**
     * @doc-component directive
     * @name gaiafrontend.directive.mpGridCrudMultiple
     * @param {string} mp-grid-crud-multiple The grid id. Applied to the generated `table` where jqGrid plugin is going to be initialized.
     * @param {string=} mp-grid-crud-multiple-pager The grid pager id. Apply to the generated `div` where the initialized jqGrid will display its pager. Notice this attribute overwrites `pager` property of jqGrid options Object.
     * @param {expression} mp-grid-crud-multiple-options The result of the expression must be the jqGrid options Object. Visit [jqGrid official Wiki](http://www.trirand.com/jqgridwiki/doku.php?id=wiki:options "jqGrid options") for info. It can be extended with `crud` property to extend default `mpGridCrudMultiple` behaviour.
     * @param {expression} mp-grid-crud-multiple-model The selected/s row/s will be assigned to the result of the expression.
     * @param {expression} mp-grid-crud-multiple-temp-model When creating/updating an item it will be assigned to the result of the expression.
     * @param {expression} mp-grid-crud-multiple-data The result of the expression must be a collection. It will be applied as `data` property in jqGrid options Object.
     * @param {expression=} mp-grid-crud-multiple-disabled Buttons will display enabled or disabled depending on the result of this expression.
     * @param {expression=} mp-grid-crud-multiple-before-create Expression to evaluate when clicking on Add(Create) button, before creating the `$tempModel`. This expression has to return a 'truthy' value to let the execution flow continue. Model is available as `$model`. Temp model is available as `$tempModel`.
     * @param {expression=} mp-grid-crud-multiple-on-create Expression to evaluate when clicking on Add(Create) button, after creating the `$tempModel`. Model is available as `$model`. Temp model is available as `$tempModel`.
     * @param {expression=} mp-grid-crud-multiple-before-read Expression to evaluate when clicking on Detail(Read) button. Model is available as `$model`. This expression has to return a 'truthy' value to let the execution flow continue. Temp model is available as `$tempModel`.
     * @param {expression=} mp-grid-crud-multiple-on-read Expression to evaluate when clicking on Detail(Read) button. Model is available as `$model`. Temp model is available as `$tempModel`.
     * @param {expression=} mp-grid-crud-multiple-before-update Expression to evaluate when clicking on Modify(Update) button, before creating the `$tempModel`. This expression has to return a 'truthy' value to let the execution flow continue. Model is available as `$model`. Temp model is available as `$tempModel`.
     * @param {expression=} mp-grid-crud-multiple-on-update Expression to evaluate when clicking on Modify(Update) button. Model is available as `$model`. Temp model is available as `$tempModel`.
     * @param {expression=} mp-grid-crud-multiple-before-delete Expression to evaluate when clicking on Remove(Delete) button, before removing and creating the `$tempModel`. This expression has to return a 'truthy' value to let the execution flow continue. Model is available as `$model`. Items to remove are available as `$tempModel`.
     * @param {expression=} mp-grid-crud-multiple-on-delete Expression to evaluate when clicking on Remove(Delete) button. Model is available as `$model`. Items to remove are available as `$tempModel`.
     * @param {expression=} mp-grid-crud-multiple-before-copy Expression to evaluate when clicking on Copy button, before creating the `$tempModel`. This expression has to return a 'truthy' value to let the execution flow continue. Model is available as `$model`. Temp model is available as `$tempModel`.
     * @param {expression=} mp-grid-crud-multiple-on-copy Expression to evaluate when clicking on Copy button. Model is available as `$model`. Temp model is available as `$tempModel`.
     * @param {expression=} mp-grid-crud-multiple-before-cancel Expression to evaluate when clicking on Cancel button, before cancelling changes. This expression has to return a 'truthy' value to let the execution flow continue. Model is available as `$model`. If there were items to remove they will be available as `$tempModel`.
     * @param {expression=} mp-grid-crud-multiple-on-cancel Expression to evaluate when clicking on Cancel button. Model is available as `$model`. If there were items to remove they will be available as `$tempModel`.
     * @param {expression=} mp-grid-crud-multiple-before-confirm Expression to evaluate when clicking on Confirm button, before applying the changes. This expression has to return a 'truthy' value to let the execution flow continue. Model is available as `$model`. If there are items to remove they will be available as `$tempModel`.
     * @param {expression=} mp-grid-crud-multiple-on-confirm Expression to evaluate when clicking on Confirm button. Model is available as `$model`. If there are removed items they will be available as `$tempModel`.
     * @description
     *
     * This directive extends `mpGrid` adding CRUD behaviour.
     *
     * This component displays Add (Create), Detail (Read), Modify (Update), Remove (Delete), Copy, Cancel and Confirm buttons by default.
     *
     * - Add (Create) button will add a new entry to the data displayed in the grid (it will push a new item into `mpGridCrudMultipleData` collection). Once clicked you can change `mpGridCrudMultipleTempModel` properties. If you want this new item to be added, you can do it by clicking on `Confirm` button. You can click on `Cancel` otherwise.
     * - Detail (Read) button will expose the selected item from `mpGridCrudMultipleData` collection.
     * - Modify (Update) button will modify the selected item from `mpGridCrudMultipleData` collection. Once clicked you can change `mpGridCrudMultipleTempModel` properties. If you want these changes to take effect you can commit them by clicking on `Confirm` button. You can click on `Cancel` otherwise.
     * - Remove (Delete) button will remove the selected/s item/s from `mpGridCrudMultipleData` collection.
     * - Copy button will create a copy of the selected item, let you modify its properties and then add it as a new entry to the data displayed in the grid (it will push the copy into `mpGridCrudMultipleData` collection). Once clicked you can change `mpGridCrudMultipleTempModel` properties. Once modified, if you want these changes to take effect, you can commit them by clicking on `Confirm` button. You can click on `Cancel` otherwise.
     * - Cancel button will only appear if one of Add(Create), Modify(Update) or Copy button is displayed. It will be enabled when Creating,  Updating or Copying an item. It will discard any change.
     * - Confirm button will only appear if one of Add(Create), Modify(Update) or Copy button is displayed. It will be enabled Creating,  Updating or Copying an item. It will commit the changes.
     *
     * Component behaviour can be extended/modified by properties defined inside `crud` property in `mpGridCrudMultipleOptions` parsed expression object. Following are the described the allowed options with their default values:
     *
     *  ```js
     *  {
     *     "create": true,
     *     "read": true,
     *     "update": true,
     *     "copy": true,
     *     "delete": true
     *  }
     *  ```
     *
     * When mpGridCrudMultipleData/mpGridCrudMultipleOptions expression result changes, the mpGridCrudMultiple refreshes. This means that a new `table` is created, jqGrid plugin is initiated again with the result of compiling the current mpGridCrudMultipleOptions and mpGridCrudMultipleData expressions and every method inside the event listener will execute again.
     *
     * @example
       <doc:example module="mpGridCrudMultiple">
        <doc:source>
        script
            function MyCtrl($scope) {
                $scope.crud = {
                    options: {'datatype':'local','height':160,'colNames':['ID','Date','CD','Amount'],'colModel':[{'name':'item_id','index':'item_id'},{'name':'item_date','index':'item_date'},{'name':'item_cd','index':'item_cd'},{'name':'amount','index':'amount'}],'rowNum':4,'rowTotal':2000,'rowList':[5,10,15],'loadonce':true,'mtype':'GET','gridview':true,'sortname':'name','viewrecords':true,'sortorder':'asc','footerrow':false,'autowidth':true,'emptyrecords':'No records found'},
                    data: [{'item_id':'1','item_date':'2012-05-24','item_cd':'test1','amount':'1700'},{'item_id':'2','item_date':'2012-05-24','item_cd':'test2','amount':'1700'},{'item_id':'3','item_date':'2012-05-24','item_cd':'test3','amount':'1700'},{'item_id':'4','item_date':'2012-05-24','item_cd':'test4','amount':'1700'},{'item_id':'5','item_date':'2012-05-24','item_cd':'test5','amount':'1700'},{'item_id':'6','item_date':'2012-05-24','item_cd':'test6','amount':'1700'},{'item_id':'7','item_date':'2012-05-24','item_cd':'test7','amount':'1700'},{'item_id':'8','item_date':'2012-05-24','item_cd':'test8','amount':'1700'},{'item_id':'9','item_date':'2012-05-24','item_cd':'test9','amount':'1700'},{'item_id':'10','item_date':'2012-05-24','item_cd':'test10','amount':'1700'},{'item_id':'11','item_date':'2012-05-24','item_cd':'test11','amount':'1700'},{'item_id':'12','item_date':'2012-05-24','item_cd':'test12','amount':'1700'},{'item_id':'13','item_date':'2012-05-24','item_cd':'test13','amount':'1700'},{'item_id':'14','item_date':'2012-05-24','item_cd':'test14','amount':'1700'},{'item_id':'15','item_date':'2012-05-24','item_cd':'test15','amount':'1700'},{'item_id':'16','item_date':'2012-05-24','item_cd':'test16','amount':'1700'},{'item_id':'17','item_date':'2012-05-24','item_cd':'test17','amount':'1700'},{'item_id':'18','item_date':'2012-05-24','item_cd':'test18','amount':'1700'}, {'item_id':'19','item_date':'2012-05-25','item_cd':'test19','amount':'8000'},{'item_id':'20','item_date':'2012-05-24','item_cd':'test20','amount':'1700'}, {'item_id':'21','item_date':'2012-05-25','item_cd':'test21','amount':'8000'},{'item_id':'22','item_date':'2012-05-24','item_cd':'test22','amount':'1700'}, {'item_id':'23','item_date':'2012-05-25','item_cd':'test23','amount':'8000'}]
                }
            }
            MyCtrl.$inject = ['$scope'];
        div(ng-controller="MyCtrl")
            div
                div(mp-grid-crud-multiple="crud_id", mp-grid-crud-multiple-pager="crud_pager_id", mp-grid-crud-multiple-model="crud.model", mp-grid-crud-multiple-temp-model="crud.tempModel", mp-grid-crud-multiple-options="crud.options", mp-grid-crud-multiple-data="crud.data")
                p
                    button.btn.btn-default(type="button", ng-click='data.push({"item_id":"0","item_date":"2012-05-24","item_cd":"Modified Test","amount":"1700"})') Add data
                pre Selected: {{crud.model | json}}
                pre Data: {{crud.data | json}}
        </doc:source>
       </doc:example>
     */
    .directive('mpGridCrudMultiple', [
        function() {
            return {
                templateUrl: 'gaiafrontend/html/mpGridCrudMultiple.html',
                scope: {
                    id: '@mpGridCrudMultiple',
                    pagerId: '@mpGridCrudMultiplePager',
                    model: '=mpGridCrudMultipleModel',
                    tempModel: '=mpGridCrudMultipleTempModel',
                    data: '=mpGridCrudMultipleData',
                    options: '=mpGridCrudMultipleOptions',
                    disabled: '=mpGridCrudMultipleDisabled'// ,
                    // onCreateFn: '&mpGridCrudMultipleOnCreate',
                    // onReadFn: '&mpGridCrudMultipleOnRead',
                    // onUpdateFn: '&mpGridCrudMultipleOnUpdate',
                    // onDeleteFn: '&mpGridCrudMultipleOnDelete',
                    // onCopyFn: '&mpGridCrudMultipleOnCopy',
                    // onCancelFn: '&mpGridCrudMultipleOnCancel',
                    // onConfirmFn: '&mpGridCrudMultipleOnConfirm'
                },
                controller: 'MpGridCrudMultipleCtrl',
                controllerAs: 'MpGridCrudMultiple'
            };
        }
    ]);

/*global angular */
angular.module('mpHeader', [])
/**
    * @doc-component directive
    * @name gaiafrontend.directive.mpHeader
    * @description
    * This component has been migrated to "GAIA Site"
    * There you will find its documentation and several examples.
    * "GAIA Site" is an application created by the Architecture Area to learn and play with GAIA. Is available in RAS. Direct links are available below in this page.
    * @example
    <doc:example>
         <doc:source>
         label GAIA site direct links are:
         a(href='https://wportalinterno.es.mapfre.net/com.ibm.ram.repository.web/faces/_rlvid.jsp?_rap=!assetDetails&_rvip=/home.jsp&guid=13A33828-B921-8DC5-DEDA-8B8D7C0EBC81') Intranet /
         a(href='https://wportalinterno.mapfre.com/com.ibm.ram.repository.web/faces/_rlvid.jsp?_rap=!assetDetails&_rvip=/home.jsp&guid=13A33828-B921-8DC5-DEDA-8B8D7C0EBC81') Internet
         </doc:source>
    </doc:example>
*/
    .directive('mpHeader', ['Utils', function(Utils) {
        return {
            replace: true,
            transclude: true,
            templateUrl: 'gaiafrontend/html/header.html',
            compile: function(elem, attrs) {
                var mpNavBar,
                    header = angular.element('#mp-header');

                if (attrs.hasOwnProperty('mpHeaderMenu')) {
                    mpNavBar = angular.element('<div>');
                    mpNavBar.attr('mp-navbar', attrs.mpHeaderMenu);
                    mpNavBar.attr('mp-navbar-options', '{showOnClick: true}');
                    elem.find('#mp-header').prepend(mpNavBar);
                }

                if (attrs.hasOwnProperty('mpHeaderMenuFilter')) {
                    mpNavBar = angular.element('<div>');
                    mpNavBar.attr('mp-navbar-filter', attrs.mpHeaderMenuFilter);
                    elem.find('#mp-header').prepend(mpNavBar);
                }

                elem.find('#mp-header .navbar-brand-group span.navbar-app').html(attrs.mpHeader);


                angular.element('button.navbar-toggle').on('click', function(event) {
                    if (Utils.platform.isIE8()) {
                        if (header.height() > 1) {
                            event.stopPropagation();
                            headerAnimate();
                            header.toggleClass('in');
                        }
                    }
                });

                angular.element('div.app-content-container').on('click', function() {
                    if (header.hasClass('in')) {
                        header.toggleClass('in');
                        headerAnimate();
                    }
                });

                function headerAnimate() {
                    header.animate({
                        height: '1px'
                    }, 'fast');
                }

                return function(scope, elem, attrs) {
                    scope.title = attrs.mpHeader;

                    function hasNoNavbars() {
                        return elem.find('[class^="navbar-"]').length === 5 && elem.find('[mp-navbar]').length === 0;
                    }

                    if (hasNoNavbars()) {
                        elem.find('.navbar-header').remove();
                    }
                };
            }
        };
    }]);

/*global angular, _*/
angular.module('mpIban', [])
    /**
        * @doc-component directive
        * @name gaiafrontend.directive.mpIban
        * @description
        * This component has been migrated to "GAIA Site"
        * There you will find its documentation and several examples.
        * "GAIA Site" is an application created by the Architecture Area to learn and play with GAIA. Is available in RAS. Direct links are available below in this page.
        * @example
        <doc:example>
             <doc:source>
             label GAIA site direct links are:
             a(href='https://wportalinterno.es.mapfre.net/com.ibm.ram.repository.web/faces/_rlvid.jsp?_rap=!assetDetails&_rvip=/home.jsp&guid=13A33828-B921-8DC5-DEDA-8B8D7C0EBC81') Intranet /
             a(href='https://wportalinterno.mapfre.com/com.ibm.ram.repository.web/faces/_rlvid.jsp?_rap=!assetDetails&_rvip=/home.jsp&guid=13A33828-B921-8DC5-DEDA-8B8D7C0EBC81') Internet
             </doc:source>
        </doc:example>
    */
    .factory('IBANSrv', function() {
        var accountLengths = {
            'AL': 28, //Albania
            'AD': 24, //Andorra
            'AT': 20, //Austria
            'AZ': 28, //Azerbaijan
            'BH': 22, //Bahrain
            'BE': 16, //Belgium
            'BA': 20, //Bosnia and Herzegovina
            'BR': 29, //Brazil
            'BG': 22, //Bulgaria
            'BF': 24, //Burkina Faso
            'CR': 21, //Costa Rica
            'HR': 21, //Croatia
            'CY': 28, //Cyprus
            'CZ': 24, //Czech Republic
            'DK': 18, //Denmark
            'DO': 28, //Dominican Republic
            'EE': 20, //Estonia
            'FO': 18, //Faroe Islands[Note 4]
            'FI': 18, //Finland
            'FR': 27, //France[Note 5]
            'GE': 22, //Georgia
            'DE': 22, //Germany
            'GI': 23, //Gibraltar
            'GR': 27, //Greece
            'GL': 18, //Greenland[Note 4]
            'GT': 28, //Guatemala
            'HU': 28, //Hungary
            'IS': 26, //Iceland
            'IE': 22, //Ireland
            'IL': 23, //Israel
            'IT': 27, //Italy
            'KZ': 20, //Kazakhstan
            'KW': 30, //Kuwait
            'LV': 21, //Latvia
            'LB': 28, //Lebanon
            'LI': 21, //Liechtenstein
            'LT': 20, //Lithuania
            'LU': 20, //Luxembourg
            'MK': 19, //Macedonia
            'MT': 31, //Malta
            'MR': 27, //Mauritania
            'MU': 30, //Mauritius
            'MC': 27, //Monaco
            'MD': 24, //Moldova
            'ME': 22, //Montenegro
            'NL': 18, //Netherlands[Note 6]
            'NO': 15, //Norway
            'PK': 24, //Pakistan
            'PS': 29, //Palestinian
            'PL': 28, //Poland
            'PT': 25, //Portugal
            'QA': 29, //Qatar
            'RO': 24, //Romania
            'SM': 27, //San Marino
            'SA': 24, //Saudi Arabia
            'RS': 22, //Serbia
            'SK': 24, //Slovakia
            'SI': 19, //Slovenia
            'ES': 24, //Spain
            'SE': 24, //Sweden
            'CH': 21, //Switzerland
            'TN': 24, //Tunisia
            'TR': 26, //Turkey
            'AE': 23, //United Arab Emirates
            'GB': 22, //United Kingdom[Note 7]
            'VG': 24 //Virgin Islands, British
        };

        function char2Digits(ch) {
            var upp = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
                i;
            for (i = 0; i < upp.length; i = i + 1) {
                if (ch === upp.charAt(i)) {
                    return i + 10;
                }
            }
        }

        function calcularIBAN(ncuenta, cpais) {
            if (cpais.length !== 2) {
                return '';
            } else {
                var aux, csiguientes, tmp;
                ncuenta = ncuenta + (cpais.charCodeAt(0) - 55).toString() + (cpais.charCodeAt(1) - 55).toString() + '00';
                tmp = parseInt(ncuenta.substring(0, 9), 10) % 97;
                if (tmp < 10) {
                    aux = '0';
                } else {
                    aux = '';
                }
                aux = aux + tmp.toString();
                ncuenta = ncuenta.substring(9);
                while (ncuenta !== '') {
                    if (parseInt(aux, 10) < 10) {
                        csiguientes = 8;
                    } else {
                        csiguientes = 7;
                    }
                    if (ncuenta.length < csiguientes) {
                        aux = aux + ncuenta;
                        ncuenta = '';
                    } else {
                        aux = aux + ncuenta.substring(0, csiguientes);
                        ncuenta = ncuenta.substring(csiguientes);
                    }
                    tmp = parseInt(aux, 10) % 97;
                    if (tmp < 10) {
                        aux = '0';
                    } else {
                        aux = '';
                    }
                    aux = aux + tmp.toString();
                }
                tmp = 98 - parseInt(aux, 10);
                if (tmp < 10) {
                    return '0' + tmp.toString();
                } else {
                    return tmp.toString();
                }
            }
        }

        function string2Digits(str) {
            var result = '',
                strArray = str.split('');

            _.each(strArray, function(ch) {
                if ('0' <= ch && ch <= '9') {
                    result += ch;
                } else {
                    result += char2Digits(ch);
                }
            });

            return result;
        }

        function m97(digits) {
            var m = 0,
                digitsArray = digits.split('');

            _.each(digitsArray, function(digit) {
                m = (m * 10 + parseInt(digit, 10)) % 97;
            });

            return m;
        }

        function getIbanLength(country) {
            return accountLengths[country];
        }

        function checkIbanDigits(iban) {
            var countryCode = iban.substring(0, 2),
                checkDigits = iban.substring(2, 4),
                accountCode = iban.substring(4),
                digits = '',
                check;
            digits += string2Digits(accountCode);
            digits += string2Digits(countryCode);
            digits += checkDigits;
            check = 98 - m97(digits);
            return (check === 97);
        }

        function correctLength(value, countryCode) {
            if (typeof accountLengths[countryCode] === 'undefined') {
                return false;
            }

            return (value.length === accountLengths[countryCode]);
        }

        function isIbanRequired(value) {
            var countryCode = value.substring(0, 2);

            return value.toUpperCase() === countryCode.toUpperCase() ? false : true;
        }

        function checkIban(value) {
            var valid,
                countryCode = value.substring(0, 2);

            value = value.toUpperCase();
            if (!isIbanRequired(value)) {
                valid = true;
            } else if (!correctLength(value, countryCode)) {
                valid = false;
            } else {
                valid = checkIbanDigits(value);
            }
            return valid;
        }

        function checkAccountLengths(country, format) {
            var sum = 0;
            _.each(format, function(digit) {
                sum += digit;
            });
            return sum === accountLengths[country];
        }

        function calculatePlaceholder(size) {
            var placeholder = '',
                i;
            for (i = 1; i <= size; i = i + 1) {
                placeholder = placeholder + '0';
            }
            return placeholder;
        }

        function generateIbanField(country, format) {
            var ibanParts = [],
                positions = [],
                ibanLength = accountLengths[country],
                fieldsWithSize4 = (ibanLength / 4) - 1,
                otherFieldSize = ibanLength % 4,
                // otherFieldPlaceholder,
                i;

            if (_.isUndefined(format)) {
                positions.push(2); // Country
                positions.push(2); // IBAN code

                for (i = 1; i <= fieldsWithSize4; i = i + 1) {
                    positions.push(4);
                }

                if (otherFieldSize) {
                    positions.push(otherFieldSize);
                }

            } else {
                positions = format;
            }
/*
            ibanParts.push({
                size: 2,
                placeholder: '',
                value: country
            });
*/
            if (checkAccountLengths(country, positions)) {
                //positions = _.rest(positions);

                for (i = 0; i < positions.length; i = i + 1) {
                    ibanParts.push({
                        size: positions[i],
                        placeholder: calculatePlaceholder(positions[i]),
                        value: ''
                    });
                    if (i === 0){
                        ibanParts[i].value = country;
                    }
                }
            }

            return ibanParts;
        }

        function joinIbanParts(parts) {
            var ibanComplete = _.reduce(parts, function(acc, part) {
                return acc + part.value;
            }, '');

            return ibanComplete;
        }

        return {
            checkIban: checkIban,
            calcularIBAN: calcularIBAN,
            isIbanRequired: isIbanRequired,
            generateIbanField: generateIbanField,
            joinIbanParts: joinIbanParts,
            getIbanLength: _.memoize(getIbanLength)

        };
    })
    .directive('mpIban', ['IBANSrv', '$timeout', function(IBANSrv, $timeout) {
        return {
            restrict: 'A',
            templateUrl: 'gaiafrontend/html/iban.html',
            scope: {
                mpIban: '=',
                mpIbanAutoCalculatedDC: '=',
                mpIbanFormat: '=',
                mpName: '@name',
                mpDisabled: '='
            },
            require: '?ngModel',
            link: function(scope, element, attrs, controller) {

                var iban,
                    maxlength,
                    isRequired = attrs.required || false;

                function keyUpHandler(e) {
                    var target = e.target || e.srcElement,
                        keyCode = e.which || e.keyCode;
                    maxlength = angular.element(target).attr('maxlength');
                    if (keyCode !== 9 && keyCode !== 16 && !e.shiftKey) {
                        if (angular.element(target).val().length === (parseInt(maxlength, 10))) {
                            angular.element(target).parent().next('.form-group').find('input').focus();
                        }
                    }
                }

                function addRequiredProperty() {
                    var input = angular.element(element.find('input'));

                    if (isRequired) {
                        input.attr('aria-required', true);
                        input.prop('required', true);
                    }
                }

                function isPristineObject(element) {
                    var isPristine = true,
                        ibanInputs = angular.element(element.find('input'));
                    _.each(ibanInputs, function(item) {
                        isPristine = isPristine && angular.element(item).hasClass('ng-pristine');
                    });
                    return isPristine;
                }

                function assignDCValue(DC) {
                    if (scope.ibanParts[0].size === 2) {
                        scope.ibanParts[1].value = DC;
                    } else {
                        scope.ibanParts[0].value = scope.mpIban + DC;
                    }
                }

                scope.$watch('mpIban', function() {
                    scope.ibanParts = '';
                    scope.ibanParts = IBANSrv.generateIbanField(scope.mpIban, scope.mpIbanFormat);
                    $timeout(function() {
                        addRequiredProperty();
                        element.find('input').on('keyup', keyUpHandler);
                    });
                }, true);

                scope.$watch('ibanParts', function(newValue) {
                    if (newValue && !isPristineObject(element)) {
                        iban = IBANSrv.joinIbanParts(newValue);
                        controller.$setViewValue(iban);
                        controller.$setValidity('iban', IBANSrv.checkIban(iban));
                        if (isRequired) {
                            controller.$setValidity('required', IBANSrv.isIbanRequired(iban));
                        }
                        scope.model = iban;
                    }

                }, true);

                scope.$on('destroy', function() {
                    element.find('input').off('keyup', keyUpHandler);
                });

                controller.$render = function() {
                    scope.model = controller.$viewValue || '';
                };

                scope.$watch('model', function(newValue) {
                    var DC, cuenta, start;
                    var cccLength = 0;
                    var length = 4;
                    var mpIbanAutoCalculatedDC = scope.mpIbanAutoCalculatedDC;
                    if(scope.mpIbanFormat && scope.mpIbanFormat[0] === 4){
                        mpIbanAutoCalculatedDC = true;
                    }
                    if (scope.ibanParts[0].size === 2) {
                        start = 2;
                    } else {
                        start = 1;
                    }
                    _.each(scope.ibanParts.slice(start, scope.ibanParts.length), function(part) {
                        cccLength += part.value.length;
                    });

                    if (newValue === '') {
                        newValue = scope.mpIban;
                    }
                    if (newValue.length === IBANSrv.getIbanLength(scope.mpIban) && cccLength + 4 === IBANSrv.getIbanLength(scope.mpIban) && mpIbanAutoCalculatedDC) {
                        cuenta = newValue.substring(4, newValue.length);
                        DC = IBANSrv.calcularIBAN(cuenta, scope.mpIban);
                        assignDCValue(DC);
                    } else if (mpIbanAutoCalculatedDC){
                        assignDCValue('xx')
                    }
                    if (newValue.length === IBANSrv.getIbanLength(scope.mpIban)) {
                        if (_.isUndefined(DC)) {
                            DC = newValue.substring(2, 4);
                        }
                        assignDCValue(DC);
                        _.each(scope.ibanParts.slice(start, scope.ibanParts.length), function(part) {
                            part.value = newValue.substr(length, part.size);
                            length = length + part.size;
                        });
                    }
                }, true);
            }
        };
    }])
    .directive('numbersOnly',
        function() {
            return {
                require: 'ngModel',
                link: function(scope, element, attr, ngModelCtrl) {
                    function fromUser(text) {
                        var transformedInput = text.replace(/[^0-9]/g, '');
                        if (transformedInput !== text) {
                            ngModelCtrl.$setViewValue(transformedInput);
                            ngModelCtrl.$render();
                        }
                        return transformedInput;
                    }
                    ngModelCtrl.$parsers.push(fromUser);
                }
            };
        });

/*global angular */
/*DEPRECATED*/
angular.module('mpId', [])
    .directive('mpId', function() {
        //DNI mask:   elm.attr("ui-mask","99999999-a");
        //NIE mask:   elm.attr("ui-mask","a9999999-a");

        function sendValidity(valid, ctrl) {
            ctrl.$setValidity('identity', valid);
        }

        function validDni(dni) {
            var chararter = dni.substr(8),
                dniNumber = dni.substr(0, 8),
                lockup = 'TRWAGMYFPDXBNJZSQVHLCKE';
            return angular.uppercase(chararter) === lockup.charAt(dniNumber % 23);
        }

        function validNie() {
            // var firstChararter = nie.substr(0, 0),
            //     lastChararter = nie.substr(8),
            //     nieNumber = nie.substr(0, 8);
            return true; // esperando validacion
        }

        function validFormat(text) {

            if (text === undefined || text === null) {
                return false;
            }
            if (text.match(/^\d{8}[a-zA-Z]$/)) {
                return validDni(text);
            }
            if (text.match(/^[a-zA-Z]\d{7}[a-zA-Z]$/)) {
                //return 'NIE';
                return validNie(text);
            } else {
                return false; //return 'FORMAT ERROR';
            }
        }

        return {
            restrict: 'A',
            require: 'ng-model',
            link: function(scope, elm, attrs, ctrl) {
                var valid;

                function toUser(modelvalue) {
                    valid = validFormat(modelvalue);
                    sendValidity(valid, ctrl);

                    return valid ? modelvalue : undefined;
                }

                function fromUser(text) {
                    valid = validFormat(text);
                    sendValidity(valid, ctrl);

                    return valid ? text : undefined;
                }
                //sendValidity(valid)
                ctrl.$formatters.push(toUser);
                ctrl.$parsers.push(fromUser);

            }
        };
    });

/*global angular, _ */
/*DEPRECATED*/
/**
 * @doc-component directive
 * @name gaiafrontend.directive.mpInputAutocomplete
 * @description
 * DEPRECATED
 * Use mpTypeahead instead
 */
angular.module('mpInputAutocomplete', [])
    .directive('mpInputAutocomplete', ['$timeout',
        function($timeout) {
            var COMBOBOX_SHOW_ALL_BUTTON_CLASS = 'combobox-show-all-button';
            return {
                require: '?ngModel',
                link: function(scope, lElm, lAttrs, ngModelCtrl) {
                    var input = lElm,
                        showAllButton,
                        showAllButtonOnClick,
                        wasOpen = false,
                        suggestions,
                        formattersIncluded = false;

                    // Remove old "show all button" if input is recompiled
                    lElm.siblings('.' + COMBOBOX_SHOW_ALL_BUTTON_CLASS).remove();
                    if (lAttrs.mpInputAutocompleteCombobox) {
                        showAllButtonOnClick = function () {
                            input.focus();

                            // Close if already visible
                            if (wasOpen) {
                                return;
                            }

                            // Pass empty string as value to search for, displaying all results
                            input.autocomplete('search', '');
                        };

                        showAllButton = angular.element('<a>')
                            .attr('tabIndex', -1)
                            .attr('title', 'Show all items')
                            .addClass(COMBOBOX_SHOW_ALL_BUTTON_CLASS)
                            .mousedown(function() {
                                wasOpen = input.autocomplete('widget').is(':visible');
                            })
                            .on('click', showAllButtonOnClick);

                        input.after(showAllButton);
                    }

                    function toUser(value) {
                        var suggestionFound;

                        suggestionFound = _.find(suggestions, function(suggestion) {
                            return suggestion.value === value;
                        });

                        return suggestionFound ? suggestionFound.label : undefined;
                    }

                    function fromUser(label) {
                        var suggestionFound;

                        suggestionFound = _.find(suggestions, function(suggestion) {
                            return suggestion.label === label;
                        });

                        return suggestionFound ? suggestionFound.value : undefined;
                    }

                    function updateSuggestions(suggs) {
                        var autocompleteSource = [];

                        suggestions = suggs;

                        function includeFormatters() {
                            ngModelCtrl.$formatters.push(toUser);
                            ngModelCtrl.$parsers.push(fromUser);
                            formattersIncluded = true;
                        }

                        if (_.isPlainObject(suggestions[0])) { // Suggestions is an array of objects with "label" and "value" properties

                            if (!formattersIncluded) {
                                includeFormatters();
                            }

                            _.each(suggestions, function(suggestion) {
                                autocompleteSource.push(suggestion.label);
                            });
                        } else {
                            Array.prototype.push.apply(autocompleteSource, suggestions);
                        }

                        input.autocomplete({
                            source: autocompleteSource,
                            minLength: 0,
                            select: function () {
                                // FIX. The angular model does not update if input event is not triggered
                                // when selecting from suggestions
                                $timeout(function () {
                                    // FIX. <IE9 do not support input event
                                    if (angular.element('html').hasClass('lt-ie9')) {
                                        input.trigger('change');
                                    } else {
                                        input.trigger('input');
                                    }
                                }, 0);
                            }
                        });
                    }

                    if (lAttrs.ngDisabled) {
                        scope.$watch(lAttrs.ngDisabled, function (disabled) {
                            if (disabled) {
                                input.addClass('disabled');
                                if (showAllButton) {
                                    showAllButton.addClass('not-allowed').off('click');
                                }
                            } else if (!disabled) {
                                input.removeClass('disabled');
                                if (showAllButton) {
                                    showAllButton.removeClass('not-allowed').on('click', showAllButtonOnClick);
                                }
                            }
                        });
                    }

                    scope.$watch(lAttrs.mpInputAutocomplete, function(suggestions) {
                        if (suggestions) {
                            updateSuggestions(suggestions);
                            // FIX. When the model has a value before suggestions were loaded the description input does not display as intended
                            if (ngModelCtrl.$modelValue) {
                                var viewValue = toUser(ngModelCtrl.$modelValue);
                                ngModelCtrl.$setViewValue(viewValue);
                                ngModelCtrl.$render();
                            }
                            // FIX END
                        }
                    }, true);
                }
            };
        }]);

/*global angular, _ */
/*DEPRECATED*/
/**
 * @doc-component directive
 * @name gaiafrontend.directive.mpInputCalendarthe week.
 * @description
 * Use mpTimeDatepicker instead
 */
angular.module('mpInputCalendar', [])
    .directive('mpInputCalendar', ['$parse', '$q', '$filter', '$locale', 'Language', 'Loader', 'HttpSrv', 'UserSrv',
        function($parse, $q, $filter, $locale, Language, Loader, HttpSrv, UserSrv) {
            return {
                replace: true,
                templateUrl: 'gaiafrontend/html/inputCalendar.html',
                link: function(scope, elem, attrs) {
                    var calendarId = attrs.mpInputCalendarId,
                        calendarModel = attrs.mpInputCalendarModel,
                        calendarInputs = attrs.mpInputCalendarInputs,
                        calendarFormat,
                        calendarAccesskey = attrs.mpInputCalendarAccesskey,
                        calendarClass = attrs.mpInputCalendarClass,
                        calendarDisabled = attrs.mpInputCalendarDisabled,
                        calendarEnableDays = attrs.mpInputCalendarEnableDays,
                        inputsQty,
                        templateBase = 'gaiafrontend/html/inputCalendar{inputsQty}.html',
                        templateUrl,
                        templatePromise,
                        lang = Language.get().languageId,
                        localeFile = 'i18n/datepicker-' + lang + '.js',
                        localePromise,
                        pluginFile = 'jquery.inputmask.js',
                        pluginPromise;

                    inputsQty = parseInt(calendarInputs, 10) === 1 ? 1 : 3;
                    templateUrl = templateBase.replace('{inputsQty}', inputsQty);
                    templatePromise = HttpSrv.get(templateUrl);
                    localePromise = Loader.load(localeFile);
                    pluginPromise = Loader.load(pluginFile);

                    scope.userInfo = UserSrv.info;
                    // if (_.isEmpty(scope.userInfo)) {
                    //     UserSrv.getInfo();
                    // }

                    function initCalendar(data) {
                        var templateContent = data[0],
                            dayRegExp = /d/g,
                            // dayRegExp = /d/gi,
                            monthRegExp = /M/g,
                            // monthRegExp = /M/gi,
                            yearRegExp = /y/g,
                            // yearRegExp = /y/gi,
                            elemLabels,
                            elemInputs;

                        elem.append(templateContent);
                        elemLabels = elem.find('label');
                        elemInputs = elem.find('.date');

                        function getMask(format) {
                            var formattedDateSample = $filter('date')(new Date(), format);
                            return formattedDateSample.replace(/[a-z]/gi, 'a').replace(/[0-9]/gi, '9');
                        }

                        function addAccesskey() {
                            elemInputs.attr('accesskey', calendarAccesskey);
                        }

                        function addClasses() {
                            elemInputs.addClass(calendarClass);
                        }

                        function getMatches(regexp) {
                            return calendarFormat.match(regexp) || [];
                        }

                        function getFormat(regexp) {
                            return getMatches(regexp).join('');
                        }

                        function getLength(regexp) {
                            return getMatches(regexp).length;
                        }

                        function getPosition(regexp) {
                            return calendarFormat.search(regexp);
                        }

                        function getInput(regexp) {
                            return angular.element(_.find(elemInputs, function(input) {
                                return angular.element(input).is('[id$=' + getFormat(regexp) + ']');
                            }));
                        }

                        function getInputValue(regexp) {
                            var inputValue;

                            if (inputsQty > 1) {
                                inputValue = getInput(regexp).val();
                            } else {
                                inputValue = elemInputs.val().substr(getPosition(regexp), getLength(regexp));
                            }

                            return inputValue;
                        }

                        function getDay() {
                            return getInputValue(dayRegExp);
                        }

                        function getMonth() {
                            return (+getInputValue(monthRegExp) - 1).toString();
                        }

                        function getCentury() {
                            return (new Date()).getFullYear().toString().substr(0, 2);
                        }

                        function getYear() {
                            var yearLength = getLength(yearRegExp),
                                inputYear = getInputValue(yearRegExp);

                            return yearLength === 2 && inputYear ? getCentury() + inputYear : inputYear;
                        }

                        function updateModel(day, month, year) {
                            var date = new Date(0);

                            function setDayMonthYear(day, month, year) {
                                date.setFullYear(parseInt(year, 10));
                                date.setMonth(parseInt(month, 10));
                                date.setDate(parseInt(day, 10));
                            }

                            setDayMonthYear(day, month, year);

                            function convertToUTC(date) {
                                var MS_IN_ONE_MINUTE = 60000;
                                return date - (date.getTimezoneOffset() * MS_IN_ONE_MINUTE);
                            }

                            $parse(calendarModel).assign(scope, convertToUTC(date));
                        }

                        function updateView(data) {
                            var formattedDate = $filter('date')(data, calendarFormat),
                                formattedDay = $filter('date')(data, getFormat(dayRegExp)),
                                formattedMonth = $filter('date')(data, getFormat(monthRegExp)),
                                formattedYear = $filter('date')(data, getFormat(yearRegExp));

                            if (inputsQty > 1) {
                                getInput(dayRegExp).inputmask('remove').val(formattedDay).inputmask(getMask(getFormat(dayRegExp)));
                                getInput(monthRegExp).inputmask('remove').val(formattedMonth).inputmask(getMask(getFormat(monthRegExp)));
                                getInput(yearRegExp).inputmask('remove').val(formattedYear).inputmask(getMask(getFormat(yearRegExp)));
                            } else {
                                elemInputs.inputmask('remove').val(formattedDate).inputmask(getMask(calendarFormat));
                            }
                        }

                        function prepareThreeInputs() {
                            var unsortedDayMonthYear = [],
                                sortedDayMonthYear;

                            unsortedDayMonthYear.push({
                                position: getPosition(dayRegExp),
                                format: getFormat(dayRegExp),
                                length: getLength(dayRegExp)
                            });
                            unsortedDayMonthYear.push({
                                position: getPosition(monthRegExp),
                                format: getFormat(monthRegExp),
                                length: getLength(monthRegExp)
                            });
                            unsortedDayMonthYear.push({
                                position: getPosition(yearRegExp),
                                format: getFormat(yearRegExp),
                                length: getLength(yearRegExp)
                            });

                            sortedDayMonthYear = _.sortBy(unsortedDayMonthYear, 'position');

                            _.each(sortedDayMonthYear, function(dayMonthYear, i) {
                                var id = calendarId + '-' + dayMonthYear.format,
                                    mask = getMask(dayMonthYear.format);

                                elemLabels.eq(i).attr('for', id);
                                elemInputs.eq(i).attr('id', id);
                                elemInputs.eq(i).attr('name', id);
                                elemInputs.eq(i).inputmask(mask);
                            });
                        }

                        function prepareSinlgeInput() {
                            elemLabels.attr('for', calendarId + '-date');
                            elemInputs.attr('id', calendarId + '-date');
                            elemInputs.attr('name', calendarId + '-date');
                            elemInputs.inputmask(getMask(calendarFormat));
                        }

                        function angularDateFormatToDatepickerDateFormat(format) {
                            if (!angular.isString(format)) {
                                return format;
                            }

                            /* REMOVE UNSUPPORTED ANGULARJS FORMATS */
                            format = format.replace(/HH/g, '').replace(/hh/g, '').replace(/mm/g, '').replace(/ss/g, '').replace(/.sss/g, '').replace(/,sss/g, '');

                            /* ANGULARJS- DATEPICKER- DESCRIPTION
                             * MM       - mm        - month of year (two digit)
                             * yy       - y         - year (two digit)
                             * yyyy     - yy        - year (four digit)
                             */
                            format = format.replace(/MM/g, 'mm').replace(/yy/g, 'y');

                            return format;
                        }

                        function manageEnableDays() {
                            // Only c
                            var element = angular.element('#ui-datepicker-div');

                            if (calendarEnableDays) {
                                element.removeClass('enable-days');
                            } else {
                                element.addClass('enable-days');
                            }
                        }

                        function addIdsAndBehaviour() {
                            if (inputsQty > 1) {
                                prepareThreeInputs();
                            } else {
                                prepareSinlgeInput();
                            }

                            elemInputs.datepicker({
                                showOn: 'button',
                                buttonImageOnly: true,
                                buttonImage: 'gaiafrontend/img/ico-calendar-on.png',
                                dateFormat: angularDateFormatToDatepickerDateFormat(calendarFormat),
                                beforeShow: function() {
                                    manageEnableDays();
                                },
                                onSelect: function(dataText, dataInstance) {
                                    scope.$apply(function() {
                                        updateModel(dataInstance.currentDay, dataInstance.currentMonth, dataInstance.currentYear);
                                    });
                                }
                            });

                            // <IE9 FIX since :last-child selector is not supported
                            elem.find('.ui-datepicker-trigger:last-child').show();
                        }

                        function manageDisable(disabled) {
                            if (disabled) {
                                elemInputs.datepicker('option', 'disabled', true);
                                elemInputs.attr('disabled', 'disabled');
                                elem.find('.ui-datepicker-trigger').addClass('disabled');
                            } else {
                                elemInputs.datepicker('option', 'disabled', false);
                                elemInputs.removeAttr('disabled');
                                elem.find('.ui-datepicker-trigger').removeClass('disabled');
                            }
                        }

                        function prepareDOM() {
                            if (calendarAccesskey) {
                                addAccesskey();
                            }

                            if (calendarClass) {
                                addClasses();
                            }

                            if (calendarId) {
                                addIdsAndBehaviour();
                            }
                        }

                        // This method modifies the input AngularJS date format so we the the inputmask can be fixed (no dynamic mask supported yet)
                        function standarizeFormat(angularFormat) {
                            if (!angular.isString(angularFormat)) {
                                return angularFormat;
                            }

                            // * EEEE     - day name long -> dd
                            // * EEE      - day name short -> dd
                            // * dd       - day of month (two digit) -> dd
                            // * d        - day of month (no leading zero) -> dd
                            angularFormat = angularFormat.replace(/D/g, 'd');
                            angularFormat = angularFormat.replace(/EEEE/g, 'EEE').replace(/EEE/g, 'dd').replace(/dd/g, 'd').replace(/d/g, 'dd');
                            // * MMMM     - month name long -> MM
                            // * MMM      - month name short -> MM
                            // * MM       - month of year (two digit) -> MM
                            // * M        - month of year (no leading zero) -> MM
                            angularFormat = angularFormat.replace(/m/g, 'M');
                            angularFormat = angularFormat.replace(/MMMM/g, 'MMM').replace(/MMM/g, 'MM').replace(/MM/g, 'M').replace(/M/g, 'MM');
                            // * yy       - year (two digit) -> yy
                            // * yyyy     - year (four digit) -> yyyy
                            // * y        - year (one digit) -> y
                            angularFormat = angularFormat.replace(/Y/g, 'y');

                            // * HH       - hour in day, padded (00-23) -> HH
                            // * H        - hour in day (0-23) -> HH
                            // * hh       - hour in am/pm, padded (01-12) -> hh
                            // * h        - hour in am/pm, (1-12) -> hh
                            // * mm       - minute in hour, padded (00-59) -> mm
                            // * m        - minute in hour (0-59) -> mm
                            // * ss       - second in minute, padded (00-59) -> ss
                            // * s        - second in minute (0-59) -> ss
                            // * (.|,)sss - millisecond in second, padded (000-999) -> .sss|,sss

                            // * a        - am/pm marker -> a

                            // * Z        - 4 digit (+sign) representation of the timezone offset (-1200-+1200) -> Z

                            return angularFormat;
                        }

                        calendarFormat = standarizeFormat(attrs.mpInputCalendarFormat);

                        if (!calendarFormat) {
                            calendarFormat = standarizeFormat($locale.DATETIME_FORMATS.shortDate);
                            scope.$watch('userInfo.applicationData.formattingAndMask.shortDate', function(userInfoDateFormat) {
                                calendarFormat = standarizeFormat(userInfoDateFormat || calendarFormat);
                                prepareDOM();
                            });
                        } else {
                            prepareDOM();
                        }

                        if (calendarModel) {
                            elemInputs.on('change', function() { //REVIEW: fixed the updateModel weird event action
                                scope.$apply(function() {
                                    updateModel(getDay(), getMonth(), getYear());
                                });
                            });
                            scope.$watch(calendarModel, updateView);
                        }

                        if (calendarDisabled) {
                            scope.$watch(calendarDisabled, manageDisable);
                        }

                        if (calendarEnableDays) {
                            calendarEnableDays = !!$parse(attrs.mpInputCalendarEnableDays)(scope);
                        }
                    }

                    $q.all([templatePromise, localePromise, pluginPromise])
                        .then(initCalendar);
                }
            };
        }]);

/*TODO: REVIEW*/
/**
 * @doc-component directive
 * @name gaiafrontend.directive.mpInputCurrency
 * @param {string} mp-input-currency Not used.
 * @param {string} mp-input-currency-iso ISO currency code.
 * @param {integer} mp-input-currency-decimals Define the number of decimal places.
 * @param {string} mp-input-currency-group-sep Define the thousands separator.
 * @param {string} mp-input-currency-decimal-sep Define the decimals separator.
 * @description
 * This input will be used for currency data entry. Restrict data entry to numeric and decimal separator only.
 * When you lose focus apply automatic formatting element data currency on adding the thousands separator and filling decimal places with zeros.
 * This component is DEPRECATED. Please use mpNumber instead.
 */
/*global angular */
angular.module('mpInputCurrency', [])
    .directive('mpInputCurrency', ['$locale', 'UserSrv',
        function($locale, UserSrv) {
            return {
                require: '?ngModel',
                link: function(scope, elm, attrs, ctrl) {
                    var decimalSep = attrs.mpInputCurrencyDecimalSep,
                        groupSep = attrs.mpInputCurrencyGroupSep,
                        numDecimals = attrs.mpInputCurrencyDecimals,
                        currency = attrs.mpInputCurrencyIso,
                        removeDecimalSepRegExp,
                        removeInvalidCharsRegExp;

                    function formatNumber(numberString) {
                        numberString = numberString || '';

                        var num = numberString.split(decimalSep)[0],
                            decimal = numberString.split(decimalSep)[1],
                            chain = '',
                            aux,
                            count = 1,
                            m,
                            formattedNumber;

                        if (num < 0) {
                            aux = 1;
                        } else {
                            aux = 0;
                        }

                        num = num.toString();

                        for (m = num.length - 1; m >= 0; m = m - 1) {

                            chain = num.charAt(m) + chain;

                            if (count % 3 === 0 && m > aux) {
                                chain = groupSep + chain;
                            }


                            if (count === 3) {
                                count = 1;
                            } else {
                                count = count + 1;
                            }

                        }

                        // chain = chain.replace(/.,/, ",");

                        if (decimal !== undefined) {
                            formattedNumber = chain.concat(decimalSep + decimal);
                        } else {
                            formattedNumber = chain;
                        }

                        return formattedNumber;
                    }

                    function removeDecimalSep(numberString) {
                        return numberString.replace(removeDecimalSepRegExp, '');
                    }

                    function removeInvalidChars(numberString) {
                        return numberString.replace(removeInvalidCharsRegExp, '');
                    }

                    function formatDecimalPart(numberString) {
                        var position = numberString.indexOf(decimalSep),
                            part1,
                            part2;

                        if (position !== -1) {
                            numberString = removeDecimalSep(numberString);
                            part1 = numberString.slice(0, position);
                            part2 = numberString.slice(position, numberString.length);

                            numberString = part1.concat(decimalSep);
                            numberString = numberString.concat(part2);
                        }

                        return numberString;
                    }

                    function addZerosToDecimalPart(numberString) {
                        if (numberString !== '') {
                            var position = numberString.indexOf(decimalSep),
                                integerPart,
                                decimalPart,
                                i,
                                len;

                            if (position === -1) {
                                position = numberString.length;
                            }

                            numberString = removeDecimalSep(numberString);
                            integerPart = numberString.slice(0, position);
                            decimalPart = numberString.slice(position, numberString.length);

                            if (decimalPart.length < numDecimals) {
                                for (i = 0, len = numDecimals - decimalPart.length; i < len; i = i + 1) {
                                    decimalPart = decimalPart + '0';
                                }
                            }

                            numberString = integerPart.concat(decimalSep);
                            numberString = numberString.concat(decimalPart);

                            return numberString;
                        }

                        return numberString;
                    }

                    function fromModelToView(numberString) {
                        if (numberString) {
                            return numberString;
                        }
                    }

                    function fromViewToModel(numberString) {
                        numberString = removeInvalidChars(numberString);
                        numberString = formatDecimalPart(numberString);

                        ctrl.$viewValue = fromModelToView(numberString); // we need that fromModelToView to be executed even if the model doesn`t change
                        ctrl.$render();

                        return numberString;
                    }

                    function updateRegExps() {
                        removeDecimalSepRegExp = new RegExp('[' + decimalSep + ']', 'gi');
                        removeInvalidCharsRegExp = new RegExp('[^0-9' + decimalSep + ']', 'gi');
                    }

                    scope.userInfo = UserSrv.info;
                    updateRegExps();

                    if (!decimalSep) {
                        scope.$watch('userInfo.applicationData.formattingAndMask.decimalSeparator', function (userInfoDecimalSep) {
                            decimalSep = userInfoDecimalSep || $locale.NUMBER_FORMATS.DECIMAL_SEP;
                            updateRegExps();
                        });
                    }

                    if (!groupSep) {
                        scope.$watch('userInfo.applicationData.formattingAndMask.groupSeparator', function (userInfoGroupSep) {
                            groupSep = userInfoGroupSep || $locale.NUMBER_FORMATS.GROUP_SEP;
                        });
                    }

                    if (!numDecimals) {
                        scope.$watch('userInfo.applicationData.formattingAndMask.decimalLength', function (userInfoDecimalLength) {
                            numDecimals = userInfoDecimalLength || 2;
                        });
                    }

                    if (!currency) {
                        scope.$watch('userInfo.applicationData.formattingAndMask.isoCurrency', function (userInfoIsoCurrency) {
                            currency = userInfoIsoCurrency || 'EUR';
                            scope.currency = currency;
                        });
                    }
                    scope.currency = currency;

                    ctrl.$parsers.push(fromViewToModel);
                    ctrl.$formatters.push(fromModelToView);


                    elm.on('focus', function() {
                        elm.val(ctrl.$modelValue);
                        this.selectionStart = this.selectionEnd = this.value.length;
                    });

                    elm.on('focusout', function() {
                        elm.val(addZerosToDecimalPart(formatNumber(ctrl.$modelValue)));
                    });
                }
            };
        }]);

/*global angular */
/*DEPRECATED*/
angular.module('mpInputFile', [])
    .directive('mpInputFile', function() {
        return {
            scope: {
                mpInputFile: '@'
            },
            templateUrl: 'gaiafrontend/html/inputFile.html'
        };
    });

/*TODO: REVIEW*/
/**
 * @doc-component directive
 * @name gaiafrontend.directive.mpInputMask
 * @description
 * This directive will be used for add a mask to an input.
 * Default masking definitions
 *   9 : numeric
 *   a : alfabetic
 *   * : alfanumeric
 * @example
   <doc:example module="mpInputMask">
    <doc:source>
    form(ng-model="formInputMask")
    input#inputMask(type="text", mp-input-mask="aaaa-9999", name="inputMask")
    </doc:source>
   </doc:example>
 */
/*global angular */
angular.module('mpInputMask', [])
    .directive('mpInputMask', ['Loader', '$timeout',
        function(Loader, timeout) {
            return {
                require: 'ngModel',
                link: function(scope, elm, attrs, ctrl) {
                    var loadPlugin = Loader.load('jquery.inputmask.js'),
                        mask = attrs.mpInputMask;

                    function initMask() {
                        if(elm.inputmask) {
                          elm.inputmask(mask);
                        }
                        else {
                          timeout(function() { elm.inputmask(mask); }, 500);
                        }
                    }

                    loadPlugin.then(initMask);

                    elm.on('keyup', function() {
                        if(elm.val() === "") {
                            ctrl.$setViewValue("");
                            elm.change();
                        }
                    });

                }
            };
        }]);

/*global angular */
/*DEPRECATED*/
/**
 * @doc-component directive
 * @name gaiafrontend.directive.mpInputNumber
 * @description
 * DEPRECATED
 * Use mpNumber instead
 */
angular.module('mpInputNumber', []).directive('mpInputNumber', ['$locale', 'UserSrv',
    function($locale, UserSrv) {
        return {
            require: '?ngModel',
            link: function(scope, elm, attrs, ctrl) {
                var decimalSep = attrs.mpInputNumberDecimalSep,
                    groupSep = attrs.mpInputNumberGroupSep,
                    removeDecimalSepRegExp,
                    removeInvalidCharsRegExp;

                function formatNumber(numberString) {
                    numberString = numberString || '';

                    var num = numberString.split(decimalSep)[0],
                        decimal = numberString.split(decimalSep)[1],
                        chain = '',
                        aux,
                        count = 1,
                        m,
                        formattedNumber;

                    if (num < 0) {
                        aux = 1;
                    } else {
                        aux = 0;
                    }

                    num = num.toString();

                    for (m = num.length - 1; m >= 0; m = m - 1) {

                        chain = num.charAt(m) + chain;

                        if (count % 3 === 0 && m > aux) {
                            chain = groupSep + chain;
                        }


                        if (count === 3) {
                            count = 1;
                        } else {
                            count = count + 1;
                        }

                    }

                    // chain = chain.replace(/.,/, ",");

                    if (decimal !== undefined) {
                        formattedNumber = chain.concat(decimalSep + decimal);
                    } else {
                        formattedNumber = chain;
                    }

                    return formattedNumber;
                }

                function removeDecimalSep(numberString) {
                    return numberString.replace(removeDecimalSepRegExp, '');
                }

                function removeInvalidChars(numberString) {
                    return numberString.replace(removeInvalidCharsRegExp, '');
                }

                function formatDecimalPart(numberString) {
                    var position = numberString.indexOf(decimalSep),
                        part1,
                        part2;

                    if (position !== -1) {
                        numberString = removeDecimalSep(numberString);
                        part1 = numberString.slice(0, position);
                        part2 = numberString.slice(position, numberString.length);

                        numberString = part1.concat(decimalSep);
                        numberString = numberString.concat(part2);
                    }

                    return numberString;
                }

                function fromModelToView(numberString) {
                    if (numberString) {
                        return numberString;
                    }
                }

                function fromViewToModel(numberString) {
                    numberString = removeInvalidChars(numberString);
                    numberString = formatDecimalPart(numberString);

                    ctrl.$viewValue = fromModelToView(numberString); // we need that fromModelToView to be executed even if the model doesn`t change
                    ctrl.$render();

                    return numberString;
                }

                function updateRegExps() {
                    removeDecimalSepRegExp = new RegExp('[' + decimalSep + ']', 'gi');
                    removeInvalidCharsRegExp = new RegExp('[^0-9' + decimalSep + ']', 'gi');
                }

                scope.userInfo = UserSrv.info;
                updateRegExps();

                if (!decimalSep) {
                    scope.$watch('userInfo.applicationData.formattingAndMask.decimalSeparator', function (userInfoDecimalSep) {
                        decimalSep = userInfoDecimalSep || $locale.NUMBER_FORMATS.DECIMAL_SEP;
                        updateRegExps();
                    });
                }

                if (!groupSep) {
                    scope.$watch('userInfo.applicationData.formattingAndMask.groupSeparator', function (userInfoGroupSep) {
                        groupSep = userInfoGroupSep || $locale.NUMBER_FORMATS.GROUP_SEP;
                    });
                }

                ctrl.$parsers.push(fromViewToModel);
                ctrl.$formatters.push(fromModelToView);


                elm.on('focus', function() {
                    elm.val(ctrl.$modelValue);
                });

                elm.on('focusout', function() {
                    elm.val(formatNumber(ctrl.$modelValue));
                });
            }
        };
    }]);

/*TODO: REVIEW*/
/*global angular */
angular.module('mpLoading', [])
    /**
     * @doc-component service
     * @name gaiafrontend.service.LoadingSrv
     * @description
     * This service manages the loading view.
     */
    .factory('LoadingSrv', function() {
        var loading = {
            show: false,
            message: ''
        };

         /**
         * @doc-component method
         * @methodOf gaiafrontend.service.LoadingSrv
         * @name gaiafrontend.service.LoadingSrv#get
         * @return {object} loading object.
         * @description
         * This method gets the loading object.
         */
        function get() {
            return loading;
        }

         /**
         * @doc-component method
         * @methodOf gaiafrontend.service.LoadingSrv
         * @name gaiafrontend.service.LoadingSrv#set
         * @param {string} Message to display.
         * @description
         * Sets a message and makes the loading `div` visible.
         */
        function set(message) {
            loading.show = true;
            loading.message = message;
        }

         /**
         * @doc-component method
         * @methodOf gaiafrontend.service.LoadingSrv
         * @name gaiafrontend.service.LoadingSrv#hide
         * @description
         * Hides the loading `div`..
         */
        function hide() {
            loading.show = false;
        }

        return {
            get: get,
            set: set,
            hide: hide
        };
    })
    /**
     * @doc-component controller
     * @name gaiafrontend.controller.LoadingCtrl
     * @description
     * The loading controller depends on LoadingSrv and it is used by mpLoading to manage the loading layer.
     */
    .controller('LoadingCtrl', ['$scope', 'LoadingSrv', function($scope, LoadingSrv) {
        $scope.loading = LoadingSrv.get();
    }])
    /**
     * @doc-component directive
     * @name gaiafrontend.directive.mpLoading
     * @param {string} mpLoading Image source path to display while loading.
     * @param {string} mp-message-waiting-alt Alternative text for the image displayed.
     * @description
     * Standard loading layer. Its visibility depends on LoadingSrv so take a look at the service.
     * @example
       <doc:example module="mpLoading">
        <doc:source>
        div(mp-loading="gaiafrontend/img/spinner.gif", mp-loading-alt="waiting...")
        </doc:source>
       </doc:example>
     */
    .directive('mpLoading', function() {
        return {
            replace: true,
            transclude: true,
            controller: 'LoadingCtrl',
            scope: {
                mpLoading: '@',
                mpLoadingAlt: '@'
            },
            templateUrl: 'gaiafrontend/html/loading.html'
        };
    });

/*global angular */
/*DEPRECATED*/
/**
 * @doc-component directive
 * @name gaiafrontend.directive..mpMessageAdvanced1
 * @param {string} mpMessageAdvanced1 receives a text with the message content.
 * @description
 * DEPRECATED
 * Use Bootstrap's progress bar instead
 */
angular.module('mpMessageAdvanced1', [])
    .directive('mpMessageAdvanced1', function() {
        return {
            scope: {
                mpMessageAdvanced1: '@'
            },
            templateUrl: 'gaiafrontend/html/messageAdvanced1.html',
            link: function(scope, elm) {
                var progressbar = elm.find('.progressbar'),
                    progressLabel = elm.find('.progress-label', progressbar);
                progressbar.progressbar({
                    value: false,
                    change: function() {
                        progressLabel.text(progressbar.progressbar('value') + '%');
                    },
                    complete: function() {
                        progressLabel.text('Complete!');
                    }
                });
            }
        };
    });

/*global angular */
/*DEPRECATED*/
/**
 * @doc-component directive
 * @name gaiafrontend.directive.mpMessageAdvanced2
 * @param {string} mpMessageAdvanced2 receives a text with the message content.
 * @param {string=} mp-message-advanced2-complete we set the text that will appear once charging is complete.
 * @description
 * DEPRECATED
 * Use Bootstrap's progress bar instead
 */
angular.module('mpMessageAdvanced2', [])
    .directive('mpMessageAdvanced2', function() {
        return {
            replace: true,
            scope: {
                mpMessageAdvanced2: '@'
            },
            templateUrl: 'gaiafrontend/html/messageAdvanced2.html',
            link: function(scope, elm, attrs) {
                var advenceprogressbar = elm.find('.advanceProgressbar'),
                    progressLabel = elm.find('.progress-label', advenceprogressbar);

                advenceprogressbar.progressbar({
                    value: false,
                    change: function() {
                        progressLabel.text(advenceprogressbar.progressbar('value') + '%');
                    },
                    complete: function() {
                        progressLabel.text(attrs.mpMessageAdvanced2Complete);
                    }
                });

                function progress() {
                    var val = advenceprogressbar.progressbar('value') || 0;
                    advenceprogressbar.progressbar('value', val + 1);
                    if (val < 99) {
                        setTimeout(progress, 100);
                    }
                }
                setTimeout(progress, 3000);
            }
        };
    });

/*global angular */
/*DEPRECATED*/
/**
 * @doc-component directive
 * @name gaiafrontend.directive.mpMessageWaiting
 * @param {string} mpMessageWaiting receives the path to the image / gif to display while viewing the message.
 * @param {string} mp-message-waiting-alt By attribute mp-message-waiting-alt stablish the image alt.
 * @description
 * DEPRECATED
 * Use mpLoading instead
 */
angular.module('mpMessageWaiting', [])
    .directive('mpMessageWaiting', function() {
        return {
            replace: true,
            transclude: true,
            scope: {
                mpMessageWaiting: '@',
                mpMessageWaitingAlt: '@'
            },
            templateUrl: 'gaiafrontend/html/messageWaiting.html'
        };
    });

/* global angular, ss*/
angular.module('mpMultiFileUpload', [])
    .constant('MPMULTIFILEUPLOADCONFIG', {})
    /**
     * @doc-component service
     * @name gaiafrontend.service.mpMultiFileUploadSrv
     * @description
     * This service is meant to be used to communicate with GAIA file upload API.
     *
     * This behaviour can be modified by changing the `mpMultiFileUploadConfig` constant object.
     *
     * It is recommended to change the default behaviour in the `config` method of the main AngularJS module of the application.
     *
     */
    .factory('mpMultiFileUploadSrv', ['HttpSrv', function (HttpSrv) {
        var config = {
            headers: {
                'Content-Type': 'application/json; charset=UTF-8'
            }
        };
        /**
         * @doc-component method
         * @methodOf gaiafrontend.service.mpMultiFileUploadSrv
         * @name gaiafrontend.service.mpMultiFileUploadSrv#getConfig
         * @return {object} Return the config file from server.
         * @description
         * This methods retrieves a config file from server.
         */
        function getConfig() {
                return HttpSrv.get('api/files/configuration');
            }
            /**
             * @doc-component method
             * @methodOf gaiafrontend.service.mpMultiFileUploadSrv
             * @name gaiafrontend.service.mpMultiFileUploadSrv#getFiles
             * @param {string} url Url server.
             * @return {promise} An $http promise.
             * @description
             * This methods retrieves all files from the server.
             */
        function getFiles(url) {
                return HttpSrv.get(url);
            }
            /**
             * @doc-component method
             * @methodOf gaiafrontend.service.mpMultiFileUploadSrv
             * @name gaiafrontend.service.mpMultiFileUploadSrv#getFile
             * @param {string} url Url server.
             * @param {string} filename Filename.
             * @return {promise} An $http promise.
             * @description
             * This methods retrieves one file from the server.
             */
        function getFile(url, filename) {
                return HttpSrv.get(url + '/:filename', {
                    filename: filename
                }, config);
            }
            /**
             * @doc-component method
             * @methodOf gaiafrontend.service.mpMultiFileUploadSrv
             * @name gaiafrontend.service.mpMultiFileUploadSrv#removeFile
             * @param {string} url Url server.
             * @param {string} filename Filename.
             * @return {promise} An $http promise.
             * @description
             * This methods remove one file from the server.
             */
        function removeFile(url, filename) {
            // AngularJS strips the Content-Type header if data property is undefined
            config.data = {};
            return HttpSrv['delete'](url + '/:filename', {
                filename: filename
            }, config);
        }

        return {
            getConfig: getConfig,
            getFiles: getFiles,
            getFile: getFile,
            removeFile: removeFile
        }
        }
    ])

.controller('MpMultiFileUploadCtrl', ['$scope', '$modal', '$filter', 'mpMultiFileUploadSrv',
        function($scope, $modal, $filter, mpMultiFileUploadSrv) {

            function generateTemplate (type, size, collection, filename) {
                var template;

                switch (type) {
                  case 'preview':
                    template = '<div class="modal-container modal-container-file">' +
                        '<div class="modal-body">' +
                        '<iframe ng-show="!extensionError && !sizeError" ng-src="api/files/' + encodeURI(collection) + '/' + encodeURI(filename) + '"></iframe>' +
                        '</div>' +
                        '<div class="modal-footer">' +
                        '<button type="button" class="btn btn-navigation" ng-click="accept()">' + $filter('translate')('mpMultiFileUpload.accept') + '</button>' +
                        '</div>' +
                        '</div>';
                    break;
                  case 'confirm':
                    template = '<div class="modal-container modal-container-file">' +
                        '<div class="modal-body">' +
                        '<span class="question">' + $filter('translate')('mpMultiFileUpload.question') + '</span>' +
                        '</div>' +
                        '<div class="modal-footer">' +
                        '<button type="button" class="btn btn-navigation" ng-click="accept()">' + $filter('translate')('mpMultiFileUpload.accept') + '</button>' +
                        '<button type="button" class="btn btn-navigation" ng-click="cancel()">' + $filter('translate')('mpMultiFileUpload.cancel') + '</button>' +
                        '</div>' +
                        '</div>';
                    break;
                }
                return template;
            }

            this.openModal = function (type, size, collection, filename) {
                return $modal.open({
                    template: generateTemplate(type, size, collection, filename),
                    size: size,
                    windowClass: 'modal-content-file',
                    scope: $scope,
                    controller: ['$scope', '$modalInstance', '$rootScope',
                        function($scope, $modalInstance, $rootScope) {
                            $scope.cancel = function() {
                                $modalInstance.dismiss();
                            };
                            $scope.accept = function () {
                                $modalInstance.close('yes');
                            };
                            var unRegisterModalStateEvent = $rootScope.$on('$stateChangeSuccess', function (event, toState, toParams, fromState, fromParams) {
                                $modalInstance.dismiss();
                                });

                            $scope.$on('$destroy', function() {
                                unRegisterModalStateEvent();
                            });
                        }
                    ]
                }).result;
            }
            this.removeFile = function(url, filename, $index) {
                mpMultiFileUploadSrv.removeFile(url, filename);
                $scope.serverInfo.files.splice($index, 1);
            }
            this.removeAllFiles = function(url, filename) {
                mpMultiFileUploadSrv.removeFile(url, filename);
            }
        }
    ])
    /**
     * @doc-component directive
     * @name gaiafrontend.directive.mpMultiFileUpload
     * @example
       <doc:example module="mpMultiFileUpload">
        <doc:source>
        label The example is currently unavailable. If you want to try this component out, you can visit:
        a(href='http://vles044273-008:8081/issuestracker/login.html#/') Issuestracker
        h2 Log in
        h4 User: UGAIA1
        h4 Password: UGAIA1
        h4 Navigate to mpMultiFileUpload submenu.
        </doc:source>
       </doc:example>
     */
    .directive('mpMultiFileUpload', ['MPMULTIFILEUPLOADCONFIG', 'Loader', '$timeout', 'mpMultiFileUploadSrv', '$q', 'Utils', '$filter', 'CookieSrv',
        function (MPMULTIFILEUPLOADCONFIG, Loader, $timeout, mpMultiFileUploadSrv, $q, Utils, $filter, CookieSrv) {
            return {
                templateUrl: 'gaiafrontend/html/multiFileUpload.html',
                scope: {
                    config: '=mpMultiFileUploadConfig',
                    serverInfo: '=?mpMultiFileUploadInfo',
                    mpMultiFileUpload: '@mpMultiFileUpload'
                },
                require: '^mpMultiFileUpload',
                controller: 'MpMultiFileUploadCtrl',
                link: function(scope, element, attrs, MpMultiFileUploadCtrl) {
                    var accordionContainer = element.find('.mp-multi-file-upload-accordion'),
                        filesContainer = element.find('.files'),
                        filesOptions = element.find('.files-options'),
                        uploadIcon = element.find('.glyphicon-cloud-upload'),
                        spinnerIcon = element.find('.spinner-load'),
                        spinnerIconIE8 = element.find('.glyphicon-refresh'),
                        errorContainer = element.find('.error-container'),
                        removeAllButton = element.find('.btn-delete-upload-items'),
                        collection = attrs.mpMultiFileUpload,
                        mpMultiFileUploadInfo = attrs.mpMultiFileUploadInfo,
                        configuration,
                        serverConfigForErrors,
                        customHeadersConfig,
                        config = {
                            button: 'upload-btn-' + collection,
                            name: 'file',
                            multipart: true,
                            url: 'api/files/' + collection,
                            encodeCustomHeaders: false,
                            startXHR: function() {
                                animateSpinner();
                            },
                            onComplete: function() {
                                hideErrors();
                                animateSpinner();
                                getFiles();
                            },
                            startNonXHR: function() {
                                animateSpinner();
                                getFiles();
                            },
                            onError: function(filename, errorType, status) {
                                manageErrors(status);
                                animateSpinner();
                                closeAccordion()
                                showErrors();
                            },
                            onSizeError: function() {
                                manageErrors('size');
                                closeAccordion()
                                showErrors();
                            }
                        };

                    function animateSpinner() {
                        if (!Utils.platform.isIE8()) {
                            uploadIcon.toggleClass('display');
                            spinnerIcon.toggleClass('display');
                        } else {
                            uploadIcon.toggleClass('display');
                            spinnerIconIE8.toggleClass('displayIE8');
                        }
                    }

                    function openAccordion() {
                        filesContainer.toggleClass('closed');
                        filesOptions.toggleClass('closed');
                    }

                    function closeAccordion() {
                        filesContainer.addClass('closed');
                        filesOptions.addClass('closed');
                    }

                    function getFiles() {
                        mpMultiFileUploadSrv.getFiles(config.url)
                            .then(function(res) {
                                scope.serverInfo.files = res;
                                $timeout(function() {
                                    var removeButton = element.find('.glyphicon-remove-circle'),
                                        openButton = element.find('.glyphicon-eye-open');
                                    desregisterListeners(removeButton, openButton);
                                    registerListeners(removeButton, openButton);
                                })
                            });
                    }

                    function removeFile(event) {
                        var targetScope = angular.element(event.target).scope();
                        MpMultiFileUploadCtrl.removeFile(config.url, encodeURI(targetScope.file.name), targetScope.$index);
                    }

                    function removeAllFiles() {
                        MpMultiFileUploadCtrl.openModal('confirm', 'sm')
                            .then(function (data) {
                                if(data === 'yes') {
                                    angular.forEach(scope.serverInfo.files, function(file) {
                                        MpMultiFileUploadCtrl.removeAllFiles(config.url, file.name);
                                    });
                                    scope.serverInfo.files = [];
                                }
                            });
                    }

                    function openFile(event) {
                        var targetScope = angular.element(event.target).scope();
                        MpMultiFileUploadCtrl.openModal('preview', 'lg', collection, targetScope.file.name);
                    }

                    function showErrors() {
                        errorContainer.removeClass('display');
                        accordionContainer.removeClass('col-sm-10');
                        accordionContainer.addClass('col-sm-8');
                    }


                    function hideErrors() {
                        errorContainer.addClass('display');
                        accordionContainer.addClass('col-sm-10');
                        accordionContainer.removeClass('col-sm-8');
                    }

                    function manageErrors(status) {
                        var typeError;

                        switch (status) {
                          case 412:
                          case 'extension':
                            typeError = 'extension';
                            break;
                          case 413:
                          case 'size':
                            typeError = 'size';
                            break;
                          default:
                            typeError = 'genericError';
                        }
                        scope.$apply(function() {
                            scope.errormsg = $filter('translate')('mpMultiFileUpload.' + typeError);
                        });
                    }

                    function unlisten(element, event, listener) {
                        element.off(event, listener);
                    }

                    function listen(element, event, listener) {
                        element.on(event, listener);
                        return function() {
                            unlisten(element, event, listener);
                        }
                    }

                    function registerListeners(removeButton, openButton) {
                        var unlistenAccordionOnClick = listen(accordionContainer, 'click', openAccordion),
                            unlistenRemoveOnClick = listen(removeButton, 'click', removeFile),
                            unlistenOpenOnClick = listen(openButton, 'click', openFile),
                            unlistenRemoveAllFilesOnClick = listen(removeAllButton, 'click', removeAllFiles);

                        element.on('$destroy', function() {
                            unlistenAccordionOnClick();
                            unlistenRemoveOnClick();
                            unlistenOpenOnClick();
                            unlistenRemoveAllFilesOnClick();
                        });
                    }

                    function desregisterListeners(removeButton, openButton) {
                        unlisten(removeButton, 'click', removeFile);
                        unlisten(openButton, 'click', openFile);
                        unlisten(accordionContainer, 'click', openAccordion);
                        unlisten(removeAllButton, 'click', removeAllFiles);
                    }

                    function generateConfig() {
                        var deferred = $q.defer(),
                            xsrfToken = CookieSrv.getCookie('XSRF-TOKEN');

                        mpMultiFileUploadSrv.getConfig()
                            .then(function (data) {

                                if(mpMultiFileUploadInfo) {
                                    scope.serverInfo = data;
                                }

                                serverConfigForErrors = {
                                    maxSize: data.maxUploadSize / 1024
                                }

                                customHeadersConfig = {
                                    customHeaders: {
                                        'x-custom-encoding':'UTF-8',
                                        'X-XSRF-TOKEN': xsrfToken
                                    }
                                }

                                configuration = angular.extend({}, MPMULTIFILEUPLOADCONFIG, scope.config, config, serverConfigForErrors, customHeadersConfig);
                                deferred.resolve(configuration);
                            });

                        return deferred.promise;
                    }

                    function createSimpleUpload(configuration) {
                        return new ss.SimpleUpload(configuration);
                    }

                    // https://www.lpology.com/code/ajaxuploader/docs.php
                    Loader.load('jquery.simpleFileupload.js')
                        .then(generateConfig)
                        .then(createSimpleUpload)
                        .then(getFiles);
                }
            }
        }
    ]);

/*global angular */
/*DEPRECATED*/
/**
 * @doc-component directive
 * @name gaiafrontend.directive.mpMultilist
 * @description
 * DEPRECATED
 * If you need this component ask for it through the UX department
 */
angular.module('mpMultilist', ['utils'])
    .directive('mpMultilist', function() {
        return {
            scope: {
                mpModel: '='
            },
            templateUrl: 'gaiafrontend/html/multilist.html',
            link: function(scope, elm, attrs) {
                var options = attrs.mpMultilist.split(',');
                scope.options = options;
            }
        };
    })
    // TODO: Review
    .directive('mpMultilistEnd', ['Loader',
        function(Loader) {
            var loadPlugin = Loader.load;

            return {
                restrict: 'A',
                link: function(scope, elm, attrs) {
                    var regexpOptions = /^.* in (.*)$/,
                        observable;

                    function refresh() {
                        elm.find('.ui-multilist').remove();
                        elm.multilist();
                    }

                    if (attrs.ngOptions) {
                        observable = regexpOptions.exec(attrs.ngOptions)[1];
                        scope.$watch(observable, function() {
                            loadPlugin('multilist.js').then(refresh);
                        });
                    }
                }
            };
        }]);

/*global angular */
/*DEPRECATED*/
/**
 * @doc-component directive
 * @name gaiafrontend.directive.mpMultiselect
 * @description
 * DEPRECATED
 * Use mpSelect instead
 */
angular.module('mpMultiselect', [])
    .directive('mpMultiselect', function() {
        return {
            scope: {
                mpModel: '='
            },
            templateUrl: 'gaiafrontend/html/multiselect.html',
            link: function(scope, elm, attrs) {
                var options = attrs.mpMultiselect.split(',');
                scope.options = options;
            }
        };
    })
    .directive('mpMultiselectEnd', ['Loader',
        function(Loader) {
            var loadPlugin = Loader.load;

            return {
                link: function(scope, elm, attrs) {
                    var regexpOptions = /^.* in (.*)$/,
                        observable;

                    function refresh() {
                        elm.siblings('button.ui-multiselect').remove();
                        elm.multiselect({
                            selectedList: 4
                        });
                    }

                    if (attrs.ngOptions) {
                        observable = regexpOptions.exec(attrs.ngOptions)[1];
                        scope.$watch(observable, function() {
                            loadPlugin('jquery.multiselect.min.js').then(refresh);
                        });
                    }
                }
            };
        }]);

/*global angular */
angular.module('mpName', [])
    .directive('mpName', ['$interpolate',
        function($interpolate) {
            return {
                priority: 9999,
                controller: ['$scope', '$attrs',
                    function($scope, $attrs) {
                        var interpolatedName = $interpolate($attrs.mpName || '')($scope);
                        if (interpolatedName) {
                            $attrs.$set('name', interpolatedName);
                        }
                    }]
            };
        }]);
/**
 * @doc-component directive
 * @name gaiafrontend.directive.mpNavbar
 * @param {expression} mp-navbar Expression to evaluate. The result of the evaluation can be an array or an object. In case of array the navigation bar will be rendered horizontally. In case of object the navigation bar will be rendered vertically.
 * @param {expression=} mp-navbar-options The result of the expression must be a smartmenus options Object. Visit [smartmenus official docs](http://www.smartmenus.org/docs/ "smartmenus docs") for info.
 * @description
 *
 * The `mpNabvar` directive allows you to display a vertical or horizontal navigation bar (depending on the result of the evaluation of mpNavbar attribute value).
 *
 * This directive uses the following javascript libraries:
 *
 * - To *dropdown* navigation bar items Bootstrap v3.1.1 dropdown jQuery plugin is asynchronously loaded.
 * - To *dropdown* nested navigation bar items SmartMenus v0.9.6 jQuery plugin is asynchronously loaded.
 * - To associate these two plugins an *ad hoc* addon is asynchronously loaded.
 *
 * The navigation bar items are objects with the following properties:
 *
 * - `class`: String expression to eval. The result of the evaluation can be a string representing space delimited class names, an array, or a map of class names to boolean values. In the case of a map, the names of the properties whose values are truthy will be added as css classes to the element. It will be assigned to the `li` as `ng-class`.
 * - `divider`: If truthy the `li` will have `.divider` class and no content.
 * - `header`: If truthy the `li` will have `.dropdown-header` class with `text` property as content.
 * - `disabled`: If truthy the `li` and the `a` will have `.disabled` class.
 * - `text`: String containing the text content of `a` if `header` property is falsy. String containing the text content of `li` if `header` property is truthy.
 * - `link`: String containing the `href` property of `a`. If falsy the `a` will not navigate (link default behaviour is prevented).
 * - `click`: Angular expression to evaluate upon click. It will be assigned to the `a` as `ng-click`.
 * - `list`: Array of navigation bar items.
 *
 * The directive operate in two different ways, depending on which of the two types the expression evaluates to:
 *
 * - If the expression evaluates to an array, each element of the array should be an *item format* object.
 * - If the expression evaluates to an object, it should be an *item format* object.
 *
 * When the expression changes, the previous navigation bar items will be replaced with the new navigation bar items.
 *
 * @example
   <doc:example module="mpNavbar">
    <doc:source>
    json =[{"text":"Google.com","link":"https://www.google.com/"},{"text":"Other search engines","list":[{"header":true,"text":"Microsoft's"},{"text":"Bing","link":"https://www.bing.com/","disabled":true},{"divider":true},{"header":true,"text":"Yahoo!'s"},{"text":"Yahoo!","link":"http://search.yahoo.com/"}]}]
    div(mp-navbar=JSON.stringify(json), mp-navbar-options="{showOnClick: true}")
    </doc:source>
   </doc:example>
 */
/*global angular, _ */
angular.module('mpNavbar', [])
    .directive('mpNavbar', ['$compile', '$parse', '$timeout', 'Loader',
        function($compile, $parse, $timeout, Loader) {
            var loadPlugin = Loader.load,
                bootstrapFile = 'bootstrap.js',
                pluginFile = 'jquery.smartmenus.tweaked.js',
                addOnFile = 'jquery.smartmenus.bootstrap.tweaked.js';

            return {
                templateUrl: 'gaiafrontend/html/navbar.html',
                replace: true,
                link: function(scope, elem, attrs) {

                    function addBehaviour() {
                        elem.bootstrappedSmartmenus($parse(attrs.mpNavbarOptions)(scope) || {});
                    }

                    function createNavbarItem(item) {
                        var navbarItem = angular.element('<li>'),
                            link;

                        if (item['class']) {
                            navbarItem.attr('ng-class', item['class']);
                        }

                        if (item.divider) {
                            navbarItem.addClass('divider');
                            return navbarItem;
                        }

                        if (item.header) {
                            navbarItem.addClass('dropdown-header');
                            navbarItem.text(item.text || '');
                            return navbarItem;
                        }

                        // Link is created only if the navbar item is NOT a header or a divider

                        link = angular.element('<a>');

                        if (item.disabled) {
                            navbarItem.addClass('disabled');
                            link.addClass('disabled');
                        }

                        if (item.text) {
                            link.text(item.text);
                        }

                        if (item.click) {
                            link.attr('ng-click', item.click);
                        }

                        if (item.link) {
                            link.attr('href', item.link);
                        } else {
                            // Prevent navigation
                            link.on('click', function (event) {
                                event.preventDefault();
                            });
                        }

                        navbarItem.append(link);

                        // Subnavbars are created if the navbar item is NOT a header or a divider

                        if (item.list) {
                            navbarItem.append(createSubNavbar(item.list));
                        }

                        return navbarItem;
                    }

                    function forceArray(object) {
                        return [].concat(object);
                    }

                    function createNavbarItems(items) {
                        var navbarItems = [];

                        angular.forEach(forceArray(items), function(item) {
                            navbarItems.push(createNavbarItem(item));
                        });

                        return navbarItems;
                    }

                    function createSubNavbar(items) {
                        var subNavbar = angular.element('<ul class="dropdown-menu">'),
                            navbarItems = createNavbarItems(items);

                        subNavbar.append(navbarItems);

                        return subNavbar;
                    }

                    function prepareNavbar(items) {
                        var alignment;

                        if (_.isArray(items)) {
                            alignment = 'horizontal';
                        } else if (_.isPlainObject(items)) {
                            alignment = 'vertical';
                        }

                        if (alignment) {
                            elem.addClass('navbar-' + alignment);
                        }

                        if (elem.closest('.navbar-collapse').length === 0) {
                            elem.addClass('navbar-external');
                        }
                    }

                    function prepareNavbarContent(items) {
                        elem.html(createNavbarItems(items));
                        $compile(elem.contents())(scope);
                    }

                    function updateNavbar(items) {
                        if (angular.isObject(items)) {
                            prepareNavbar(items);
                            prepareNavbarContent(items);
                            $timeout(addBehaviour, 500);
                        }
                    }

                    function watchNavbarItems() {
                        scope.$watch(attrs.mpNavbar, updateNavbar, true);
                    }

                    function initNavbar() {
                        watchNavbarItems();
                    }

                    loadPlugin(bootstrapFile).then(function() {
                        loadPlugin(pluginFile).then(function() {
                            loadPlugin(addOnFile).then(function(){
                                initNavbar();
                            });
                        });
                    });

                }
            };
        }]);

angular.module('mpNavbarFilter', [])
    .directive('mpNavbarFilter', ['$compile', '$parse',
        function($compile, $parse) {
            return {
                templateUrl: 'gaiafrontend/html/navbarFilter.html',
                link: function(scope, element, attrs) {
                    var searchIconContainer = element.find('.input-group-addon'),
                        searchIcon = element.find('span .glyphicon-search'),
                        arrowIcon = element.find('span .glyphicon-chevron-left'),
                        searchBox = element.find('input'),
                        itemContainer = element.find('.item-container'),
                        documentElem = angular.element(document);

                    scope.items = $parse(attrs.mpNavbarFilter)(scope);

                    function createMenuItemLink(item) {
                        var itemLink = angular.element('<a></a>')

                        if (item.disabled) {
                            itemLink.addClass('disabled');
                        }

                        if (item.text) {
                            itemLink.text(item.text);
                        }

                        if (item.click) {
                            itemLink.attr('ng-click', item.click);
                        }

                        if (item.link) {
                            itemLink.attr('href', item.link);
                        } else {
                            // Prevent navigation
                            itemLink.on('click', function(event) {
                                event.preventDefault();
                            });
                        }
                        return itemLink;
                    }

                    function createSubMenuItem(item) {
                        var items = item.list.length > 1 ? item.list : item.list[0].list,
                            subItems = [];

                        angular.forEach(items, function(item) {
                            subItems.push(item)
                        });

                        return subItems;
                    }

                    scope.createMenuItem = function(item) {
                        var menuItem = angular.element('<li>');

                        if (item['class']) {
                            menuItem.attr('ng-class', item['class']);
                        }

                        if (item.divider) {
                            menuItem.addClass('divider');
                            return menuItem;
                        }

                        if (item.header) {
                            menuItem.addClass('dropdown-header');
                            menuItem.text(item.text || '');
                            return menuItem;
                        }

                        menuItem.append(createMenuItemLink(item));

                        if (item.list) {
                            angular.forEach(createSubMenuItem(item), function(item) {
                                menuItem.append(createMenuItemLink(item));
                            });
                        }

                        return menuItem.html();
                    }

                    function unlisten(element, event, listener) {
                        element.off(event, listener);
                        element = null;
                    }

                    function listen(element, event, listener) {
                        element.on(event, listener);
                        return function() {
                            unlisten(element, event, listener);
                        }
                    }

                    function manageSearchBoxStyles() {
                        searchIconContainer.toggleClass('position');
                        searchIcon.toggleClass('display');
                        arrowIcon.toggleClass('display');
                        searchBox.toggleClass('active');
                    }

                    function hideSearchBox() {
                        searchIconContainer.removeClass('position');
                        searchIcon.removeClass('display');
                        arrowIcon.addClass('display');
                        searchBox.removeClass('active');
                    }

                    function manageItemsContainerStyles() {
                        if(searchBox.val().length > 0) {
                            itemContainer.addClass('open');
                        }
                        if(searchBox.val().length === 0) {
                            itemContainer.removeClass('open');
                        }
                    }

                    var listenerForSearchBox = listen(searchBox, 'input', manageItemsContainerStyles),
                        listenerForShowItemsContainer = listen(searchBox, 'focus', manageItemsContainerStyles),
                        listenerForSearchIcon = listen(searchIconContainer, 'click', function () {
                            manageSearchBoxStyles();
                            if (searchBox.hasClass('active')) {
                                searchBox.focus();
                            }
                            if (searchBox.hasClass('active') && searchBox.val().length > 0) {
                                itemContainer.addClass('open');
                            }
                        }),
                        listenerForHideItemsContainer = listen(documentElem, 'click', function (event) {
                            if (event.target !== searchBox[0]) {
                                itemContainer.removeClass('open');
                            }
                        }),
                        watcherForItmesContainer = scope.$watch(function () {
                            return element.find('[mp-navbar]').data('smartmenus');
                            }, function (smartmenus) {
                                if (smartmenus) {
                                    var oldMenuShow = smartmenus.menuShow;
                                    // Sobreescribe el metodo menuShow del plugin smartmenus
                                    smartmenus.menuShow = function ($sub) {
                                        oldMenuShow.call(element.find('[mp-navbar]').data('smartmenus'), $sub);
                                        itemContainer.removeClass('open');
                                    };
                                    watcherForItmesContainer();
                                }
                            });

                    scope.$on('$stateChangeSuccess', function() {
                        hideSearchBox();
                        searchBox.val('');
                    });

                    element.on('$destroy', function() {
                        listenerForSearchIcon();
                        listenerForSearchBox();
                        listenerForShowItemsContainer();
                        listenerForHideItemsContainer();
                    });
                }
            }
        }
    ])
    .filter('navbarFilter', function() {
        return function(items, search) {
            var results= [];
            if(!search || search === '') {
                return items;
            }
            (function filter (items, collection) {
                collection.push.apply(collection, _.filter(items, function (item) {
                    if (item.list) filter(item.list, collection);
                    return item.text && item.text.toLowerCase().search(search.toLowerCase()) >= 0;
                }));
            }(items, results));
            return results;
        }
    })

/*global angular, $ */
angular.module('mpNumber', [])
    /**
     * @doc-component directive
     * @name gaiafrontend.directive.mpNumber
     * @description
     *
     * This directive forces the model to be saved as a number if possible.
     *
     * Validation is not executed. If needed you can use `[mp-type="number"]` instead.
     *
     * @example
       <doc:example module="mpNumber">
        <doc:source>
        script
            function MyCtrl($scope) {
                $scope.$watch('model', function (model) {
                    $scope.modelType = typeof model;
                });
            }
            MyCtrl.$inject = ['$scope'];
        div(ng-controller="MyCtrl")
            form(role="form", name="mpNumberForm", novalidate")
                input.form-control(type="text", ng-model="model", mp-number="mp-number")
                span Model type: {{modelType}}
        </doc:source>
       </doc:example>
     */
    .directive('mpNumber', ['$locale', 'UserSrv','$parse', function($locale, UserSrv, $parse) {
        return {
            require: 'ngModel',
            link: function(scope, elm, attrs, ctrl) {
                var config = $parse(attrs.mpNumberConfig)(scope) || {};
                var decimalSep = config.mpNumberDecimalSep,
                    groupSep = config.mpNumberGroupSep,
                    numDecimals = config.mpNumberDecimals,
                    useMaskInNumber = config.mpNumberMask,
                    removeDecimalSepRegExp,
                    removeInvalidCharsRegExp;

                    function formatNumber(numberString) {
                        numberString = numberString || '';
                        numberString = numberString.replace('.', decimalSep);

                        var num = numberString.split(decimalSep)[0],
                            decimal = numberString.split(decimalSep)[1],
                            chain = '',
                            aux,
                            count = 1,
                            m,
                            formattedNumber;

                        if (num < 0) {
                            aux = 1;
                        } else {
                            aux = 0;
                        }

                        num = num.toString();

                        for (m = num.length - 1; m >= 0; m = m - 1) {

                            chain = num.charAt(m) + chain;

                            if (count % 3 === 0 && m > aux) {
                                chain = groupSep + chain;
                            }


                            if (count === 3) {
                                count = 1;
                            } else {
                                count = count + 1;
                            }

                        }

                        // chain = chain.replace(/.,/, ",");

                        if (decimal !== undefined) {
                            formattedNumber = chain.concat(decimalSep + decimal);
                        } else {
                            formattedNumber = chain;
                        }

                        return formattedNumber;
                    }

                    function removeDecimalSep(numberString) {
                        if(numberString) {
                            return numberString.replace(removeDecimalSepRegExp, '');
                        }
                    }

                    function removeInvalidChars(numberString) {
                        if(numberString) {
                            if(numberString.substring(0, 1) === '-') {
                                return '-' + numberString.replace(removeInvalidCharsRegExp, '');
                            }
                            else {
                                return numberString.replace(removeInvalidCharsRegExp, '');
                            }
                        }
                    }

                    function formatDecimalPart(numberString) {
                        if(numberString) {
                            var position = numberString.indexOf(decimalSep),
                                part1,
                                part2;

                            if (position !== -1) {
                                numberString = removeDecimalSep(numberString);
                                part1 = numberString.slice(0, position);
                                part2 = numberString.slice(position, numberString.length);

                                numberString = part1.concat(decimalSep);
                                numberString = numberString.concat(part2);
                            }

                            return numberString;
                        }
                    }

                    function addZerosToDecimalPart(numberString) {
                        if (numberString) {
                            var position = numberString.indexOf(decimalSep),
                                integerPart,
                                decimalPart,
                                i,
                                len;

                            if (position === -1) {
                                position = numberString.length;
                            }

                            numberString = removeDecimalSep(numberString);
                            integerPart = numberString.slice(0, position);
                            decimalPart = numberString.slice(position, numberString.length);

                            if (decimalPart.length < numDecimals) {
                                for (i = 0, len = numDecimals - decimalPart.length; i < len; i = i + 1) {
                                    decimalPart = decimalPart + '0';
                                }
                            }

                            numberString = integerPart.concat(decimalSep);
                            numberString = numberString.concat(decimalPart);

                            return numberString;
                        }

                        return numberString;
                    }

                    function fromModelToView(numberString) {
                        if (numberString) {
                            return numberString;
                        }
                    }

                    function fromViewToModel(numberString) {
                        numberString = removeInvalidChars(numberString);
                        numberString = formatDecimalPart(numberString);
                        var numberString2;
                        if (numberString) {
                            numberString2 = numberString.replace(decimalSep, '.');
                        }

                        ctrl.$viewValue = fromModelToView(numberString); // we need that fromModelToView to be executed even if the model doesn`t change
                        ctrl.$render();

                        if(!useMaskInNumber) {
                            return parseInt(numberString2, 10);
                        }
                        else {
                            return numberString2;
                        }
                    }

                    function updateRegExps() {
                        removeDecimalSepRegExp = new RegExp('[' + decimalSep + ']', 'gi');
                        if(useMaskInNumber) {
                            removeInvalidCharsRegExp = new RegExp('[^0-9' + decimalSep + ']', 'gi');
                        }
                        else {
                            removeInvalidCharsRegExp = new RegExp('[^0-9]', 'gi');
                        }

                    }
                if(useMaskInNumber) {
                    scope.userInfo = UserSrv.info;
                    updateRegExps();

                    if (!decimalSep) {
                        scope.$watch('userInfo.applicationData.formattingAndMask.decimalSeparator', function (userInfoDecimalSep) {
                            decimalSep = userInfoDecimalSep || $locale.NUMBER_FORMATS.DECIMAL_SEP;
                            updateRegExps();
                        });
                    }

                    if (!groupSep) {
                        scope.$watch('userInfo.applicationData.formattingAndMask.groupSeparator', function (userInfoGroupSep) {
                            groupSep = userInfoGroupSep || $locale.NUMBER_FORMATS.GROUP_SEP;
                        });
                    }

                    if (!numDecimals) {
                        scope.$watch('userInfo.applicationData.formattingAndMask.decimalLength', function (userInfoDecimalLength) {
                            numDecimals = userInfoDecimalLength || 2;
                        });
                    }

                    ctrl.$parsers.push(fromViewToModel);
                    ctrl.$formatters.push(fromModelToView);

                    if(useMaskInNumber) {
                        elm.on('focus', function() {
                            var valToPutInInput;
                            if(ctrl.$modelValue) {
                                if(ctrl.$modelValue.replace) {
                                    valToPutInInput = ctrl.$modelValue.replace('.', decimalSep);
                                }
                                else {
                                    valToPutInInput = ctrl.$modelValue;
                                }
                            }
                            elm.val(valToPutInInput);
                            this.selectionStart = this.selectionEnd = this.value.length;
                        });

                        elm.on('focusout', function() {
                                elm.val(addZerosToDecimalPart(formatNumber(ctrl.$modelValue)));
                        });
                    }
                }
                else {
                    ctrl.$parsers.push(function(value) {
                        var number = parseFloat(value),
                            empty = ctrl.$isEmpty(number);
                        if(empty) {
                            return;
                        }
                        else {
                            return number;
                        }
                    });
                }
            }
        };
    }]);

/*global angular */
angular.module('mpOptionsList', ['mgcrea.ngStrap'])
    .constant('OptionsListConfig', {
        url: 'api/nwt/trn/optVal'
    })
    .factory('OptionsListSrv', ['HttpSrv', 'OptionsListConfig', function (HttpSrv, OptionsListConfig) {
        return {
            get: function getOptionsList(data) {
                return HttpSrv.post(OptionsListConfig.url, data);
            }
        };
    }])
    /**
        * @doc-component directive
        * @name gaiafrontend.directive.mpOptionsList
        * @description
        * This component has been migrated to "GAIA Site"
        * There you will find its documentation and several examples.
        * "GAIA Site" is an application created by the Architecture Area to learn and play with GAIA. Is available in RAS. Direct links are available below in this page.
        * @example
        <doc:example>
             <doc:source>
             label GAIA site direct links are:
             a(href='https://wportalinterno.es.mapfre.net/com.ibm.ram.repository.web/faces/_rlvid.jsp?_rap=!assetDetails&_rvip=/home.jsp&guid=13A33828-B921-8DC5-DEDA-8B8D7C0EBC81') Intranet /
             a(href='https://wportalinterno.mapfre.com/com.ibm.ram.repository.web/faces/_rlvid.jsp?_rap=!assetDetails&_rvip=/home.jsp&guid=13A33828-B921-8DC5-DEDA-8B8D7C0EBC81') Internet
             </doc:source>
        </doc:example>
    */
    .directive('mpOptionsList', ['$parse', '$parseOptions', 'OptionsListSrv', function ($parse, $parseOptions, OptionsListSrv) {
        var typeRegExp = /(input)?\s*?\+?\s*?(typeahead|select)/;

        return {
            compile: function(cElement, cAttributes) {
                var match = cAttributes.mpOptionsList.match(typeRegExp),
                    input = match && match[1], // null | undefined | 'input'
                    type = match && match[2], // null | 'select' | 'typeahead'
                    descriptionElement,
                    descriptionCaretElement;

                function generateCodeOptionsExpression() {
                    var parsedOptions = $parseOptions(cAttributes.mpOptionsListOptions),
                        value = parsedOptions.$match[1],
                        iterator = parsedOptions.$match[4],
                        collection = parsedOptions.$match[7];

                    return value + ' as ' + value + ' for ' + iterator + ' in ' + collection;
                }

                function createTypeaheadCodeElement() {
                    var codeElement = angular.element('<input class="form-control" autocomplete="off"></input>'),
                        options = cAttributes.mpOptionsListCodeOptions || generateCodeOptionsExpression(),
                        attributes = cAttributes.mpOptionsListCodeAttributes,
                        attributesObject = $parse(attributes)();

                    attributesObject.dataFilter = attributesObject.dataFilter || 'filterByPath:"' + $parseOptions(options).$match[2] + '"';

                    codeElement
                        .attr('mp-typeahead', 'mp-typeahead')
                        .attr('mp-typeahead-model', cAttributes.mpOptionsListModel)
                        .attr('mp-typeahead-options', options)
                        .attr('mp-typeahead-attributes', JSON.stringify(attributesObject));

                    return codeElement;
                }

                function createCodeWrapperElement() {
                    var codeWrapperElement = angular.element('<div>'),
                        codeAttributes = input && cAttributes.mpOptionsListCodeAttributes ? $parse(cAttributes.mpOptionsListCodeAttributes)() : undefined;

                    if (input) {
                        codeWrapperElement
                            .addClass(!codeAttributes || codeAttributes.type === 'hidden' ? 'hidden' : 'col-sm-2')
                            .append(createTypeaheadCodeElement());
                    }

                    return codeWrapperElement;
                }

                function createSelectDescriptionElement() {
                    var descriptionElement = angular.element('<select class="form-control"></select>');

                    descriptionElement
                        .attr('mp-select', 'mp-select')
                        .attr('mp-select-model', cAttributes.mpOptionsListModel)
                        .attr('mp-select-options', cAttributes.mpOptionsListDescriptionOptions || cAttributes.mpOptionsListOptions)
                        .attr('mp-select-config', '{placeholder: "' + (cAttributes.mpOptionsListDefaultOption || '') + '"}')
                        .attr('mp-select-attributes', cAttributes.mpOptionsListDescriptionAttributes);

                    return descriptionElement;
                }

                function createTypeaheadDescriptionElement() {
                    var descriptionElement = angular.element('<input type="text" class="form-control" autocomplete="off"></input>'),
                        options = cAttributes.mpOptionsListDescriptionOptions || cAttributes.mpOptionsListOptions,
                        attributes = cAttributes.mpOptionsListDescriptionAttributes,
                        attributesObject = $parse(attributes)();

                    attributesObject.dataFilter = attributesObject.dataFilter || 'filterByPath:"' + $parseOptions(options).$match[2] + '"';

                    descriptionElement
                        .attr('mp-typeahead', 'mp-typeahead')
                        .attr('mp-typeahead-model', cAttributes.mpOptionsListModel)
                        .attr('mp-typeahead-options', options)
                        .attr('mp-typeahead-attributes', JSON.stringify(attributesObject))
                        .attr('placeholder', cAttributes.mpOptionsListDefaultOption || '');

                    return descriptionElement;
                }

                function createTypeaheadDescriptionCaretElement() {
                    var descriptionAttributes = $parse(cAttributes.mpOptionsListDescriptionAttributes)();
                    return angular.element('<a class="combobox-show-all-button" ng-class="{\'not-allowed\': ' + (descriptionAttributes.disabled || descriptionAttributes.ngDisabled) + '}"></a>')
                        .attr('tabIndex', -1)
                        .attr('title', 'Show all items');
                }

                function createDescriptionWrapperElement() {
                    var descriptionWrapperElement = angular.element('<div class="validable"></div>'),
                        codeAttributes = input && cAttributes.mpOptionsListCodeAttributes ? $parse(cAttributes.mpOptionsListCodeAttributes)() : undefined;

                    descriptionWrapperElement.addClass(!codeAttributes || codeAttributes.type === 'hidden' ? 'col-sm-12' : 'col-sm-10');

                    if (type === 'select') {
                        descriptionWrapperElement
                            .append(createSelectDescriptionElement());
                    } else {
                        descriptionElement = createTypeaheadDescriptionElement();
                        descriptionCaretElement = createTypeaheadDescriptionCaretElement();
                        descriptionWrapperElement
                            .append(descriptionElement)
                            .append(descriptionCaretElement);

                    }

                    return descriptionWrapperElement;
                }

                if (cElement.contents().length) {
                    cElement.empty();
                }

                cElement
                    .append(createCodeWrapperElement())
                    .append(createDescriptionWrapperElement())

                return function postLink (scope, lElement, lAttributes) {
                    var caretElement = lElement.find('a'),
                        unListenCaretElement;

                    if (angular.isDefined(lAttributes.mpOptionsListData)) {
                        scope.$watch(lAttributes.mpOptionsListData, function (data) {
                            if (!data) return;
                            var collectionName = $parseOptions(lAttributes.mpOptionsListOptions || lAttributes.mpOptionsListDescriptionOptions).$match[7];
                            OptionsListSrv.get(data)
                                .then(function (list) {
                                    $parse(collectionName).assign(scope, list.data);
                                }, function () {
                                    $parse(collectionName).assign(scope, []);
                                })
                        });
                    }

                    function listen(element, event, listener) {
                        element.on(event, listener);
                        return function() {
                            element.off(event, listener);
                        }
                    }

                    function whenClickOnCaret() {
                        if (!caretElement.siblings('.typeahead.dropdown-menu').length) {
                            caretElement.siblings().focus();
                        }
                    }

                    unListenCaretElement = listen(caretElement, 'click', whenClickOnCaret)
                    lElement.on('$destroy', function() {
                        unListenCaretElement();
                    });
                };
            }
        };
    }]);

/*TODO: REVIEW*/
/**
 * @doc-component directive
 * @name gaiafrontend.directive.mpRichTextEditor
 * @param {string=} mp-rich-text-editor Property of the scope, supports all of the standard TinyMCE initialization options.
 * @description
 * Visit Issuestracker for more information and examples of this component.
 */
/*global tinymce*/
(function() {
    'use strict';

    function mpRichTextEditor($rootScope, $compile, $timeout, $window, $sce, mpRichTextEditorConfig, Loader, Language) {
        mpRichTextEditorConfig = mpRichTextEditorConfig || {};
        var generatedIds = 0;
        var ID_ATTR = 'mp-rich-text-editor';
        if (mpRichTextEditorConfig.baseUrl) {
            tinymce.baseURL = mpRichTextEditorConfig.baseUrl;
        }

        return {
            require: ['ngModel', '^?form'],
            link: function(scope, element, attrs, ctrls) {

                function originalLink() {
                    if (!$window.tinymce) {
                        return;
                    }

                    var ngModel = ctrls[0],
                        form = ctrls[1] || null;

                    var expression, options, tinyInstance,
                        updateView = function(editor) {
                            var content = editor.getContent({
                                format: options.format
                            }).trim();
                            content = $sce.trustAsHtml(content);

                            ngModel.$setViewValue(content);
                            if (!$rootScope.$$phase) {
                                scope.$apply();
                            }
                        };

                    function toggleDisable(disabled) {
                        if (disabled) {
                            ensureInstance();

                            if (tinyInstance) {
                                tinyInstance.getBody().setAttribute('contenteditable', false);
                            }
                        } else {
                            ensureInstance();

                            if (tinyInstance) {
                                tinyInstance.getBody().setAttribute('contenteditable', true);
                            }
                        }
                    }

                    // generate an ID
                    attrs.$set('id', ID_ATTR + '-' + generatedIds++);

                    expression = {
                        language: Language.get().languageId
                    };

                    angular.extend(expression, scope.$eval(attrs.mpRichTextEditor));

                    options = {
                        // Update model when calling setContent
                        // (such as from the source editor popup)
                        setup: function(ed) {
                            ed.on('init', function() {
                                ngModel.$render();
                                ngModel.$setPristine();
                                if (form) {
                                    form.$setPristine();
                                }
                            });

                            // Update model on button click
                            ed.on('ExecCommand', function() {
                                ed.save();
                                updateView(ed);
                            });

                            // Update model on change
                            ed.on('change', function() {
                                ed.save();
                                updateView(ed);
                            });

                            ed.on('blur', function() {
                                element[0].blur();
                            });

                            // Update model when an object has been resized (table, image)
                            ed.on('ObjectResized', function() {
                                ed.save();
                                updateView(ed);
                            });

                            ed.on('remove', function() {
                                element.remove();
                            });

                            if (expression.setup) {
                                expression.setup(ed, {
                                    updateView: updateView
                                });
                            }
                        },
                        format: 'raw',
                        selector: '#' + attrs.id
                    };
                    // extend options with initial mpRichTextEditorConfig and
                    // options from directive attribute value
                    angular.extend(options, mpRichTextEditorConfig, expression);
                    // Wrapped in $timeout due to $tinymce:refresh implementation, requires
                    // element to be present in DOM before instantiating editor when
                    // re-rendering directive
                    $timeout(function() {
                        tinymce.init(options);
                        toggleDisable(scope.$eval(attrs.ngDisabled));
                    });

                    ngModel.$formatters.unshift(function(modelValue) {
                        return modelValue ? $sce.trustAsHtml(modelValue) : '';
                    });

                    ngModel.$parsers.unshift(function(viewValue) {
                        return viewValue ? $sce.getTrustedHtml(viewValue) : '';
                    });

                    ngModel.$render = function() {
                        ensureInstance();

                        var viewValue = ngModel.$viewValue ?
                            $sce.getTrustedHtml(ngModel.$viewValue) : '';

                        // instance.getDoc() check is a guard against null value
                        // when destruction & recreation of instances happen
                        if (tinyInstance &&
                            tinyInstance.getDoc()
                        ) {
                            tinyInstance.setContent(viewValue);
                            // Triggering change event due to TinyMCE not firing event &
                            // becoming out of sync for change callbacks
                            tinyInstance.fire('change');
                        }
                    };

                    attrs.$observe('disabled', toggleDisable);

                    // This block is because of TinyMCE not playing well with removal and
                    // recreation of instances, requiring instances to have different
                    // selectors in order to render new instances properly
                    scope.$on('$tinymce:refresh', function(e, id) {
                        var eid = attrs.id;
                        if (angular.isUndefined(id) || id === eid) {
                            var parentElement = element.parent();
                            var clonedElement = element.clone();
                            clonedElement.removeAttr('id');
                            clonedElement.removeAttr('style');
                            clonedElement.removeAttr('aria-hidden');
                            tinymce.execCommand('mceRemoveEditor', false, eid);
                            parentElement.append($compile(clonedElement)(scope));
                        }
                    });

                    scope.$on('$destroy', function() {
                        ensureInstance();

                        if (tinyInstance) {
                            tinyInstance.remove();
                            tinyInstance = null;
                        }
                    });

                    function ensureInstance() {
                        if (!tinyInstance) {
                            tinyInstance = tinymce.get(attrs.id);
                        }
                    }
                }
                Loader.load('tinymce/tinymce.js')
                    .then(originalLink);
                    // .then(Loader.load('theme.min.js'))
                // Loader.load('tinymce.min.js')
                //     .then(function () {
                //         return Loader.load('theme.min.js')
                //     }).then(originalLink);
            }
        };
    }
    (angular.module('mpRichTextEditor', ['utils']))
        .value('mpRichTextEditorConfig', {})
        .directive('mpRichTextEditor', ['$rootScope', '$compile', '$timeout', '$window', '$sce', 'mpRichTextEditorConfig', 'Loader', 'Language', mpRichTextEditor]);

}());

/*global angular */
angular.module('mpSelect', ['utils'])
    /*TODO: Use $select to build a custom directive. Do not wrap bsTypeahead.*/
    /**
     * @doc-component directive
     * @name gaiafrontend.directive.mpSelect
     * @param {expression} mp-select-model The selected option will be assigned to the result of the expression.
     * @param {expression} mp-select-options Expression `ngOptions` alike to dynamically generate options. See [ngOptions](https://code.angularjs.org/1.2.16/docs/api/ng/directive/select#-ngoptions-) documentation for more info.
     * @param {expression=} mp-select-config The result of evaluating this expression should be an options object. Supported options are listed [here](http://mgcrea.github.io/angular-strap/##selects-usage).
     * @description
     * This directive allows you to display a dropdown component as a select .
     *
     * This directive wraps the AngularStrap `bs-select` directive.
     * @example
       <doc:example>
        <doc:source>
        script
            function SelectCtrl($scope) {
                $scope.selectedIcon = '';
                $scope.selectedIcons = ['Globe', 'Heart'];
                $scope.icons = [{
                    value: 'Gear',
                    label: '<span class="glyphicon glyphicon-cog"></span> Gear'
                }, {
                    value: 'Globe',
                    label: '<span class="glyphicon glyphicon-globe"></span> Globe'
                }, {
                    value: 'Heart',
                    label: '<span class="glyphicon glyphicon-heart"></span> Heart'
                }, {
                    value: 'Camera',
                    label: '<span class="glyphicon glyphicon-camera"></span> Camera'
                }];
            }
            SelectCtrl.$inject = ['$scope'];
        div(ng-controller="SelectCtrl")
            form.form-horizontal(role="form", name="selectForm")
                .row
                    .form-group.col-md-6
                        label.control-label.col-md-2(for="select1") Single:
                        .validable.col-md-10
                            data ={delay: 10, html: 1, placeholder: "Choose bro'"}
                            select.form-control(type="button", id="select1", name="select1", required="required", mp-select, mp-select-model="selectedIcon", mp-select-options="icon.value as icon.label for icon in icons", mp-select-config="#{JSON.stringify(data)}")
                    .form-group.col-md-6
                        label.control-label.col-md-2(for="select2") Multiple:
                        .validable.col-md-10
                            select.form-control(type="button", id="select2", name="select2", required="required", mp-select, mp-select-model="selectedIcons", mp-select-options="icon.value as icon.label for icon in icons", mp-select-config="{multiple: 1, html: 1}")

        </doc:source>
       </doc:example>
     */
    .directive('mpSelect', ['$parse', '$compile', 'Utils', function ($parse, $compile, Utils) {
        return {
            link: function(scope, element, attributes) {
                var config,
                    attrs;

                if (angular.isUndefined(attributes.bsSelect)) {
                    config = $parse(attributes.mpSelectConfig)(scope);
                    // FIX: IE8 needs a minimum delay to work as intended
                    config = config || {};
                    config.delay = !angular.isDefined(config.delay) || parseInt(config.delay, 10) < 100 ? '100' : config.delay;
                    config.trigger = 'focus';
                    // TODO: REVIEW
                    // Because of mpOptionsList directive
                    // If mpOptionsList assign these attributes they will be compiled twice
                    // and some directives might not work as intended (ngClick expression will be evaluated twice)
                    attrs = $parse(attributes.mpSelectAttributes)(scope);
                    attrs = attrs || {};
                    angular.forEach(attrs, function (value, attr) {
                        element.attr(Utils.string.toHyphens(attr), value);
                    });

                    element
                        .addClass('select')
                        .attr('bs-select', attributes.mpSelect)
                        .attr('ng-model', attributes.mpSelectModel)
                        .attr('ng-options', attributes.mpSelectOptions);

                    angular.forEach(config, function (value, option) {
                        element.attr('data-' + Utils.string.toHyphens(option), value);
                    });

                    $compile(element)(scope);
                }
            }
        };
    }]);

/*global angular */
angular.module('mpSession', [])

    .constant('SessionConfig', {
        'sessionParams':{},
        'sessionNode':      null
    })

    .controller('MpSessionCtrl', ['$scope', '$filter', '$q', '$timeout', '$interval', '$window', 'SessionConfig', 'SessionSrv', function ($scope, $filter, $q, $timeout, $interval, $window, SessionConfig, SessionSrv) {
        var sessionContainer = angular.element('.sessionContainer');
        var sessionClickBtn = angular.element('#sessionBtn');
        var sessionMsg = angular.element('.sessionMsg');

        SessionConfig.time = SessionSrv.calculateMillis(SessionConfig.time);
        SessionConfig.sessionParams.sessionAlertTime = SessionSrv.calculateMillis(SessionConfig.sessionParams.sessionAlertTime);

        function deferredTranslation(key){
            var deferred = $q.defer();
             $timeout(function(){
                deferred.resolve($filter('translate')(key))}, 1000);
            return deferred.promise;
        }

        deferredTranslation('mpSession.msg1').then(function(result){
            SessionConfig.sessionParams.msg1 = result;
            $scope.msg1 = SessionConfig.sessionParams.msg1;
        });


        deferredTranslation('mpSession.msg2').then(function(result){
            SessionConfig.sessionParams.msg2 = result
        });

        SessionConfig.sessionNode = sessionContainer === null ? null : sessionContainer;

        /* Ocultamiento y envío de la petición para hacer ping y que no se cierre la sesión */
        function hide() {
            SessionSrv.sessionPing();
        }

        /* Control del evento de click del botón */
        function unlisten(element, event, listener) {
            element.off(event, listener);
        }

        function listen(element, event, listener) {
            element.on(event, listener);
            return function() {
                unlisten(element, event, listener);
            }
        }

        function desregisterListeners() {
            unlisten(sessionClickBtn, 'click', hide);
        }

        var unlistenSessionClickBtn = listen(sessionClickBtn, 'click', hide);

        sessionClickBtn.on('$destroy', function() {
            unlistenSessionClickBtn();
        })

        SessionSrv.init();

    }])

    .directive('mpSession', ['SessionConfig', function (SessionConfig) {
        return {
            templateUrl: 'gaiafrontend/html/sessionAlert.html',
            controller: 'MpSessionCtrl',
            transclude: true,
            replace: true
        };
    }])

    .factory('SessionSrv', ['SessionConfig', 'SessionCounterSrv', 'HttpSrv', '$interval', 'Tbid', function (SessionConfig, SessionCounterSrv, HttpSrv, $interval, Tbid) {

        function sessionPing(){
            HttpSrv.get(SessionConfig.sessionParams.endPoint);
        }

        function initSrv(){
            HttpSrv.get(SessionConfig.sessionParams.endPoint)
                .then(function(data){
                    SessionConfig.time = calculateMillis(data);
                    SessionCounterSrv.start(SessionConfig.time);
                    SessionConfig.tbid = {
                        header : Tbid.header
                    }
                })
        }

        function calculateMillis(time){
            return Math.round((parseFloat(time,10) * 60) * 1000);
        }

        return {
            sessionPing: sessionPing,
            init:        initSrv,
            calculateMillis: calculateMillis
        }
    }])

    .factory('SessionCounterSrv', ['SessionConfig', '$interval', '$window', '$filter', 'BrowserDetectSrv', 'SessionStorageSrv', function (SessionConfig, $interval, $window, $filter, BrowserDetectSrv, SessionStorage) {
        var deltaTime = 1000;
        var interval = null;
        var counter = SessionConfig.time;
        var mainSessionDiv = null;
        var sessionWindow;
        var win = angular.element($window);
        var browser;

        function clock(counterParam){
            if(counterParam){
                SessionConfig.time = counterParam;
            }

            checkTimersCoherence();
            counter = SessionConfig.time;

            if (counter > 1000 && !interval){
                interval = $interval(counterClockDown, deltaTime, 0);
            }
        }

        function checkTimersCoherence(){
            if(SessionConfig.time < 60000){
                SessionConfig.time  = 60000;
                if(typeof console !== "undefined"){
                    console.log('Check your session time. Is less than the 1 minute minimum. Setting session time to minimum.');
                }
            }

            if(SessionConfig.sessionParams.sessionAlertTime >= SessionConfig.time){
                SessionConfig.sessionParams.sessionAlertTime = SessionConfig.time / 2;
                if(typeof console !== "undefined"){
                    console.log('Check your session alert time. Is bigger than configured session time. Setting session alert time to half the session time.');
                }
            }
        }

        function counterClockDown(){

            if(!mainSessionDiv){
                mainSessionDiv = angular.element('.sessionContainer');
            }

            if(counter <= 0){
                var sessionBtn = angular.element('#sessionBtn', mainSessionDiv);
                var counterCont = angular.element('.counterCont', mainSessionDiv);

                killInterval();
                killTbid();
                killCookies();
                angular.element('.sessionMsg', mainSessionDiv).text(SessionConfig.sessionParams.msg2);
                counterCont.addClass('hide');
                sessionBtn.off('click');
                sessionBtn.on('click', redirectHREF);
                setWindowPosition();
                if(typeof console !== "undefined"){
                    console.log('Your session is over.');
                }
            }

            if(counter <= SessionConfig.sessionParams.sessionAlertTime ){
                var sessionCounterUnits = angular.element('.sessionCounterUnits', mainSessionDiv);
                var sessionCounterDigits = angular.element('strong', mainSessionDiv);

                if(counter > 60000){
                    sessionCounterDigits.text(Math.ceil((counter/1000)/60));
                    sessionCounterUnits.text($filter('translate')('mpSession.minStr'));
                }else{
                    sessionCounterDigits.text(counter/1000);
                    sessionCounterUnits.text($filter('translate')('mpSession.secStr'));
                }

                if(!mainSessionDiv.hasClass('show')){
                    mainSessionDiv.addClass('show');
                    setWindowPosition();
                }
            }

            counter = counter - deltaTime;
        }

        function redirectHREF(){
            $window.location.href = SessionConfig.sessionParams.expiredHREF;
        }

        function resetClock(){
            killInterval()
            if(mainSessionDiv){
                mainSessionDiv.removeClass('show');
                if(typeof console !== "undefined"){
                    console.log('Your session time has been restarted.');
                }
            }
            clock();
        }

        function killInterval(){
            if(interval){
                $interval.cancel(interval);
                interval = null;
            }
        }

        function killTbid(){
            SessionStorage.removeItem(SessionConfig.tbid.header.get())
        }

        function killCookies(){
            var aKeys = getCookiesKeys();
            for(var i=0; i<aKeys.length;i++){
                document.cookie = aKeys[i] + '=;expires=Thu, 01 Jan 1970 00:00:01 GMT;';
            }
        }

        function getCookiesKeys(){
            var aCookies = document.cookie.split('; ');
            var aKeys=[];
            for(var i=0; i<aCookies.length; i++){
                aKeys.push(aCookies[i].split('=')[0])
            }
            return aKeys
        }

        function setWindowPosition(){
            if(!browser){
                browser = BrowserDetectSrv.getBrowser();
            }

            if(browser.name === 'Explorer' && browser.version <= 8){
                sessionWindow = angular.element('.sessionWindow');
                var topPos = (win.height() - sessionWindow.height()) / 2;
                var leftPos = (win.width() - sessionWindow.width()) / 2;
                sessionWindow.css('top', topPos + 'px');
                sessionWindow.css('left', leftPos + 'px');
            }
        }

        win.bind('resize', function(){
            setWindowPosition();
        })

        return {
            reset: resetClock,
            start: clock,
            setWindowPosition: setWindowPosition
        }
    }]);

/*global angular */
/*DEPRECATED*/
/**
 * @doc-component directive
 * @name gaiafrontend.directive.mpSlider
 * @description
 * DEPRECATED
 * If you need this component ask for it through UX department
 */
angular.module('mpSlider', [])
    .directive('mpSlider', function() {
        return {
            templateUrl: 'gaiafrontend/html/slider.html',
            link: function(scope, elm, attrs) {
                var min = attrs.mpSliderMin,
                    max = attrs.mpSliderMax,
                    sliderOptions;

                scope.sliderValue = 0;

                function refreshValue() {
                    scope.$apply(function() {
                        scope.sliderValue = elm.slider('option', 'value');
                    });
                }

                sliderOptions = {
                    min: min,
                    max: max,
                    slide: refreshValue
                };

                elm.slider(sliderOptions);
            }
        };
    });

/*global angular */
angular.module('mpStateModal', ['utils'])
    /**
     * @doc-component service
     * @name gaiafrontend.service.stateModal
     * @description
     * The `StateModal` service allows you to manage the visibility of a state (and its children) whose view is displayed as/in a modal.
     *
     * This service works "hand in hand" with `mpStateModal` directive.
     *
     * For more info about its usage see `mpStateModal` directive documentation.
     *
     */
    .factory('StateModal', function() {
        var modal = this;

        modal.visible = false;

        /**
         * @doc-component method
         * @methodOf gaiafrontend.service.stateModal
         * @name gaiafrontend.service.stateModal#open
         * @description The `open` method turns the state modal view visible.
         */
        function open() {
            modal.visible = true;
        }

        /**
         * @doc-component method
         * @methodOf gaiafrontend.service.stateModal
         * @name gaiafrontend.service.stateModal#close
         * @description The `close` method turns the state modal view not visible.
         */
        function close() {
            modal.visible = false;
        }

        modal.open = open;
        modal.close = close;

        return modal;
    })
    /**
     * @doc-component directive
     * @name gaiafrontend.directive.mpStateModal
     * @param {string=} mp-state-modal-class Space separated classes to apply to .modal-dialog element. Bootstrap provides .modal-lg and -modal-sm classes to apply different modal sizes.
     * @description
     *
     * This directive allows you to display a state view as a modal window.
     *
     * This directive works "hand in hand" with `StateMdoal` service.
     *
     * #Usage
     *
     * If our web application has a section to register users in two steps we would have a `state.js` file like this.
     *
     *  ```js
     *  states.push({
     *      'name': 'registrationFlw',
     *      'abstract': true,
     *      'templateUrl': 'registration/html/registrationFlw.html',
     *      'controller': 'RegistrationFlwCtrl'
     *      },
     *      'resolve': {
     *          'flowData': ['DataSrv', function (DataSrv) {
     *              return DataSrv.$new(this.name);
     *          }]
     *      }
     *  });
     *
     *  states.push({
     *      'parent': 'registrationFlw',
     *      'name': 'registrationInfo',
     *      'url': '/registrationInfo',
     *      'views': {
     *          'registrationFlwChild@registrationFlw': {
     *              'templateUrl': 'registration/html/registrationInfo.html',
     *              'controller': 'RegistrationInfoCtrl'
     *          }
     *      }
     *  });
     *
     *  states.push({
     *      'parent': 'registrationFlw',
     *      'name': 'confirmation',
     *      'url': '/confirmation',
     *      'views': {
     *          'registrationFlwChild@registrationFlw': {
     *              'templateUrl': 'registration/html/confirmation.html',
     *              'controller': 'ConfirmationCtrl'
     *          }
     *      }
     *  });
     *  ```
     *
     * Our states are:
     *
     * - `registrationFlw` This is an abstract parent state to manage the registration flow.
     * - `registrationInfo` This is the first step of our flow. In this state the user will introduce his registration info.
     * - `confirmation` This is the second step of our flow. In ths state a confirmation/error message will be displayed.
     *
     * We want this flow to be displayed in a modal window.
     * For this purpose we will use the `mpStateModal` directive in the same DOM element we are using the `uiView` directive.
     *
     * The best way to do this is by applying the `mpStateModal` directive to the `registrationFlw` template's `uiView`.
     *
     * So the `registrationFlw` jade template will be something like this.
     *
     *  ```js
     *  h1 Registration
     *  div(ui-view="registrationFlwChild", mp-state-modal)
     *  ```
     *
     * To open/close our modal we could use the `onEnter`/`onExit` state object properties
     * but (due to how states are resolved) if we try to navigate straight to `registration` state the modal will not open
     * because the `onEnter` callback will be executed before the modal element exists in the DOM.
     *
     * To solve this problem the `StateModal` service has been developed. See `StateModal` service documentation for more info.
     *
     * So in our example we will show and hide our modal window from `RegistrationFlwCtrl`.
     *
     *  ```js
     *  function ControllerName($scope, StateModal) {
     *      StateModal.open();
     *
     *      //Logic here...
     *
     *      $scope.$on('$destroy', function () {
     *          StateModal.close();
     *      })
     *  }
     *  ```
     *
     * This way we can navigate straight to `registration` state and when we go to any state that is not a `registrationFlw` child state our modal will close.
     *
     */
    .directive('mpStateModal', ['Loader', 'StateModal',
        function(Loader, StateModal) {
            return {
                templateUrl: 'gaiafrontend/html/stateModal.html',
                transclude: true,
                link: function(scope, element, attributes) {
                    var loadPlugin = Loader.load,
                        bootstrapFile = 'bootstrap.js',
                        mpStateModalClass = attributes.mpStateModalClass,
                        modal = element.find('.modal');

                    if (mpStateModalClass) {
                        modal.find('.modal-dialog').addClass(mpStateModalClass);
                    }

                    function initModal() {
                        modal.modal({
                            backdrop: 'static',
                            keyboard: false,
                            show: false
                        });

                        scope.$watch(function() {
                            return StateModal.visible;
                        }, function(visible) {
                            modal.modal(visible ? 'show' : 'hide');
                        });
                    }

                    loadPlugin(bootstrapFile)
                        .then(initModal);
                }
            };
        }]);

/**
    * @doc-component directive
    * @name gaiafrontend.directive.mpTable
    * @description
    * This component has been migrated to "GAIA Site"
    * There you will find its documentation and several examples.
    * "GAIA Site" is an application created by the Architecture Area to learn and play with GAIA. Is available in RAS. Direct links are available below in this page.
    * @example
    <doc:example>
         <doc:source>
         label GAIA site direct links are:
         a(href='https://wportalinterno.es.mapfre.net/com.ibm.ram.repository.web/faces/_rlvid.jsp?_rap=!assetDetails&_rvip=/home.jsp&guid=13A33828-B921-8DC5-DEDA-8B8D7C0EBC81') Intranet /
         a(href='https://wportalinterno.mapfre.com/com.ibm.ram.repository.web/faces/_rlvid.jsp?_rap=!assetDetails&_rvip=/home.jsp&guid=13A33828-B921-8DC5-DEDA-8B8D7C0EBC81') Internet
         </doc:source>
    </doc:example>
*/
(function () {
    var defaults = {
        autowidth: false,
        data: [],
        height: 150,
        rowNum: 20,
        shrinkToFit: true,
        colModel: {
            width: 150,
            key: 'id'
        }
    };

    function isANumber(value) {
        return !isNaN(value) && typeof value === 'number';
    }

    function escapeHtml(str) {
        var entityMap = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#39;',
            '/': '&#x2F;'
        };
        return String(str).replace(/[&<>"'\/]/g, function (s) {
            return entityMap[s];
        });
    }

    function pixelsToPercentage(width, total) {
        return (width * 100) / total + '%';
    }

    function calculateTableWidth(width) {
        if (isANumber(+width)) width = width + 'px';
        else width = '';

        return width;
    }

    function calculateTableHeight(height) {
        if (isANumber(+height)) height = height + 'px';
        else if (height !== '100%' && height !== 'auto') height = defaults.height + 'px';

        return height;
    }

    function calculateCellWidth(width, autowidth) {
        if (autowidth !== true && isANumber(+width)) width = width + 'px';
        else if (autowidth !== true) width = defaults.colModel.width + 'px';

        return width;
    }

    function recalculateColModelWidths(colModels) {
        var total = 0,
            i, l;

        for (i = 0, l = colModels.length; i < l; i += 1) {
            colModels[i].width = colModels[i].hidden ? 0 : +calculateCellWidth(colModels[i].width).replace('px', '');
            total += colModels[i].width;
        }

        for (i = 0, l = colModels.length; i < l; i += 1) {
            colModels[i].width = pixelsToPercentage(colModels[i].width, total);
        }

        return colModels;
    }

    function calculateCellAlign(align) {
        if (align !== 'left' && align !== 'center' && align !== 'right') align = '';
        return align;
    }

    angular.module('mpTable', [])
        .directive('mpTable', ['Utils', '$parse', '$compile', function (Utils, $parse, $compile) {
            return {
                template: '<div></div>',
                replace: true,
                link: function (scope, elem, attrs) {
                    var optionsExpression = attrs.mpTableOptions,
                        dataExpression = attrs.mpTableData,
                        loadOnce = angular.isDefined(attrs.mpTableOnce),
                        raw = angular.isDefined(attrs.mpTableRaw),
                        styleRegEx = /(style=["|'])(.*)(["|'])/g,
                        classRegEx = /(class=["|'])(.*)(["|'])/g;

                    function createTheadCell(colModel, colName, lastCell, autowidth) {
                        var th = '<th role="columnheader" id="' + attrs.mpTable + '_' + colModel.name + '" title="' + escapeHtml(colName || colModel.label || colModel.name) + '"';

                        if (colModel.width || colModel.align || colModel.hidden === true) {
                            th += ' style="';
                            if (colModel.width) {
                                th += 'width:' + calculateCellWidth(colModel.width, autowidth) + ';';
                                th += 'min-width:' + calculateCellWidth(colModel.width, autowidth) + ';';
                                th += 'max-width:' + calculateCellWidth(colModel.width, autowidth) + ';';
                            }
                            if (colModel.hidden === true) th += ' display:none;';
                            if (lastCell) th += ' border-right: 1px solid #9FA8AF;';
                            th += '" ';
                        }


                        if (lastCell && classRegEx.test(th)) th = th.replace(classRegEx, '$1 lastCell $2$3');
                        else if (lastCell) th += ' class="lastCell"';

                        th += '>' + colName || colModel.label || colModel.name + '</th>';
                        return th;
                    }

                    function createTheadCells(colModels, colNames, autowidth) {
                        var ths = '';

                        for (var i = 0, l = colModels.length; i < l; i += 1) {
                            ths += createTheadCell(colModels[i], colNames[i], i === l - 1, autowidth);
                        }

                        return ths;
                    }

                    function createThead(colModels, colNames, autowidth) {
                        return '<thead><tr>' + createTheadCells(colModels, colNames, autowidth) + '</tr></thead>';
                    }

                    function createRdata(colModels, rawObject) {
                        var rdata = {};

                        for (var i = 0, l = colModels.length; i < l; i += 1) {
                            $parse(colModels[i].name).assign(rdata, $parse(colModels[i].name)(rawObject));
                        }

                        return rdata;
                    }

                    function createTbodyCell(rowId, rawObject, cm, rdata, lastCell, autowidth) {
                        var parsed = $parse(cm.name)(rawObject),
                            val = parsed ? parsed : '',
                            td = '<td role="gridcell" title="' + escapeHtml(val) + '" aria-describedby="' + attrs.mpTable + '_' + cm.name + '"';

                        if (cm.cellattr) td += cm.cellattr(rowId, val, rawObject, cm, rdata);

                        if (cm.align || cm.width || cm.hidden === true) {
                            var styles = '';

                            if (cm.align) styles += 'text-align:' + calculateCellAlign(cm.align) + ';';
                            if (cm.width) {
                                styles += 'width:' + calculateCellWidth(cm.width, autowidth) + ';';
                                styles += 'min-width:' + calculateCellWidth(cm.width, autowidth) + ';';
                                styles += 'max-width:' + calculateCellWidth(cm.width, autowidth) + ';';
                            }
                            if (cm.hidden === true) styles += ' display:none;';

                            if (lastCell && classRegEx.test(td)) td = td.replace(classRegEx, '$1 lastCell $2$3');
                            else if (lastCell) td += ' class="lastCell"';

                            if (styleRegEx.test(td)) td = td.replace(styleRegEx, '$1' + styles + '$2$3');
                            else td += ' style="' + styles + '"';
                        }

                        td += '>' + val + '</td>';
                        return td;
                    }

                    function findKey(colModels) {
                        var key = defaults.colModel.key;

                        for (var i = 0, l = colModels.length; i < l; i += 1) {
                            for (var prop in colModels[i]) {
                                if (colModels[i].hasOwnProperty(prop) && prop === 'key') key = colModels[i][key];
                            }
                        }

                        return key;
                    }

                    function createTbodyRow(colModels, model, oddRow, autowidth) {
                        var key = findKey(colModels),
                            rowId = $parse(key)(model),
                            tr = '<tr role="row" id="' + rowId + '"';

                        if (Utils.platform.isIE8() && oddRow) tr += ' class="oddRow"';

                        tr += '>';

                        for (var i = 0, l = colModels.length; i < l; i += 1) {
                            tr += createTbodyCell(rowId, model, colModels[i], createRdata(colModels, model), i === l - 1, autowidth);
                        }

                        tr += '</tr>';
                        return tr;
                    }

                    function createTbodyRows(colModels, data, autowidth) {
                        var trs = '';

                        for (var i = 0, l = data.length; i < l; i += 1) {
                            trs += createTbodyRow(colModels, data[i], i % 2 !== 0, autowidth);
                        }

                        return trs;
                    }

                    function createTbody(colModels, data, height, autowidth) {
                        var tbody = '<tbody';

                        if (height) tbody += ' style="height:' + calculateTableHeight(height) + ';"';

                        tbody += '>' + createTbodyRows(colModels, data, autowidth) + '</tbody>';
                        return tbody;
                    }

                    function manageIdKey(data) {
                        for (var i = 0, l = data.length; i < l; i += 1) {
                            data[i].id = (data[i].id || i + 1) + '';
                        }
                    }

                    function initTable(options, collection) {
                        var opts = angular.copy(angular.extend({}, defaults, options)),
                            data = angular.copy(collection),
                            key = findKey(options),
                            headTable = '<div class="headTable"><table',
                            bodyTable = '<div class="bodyTable" style="height:' + calculateTableHeight(opts.height) + ';"><table id="' + attrs.mpTable + '" height="auto"';

                        if (key === 'id' && data[0]) manageIdKey(data);

                        opts.data = data;

                        if (opts.autowidth) {
                            headTable += ' class="autowidth"';
                            bodyTable += ' class="autowidth"';
                            recalculateColModelWidths(opts.colModel);
                        } else {
                            headTable += ' width="' + calculateTableWidth(opts.width) + '"';
                            bodyTable += ' width="' + calculateTableWidth(opts.width) + '"';
                        }

                        headTable += '>' + createThead(opts.colModel, opts.colNames, opts.autowidth) + ' </table></div>';
                        bodyTable += '>' + createTbody(opts.colModel, opts.data, opts.height, opts.autowidth) + ' </table></div>';

                        elem[0].innerHTML = headTable + bodyTable;
                        if (!raw) $compile(elem.contents())(scope);
                    }

                    var stopWatching = scope.$watch('{options: ' + optionsExpression + ',data: ' + dataExpression + '}', function (obj) {
                        if (obj && obj.options && obj.data) {
                            initTable(obj.options, obj.data);
                            if (loadOnce) stopWatching();
                        }
                    }, true);
                }
            };
        }]);
}());

/*global angular, _ */
/**
    * @doc-component directive
    * @name gaiafrontend.directive.mpTabsSet
    * @description
    * This component has been migrated to "GAIA Site"
    * There you will find its documentation and several examples.
    * "GAIA Site" is an application created by the Architecture Area to learn and play with GAIA. Is available in RAS. Direct links are available below in this page.
    * @example
    <doc:example>
         <doc:source>
         label GAIA site direct links are:
         a(href='https://wportalinterno.es.mapfre.net/com.ibm.ram.repository.web/faces/_rlvid.jsp?_rap=!assetDetails&_rvip=/home.jsp&guid=13A33828-B921-8DC5-DEDA-8B8D7C0EBC81') Intranet /
         a(href='https://wportalinterno.mapfre.com/com.ibm.ram.repository.web/faces/_rlvid.jsp?_rap=!assetDetails&_rvip=/home.jsp&guid=13A33828-B921-8DC5-DEDA-8B8D7C0EBC81') Internet
         </doc:source>
    </doc:example>
*/
(function() {
    function mpTabsSet($window) {
        return {
            restrict: 'A',
            scope: {
                closeOthers: '='
            },
            link: function(scope, element, attrs) {
                var activetab = angular.element('ul.tabSet').find('li.active'),
                    tabs = angular.element('.tab-title'),
                    width = $window.innerWidth,
                    lastSelected;

                function getWindowSize() {
                    angular.element(window).resize(function(event) {
                        if (width > 800 && !scope.closeOthers && lastSelected) {
                            _.forEach(tabs, function(tabs) {
                                angular.element(tabs).removeClass('active');
                            });
                            lastSelected.addClass('active');
                        }
                    });
                }

                scope.$watch(width, function(newValue, oldValue) {
                    if (newValue !== oldValue)
                        getWindowSize();
                });

                angular.element(activetab).next().addClass('setDisplay');

                // The clicking action
                angular.element('.tab-title').on('click', function() {
                    if (!angular.element(this).hasClass('disabled')) {
                        if (!window.matchMedia('(max-width: 800px)').matches) {
                            angular.element('.tab_content').hide();
                            angular.element(this).next().show().prev().addClass('active').siblings().removeClass('active');
                        } else {
                            if (scope.closeOthers) {
                                _.forEach(tabs, function(tabs) {
                                    angular.element(tabs).removeClass('active');
                                })
                            }
                            angular.element(this).toggleClass('active');
                        }
                    }
                    lastSelected = angular.element(this);
                });

                getWindowSize();
            }
        }
    }

    (angular.module('mpTabsSet', []))
    .directive('mpTabsSet', ['$window', mpTabsSet])
}());

/*global angular */
angular.module('mpTimeDatepicker', [])
    /**
        * @doc-component directive
        * @name gaiafrontend.directive.mpTimeDatepicker
        * @description
        * This component has been migrated to "GAIA Site"
        * There you will find its documentation and several examples.
        * "GAIA Site" is an application created by the Architecture Area to learn and play with GAIA. Is available in RAS. Direct links are available below in this page.
        * @example
        <doc:example>
             <doc:source>
             label GAIA site direct links are:
             a(href='https://wportalinterno.es.mapfre.net/com.ibm.ram.repository.web/faces/_rlvid.jsp?_rap=!assetDetails&_rvip=/home.jsp&guid=13A33828-B921-8DC5-DEDA-8B8D7C0EBC81') Intranet /
             a(href='https://wportalinterno.mapfre.com/com.ibm.ram.repository.web/faces/_rlvid.jsp?_rap=!assetDetails&_rvip=/home.jsp&guid=13A33828-B921-8DC5-DEDA-8B8D7C0EBC81') Internet
             </doc:source>
        </doc:example>
    */
    .directive('mpTimeDatepicker', ['$parse', 'Utils', '$compile', function ($parse, Utils, $compile) {
        return {
            restrict: 'A',
            link: function(scope, element, attrs) {
                var dateWrapper,
                    timeWrapper,
                    id = attrs.mpTimeDatepickerId,
                    name = attrs.mpTimeDatepickerName,
                    model = attrs.mpTimeDatepickerModel,
                    timer = !!$parse(attrs.mpTimeDatepickerTimer)(),
                    dateOptions = $parse(attrs.mpTimeDatepickerDateData)(),
                    timeOptions = $parse(attrs.mpTimeDatepickerTimeData)(),
                    disabledFn = $parse(attrs.mpTimeDatepickerDisabled),
                    isIE8 = Utils.platform.isIE8(),
                    defaults = {
                        date: {
                            dateFormat: 'dd/MM/yyyy',
                            placeholder: 'dd/MM/yyyy'
                        },
                        time: {
                            timeFormat: 'HH:mm',
                            placeholder: 'HH:mm'
                        }
                    };

                function addOptions(input, options) {
                    angular.forEach(options, function(value, key) {
                        if (key.match(/placeholder|size|/g)) {
                            input.attr(Utils.string.toHyphens(key), value);
                        } else {
                            input.attr('data-' + Utils.string.toHyphens(key), value);
                        }
                    });
                }

                function addMask(element, type) {
                    var typeMask;
                    if (type === 'time') {
                        typeMask = defaults.time.timeFormat;
                    } else {
                        typeMask = defaults.date.dateFormat;
                    }
                    element.attr('mp-input-mask', typeMask.replace(new RegExp(/(\w)/g), '9'));
                }

                function createDate(formatoFecha) {
                    var iconDate = angular.element('<img>').attr( 'src', 'gaiafrontend/img/icon/calendar.png' ).addClass('glyphicon-calendar'),
                        inputDate = angular.element('<input>')
                            .addClass('form-control datepicker')
                            .attr('type', 'text')
                            .attr('id', id)
                            .attr('name', name)
                            .attr('size', '10')
                            .attr('ng-model', model)
                            .attr('ng-disabled', attrs.mpTimeDatepickerDisabled)
                            .attr('ng-required', attrs.mpTimeDatepickerRequired)
                            .attr('bs-datepicker', '');

                    angular.extend(defaults.date, dateOptions);
                    if(angular.isUndefined(dateOptions)){
                        defaults.date.placeholder = formatoFecha || defaults.date.dateFormat;
                        defaults.date.dateFormat = formatoFecha || defaults.date.dateFormat;
                    }else{
                        defaults.date.placeholder = formatoFecha || dateOptions.dateFormat || defaults.date.dateFormat;
                        defaults.date.dateFormat = formatoFecha || dateOptions.dateFormat || defaults.date.dateFormat;
                    }
                    addMask(inputDate, 'date');

                    dateWrapper = angular.element('<div>').addClass('validable');

                    if (timer) {
                        dateWrapper.addClass('col-md-6');
                    }


                    if (isIE8) {
                        defaults.date.delay = parseInt(defaults.date.delay, 10) > 100 ? defaults.date.delay : '100';
                        if (defaults.date.trigger !== 'manual') defaults.date.trigger = 'click';
                    }

                    addOptions(inputDate, defaults.date);

                    dateWrapper.append(inputDate);
                    dateWrapper.append(iconDate);
                }

                function createTime(formatoHora) {
                    if (!timer) {
                        return;
                    }

                    var iconTime = angular.element('<img>').attr( 'src', 'gaiafrontend/img/icon/time.png' ).addClass('glyphicon-time'),
                        inputTime = angular.element('<input>')
                            .addClass('form-control timepicker')
                            .attr('type', 'text')
                            .attr('id', id + '_time')
                            .attr('name', name + '_time')
                            .attr('size', '8')
                            .attr('ng-model', model)
                            .attr('ng-disabled', attrs.mpTimeDatepickerDisabled)
                            .attr('ng-required', attrs.mpTimeDatepickerRequired)
                            .attr('bs-timepicker', '');

                    angular.extend(defaults.time, timeOptions);
                    if(angular.isUndefined(timeOptions)){
                        defaults.time.placeholder = formatoHora || defaults.time.timeFormat;
                        defaults.time.timeFormat = formatoHora || defaults.time.timeFormat;
                    } else {
                        defaults.time.placeholder = formatoHora || timeOptions.timeFormat || defaults.time.timeFormat;
                        defaults.time.timeFormat = formatoHora || timeOptions.timeFormat || defaults.time.timeFormat;
                    }
                    addMask(inputTime, 'time');

                    timeWrapper = angular.element('<div>').addClass('col-md-6 validable');


                    if (isIE8) {
                        defaults.time.delay = parseInt(defaults.time.delay, 10) > 100 ? defaults.time.delay : '100';
                        if (defaults.time.trigger !== 'manual') defaults.time.trigger = 'click';
                    }

                    addOptions(inputTime, defaults.time);

                    timeWrapper.append(inputTime);
                    timeWrapper.append(iconTime);
                }

                function createWrapper() {
                    element.append(dateWrapper);
                    element.append(timeWrapper);
                }

                function createClass() {
                    element.addClass('timeDatepicker');
                }

                var dateInput = element.find('input').eq(0),
                    dateIcon = element.find('img.glyphicon-calendar').eq(0),
                    $datepicker = dateInput.data('$datepicker'),
                    $dateNgController = dateInput.data('$ngModelController'),
                    timeInput = element.find('input').eq(1),
                    timeIcon = element.find('img.glyphicon-time').eq(0),
                    $timepicker = timeInput.data('$timepicker'),
                    $timeNgController = timeInput.data('$ngModelController');

                function listenClick(element, $tooltipInstance) {
                    function iconClick(event) {
                        event.preventDefault();
                        event.stopPropagation();
                        if (!disabledFn(scope) && $tooltipInstance) $tooltipInstance.toggle();
                    }

                    element.on('click', iconClick);

                    return function () {
                        element.off('click', iconClick);
                    }
                }

                var unlistenDateIconClick = listenClick(dateIcon, $datepicker);
                var unlistenTimeIconClick = listenClick(timeIcon, $timepicker);

                if ($dateNgController) $dateNgController.$parsers.push(function (viewValue) {
                    // No date is not an invalid date. This parser overwrites bsDatepicker directive parser
                    if (viewValue === null || viewValue === '') {
                        $dateNgController.$setValidity('date', true);
                    }
                    return viewValue;
                });

                if ($timeNgController) $timeNgController.$parsers.push(function (viewValue) {
                    // No time is not an invalid date. This parser overwrites bsTimepickerpicker directive parser
                    if (viewValue === null || viewValue === '') {
                        $timeNgController.$setValidity('date', true);
                    }
                    return viewValue;
                });

                var watcherForModel = scope.$watch(function (scope) {
                    return $parse(attrs.mpTimeDatepickerModel)(scope);
                }, function (newValue) {
                    if (newValue && typeof newValue !== 'number') {
                        if(typeof newValue === 'string'){
                            newValue =  new Date(newValue);
                        }
                        scope[attrs.mpTimeDatepickerModel] = newValue.getTime();
                    }
                    if (angular.isUndefined(newValue)) {
                        if(!angular.isUndefined($datepicker)){
                            $datepicker.update(new Date());
                        }
                        element.addClass('only-today');
                    } else {
                        element.removeClass('only-today');
                    }
                });

                scope.$on('$destroy', function () {
                    unlistenDateIconClick();
                    $datepicker = null;
                    dateIcon = null;
                    dateInput = null;
                    unlistenTimeIconClick();
                    $timepicker = null;
                    timeIcon = null;
                    timeInput = null;
                    watcherForModel();
                });

                var formatoFecha;
                angular.forEach($parse(attrs.mpTimeDatepickerDateData)(), function(value, key) {
                    if (key==='dateFormat') {
                        formatoFecha = value;
                    }
                });

                var valorFormatoFecha = $parse(formatoFecha)(scope);


                var valorFormatoHora
                if (timer) {
                    var formatoHora;
                    angular.forEach($parse(attrs.mpTimeDatepickerTimeData)(), function(value, key) {
                        if (key==='timeFormat') {
                            formatoHora = value;
                        }
                    });

                    if(formatoHora && formatoHora.indexOf(':') > 0){
                        valorFormatoHora = formatoHora;
                    }else{
                        valorFormatoHora = $parse(formatoHora)(scope);
                    }
                }

                if (!element.contents().length) {
                    createDate(valorFormatoFecha);
                    createTime(valorFormatoHora);
                    createWrapper();
                    createClass();
                    $compile(element)(scope);
                }

            }
        };
    }]);

/**
    * @doc-component directive
    * @name gaiafrontend.directive.mpToLowerCase
    * @description
    * This component has been migrated to "GAIA Site"
    * There you will find its documentation and several examples.
    * "GAIA Site" is an application created by the Architecture Area to learn and play with GAIA. Is available in RAS. Direct links are available below in this page.
    * @example
    <doc:example>
         <doc:source>
         label GAIA site direct links are:
         a(href='https://wportalinterno.es.mapfre.net/com.ibm.ram.repository.web/faces/_rlvid.jsp?_rap=!assetDetails&_rvip=/home.jsp&guid=13A33828-B921-8DC5-DEDA-8B8D7C0EBC81') Intranet /
         a(href='https://wportalinterno.mapfre.com/com.ibm.ram.repository.web/faces/_rlvid.jsp?_rap=!assetDetails&_rvip=/home.jsp&guid=13A33828-B921-8DC5-DEDA-8B8D7C0EBC81') Internet
         </doc:source>
    </doc:example>
*/
/*global angular */
angular.module('mpToLowerCase', [])
    .directive('mpToLowerCase', function() {
        return {
            require: 'ngModel',
            link: function(_scope, _element, _attributes, ngModelCtrl) {
                function lowerCase(inputValue) {
                    var lowerCased = angular.isString(inputValue) ? inputValue.toLowerCase() : inputValue;

                    if (lowerCased !== inputValue) {
                        ngModelCtrl.$setViewValue(lowerCased);
                        ngModelCtrl.$render();
                    }

                    return lowerCased;
                }

                ngModelCtrl.$parsers.push(lowerCase);
                ngModelCtrl.$formatters.push(lowerCase);
            }
        };
    });

/**
    * @doc-component directive
    * @name gaiafrontend.directive.mpToUpperCase
    * @description
    * This component has been migrated to "GAIA Site"
    * There you will find its documentation and several examples.
    * "GAIA Site" is an application created by the Architecture Area to learn and play with GAIA. Is available in RAS. Direct links are available below in this page.
    * @example
    <doc:example>
         <doc:source>
         label GAIA site direct links are:
         a(href='https://wportalinterno.es.mapfre.net/com.ibm.ram.repository.web/faces/_rlvid.jsp?_rap=!assetDetails&_rvip=/home.jsp&guid=13A33828-B921-8DC5-DEDA-8B8D7C0EBC81') Intranet /
         a(href='https://wportalinterno.mapfre.com/com.ibm.ram.repository.web/faces/_rlvid.jsp?_rap=!assetDetails&_rvip=/home.jsp&guid=13A33828-B921-8DC5-DEDA-8B8D7C0EBC81') Internet
         </doc:source>
    </doc:example>
*/
/*global angular */
angular.module('mpToUpperCase', [])
    .directive('mpToUpperCase', function() {
        return {
            require: 'ngModel',
            link: function(_scope, _element, _attributes, ngModelCtrl) {
                function upperCase(inputValue) {
                    var upperCased = angular.isString(inputValue) ? inputValue.toUpperCase() : inputValue;

                    if (upperCased !== inputValue) {
                        ngModelCtrl.$setViewValue(upperCased);
                        ngModelCtrl.$render();
                    }

                    return upperCased;
                }

                ngModelCtrl.$parsers.push(upperCase);
                ngModelCtrl.$formatters.push(upperCase);
            }
        };
    });

/*global angular*/
/*TODO: REVIEW*/
angular.module('mpTooltip', [])
    /**
     * @doc-component directive
     * @name gaiafrontend.directive.mpTooltip
     * @param {string} mp-tooltip Tooltip to display. The directive will create the title attribute with the contents of mp-tooltip.
     * @param {string=} mp-tooltip-type This attribute indicates the type of tooltip to display. The "error" will be used for validation tooltips.
     * @param {string=} mp-tooltip-options This optional attribute to customize the plugin options that activates the tooltip.
     * @description
     * This auxiliary component displays a tooltip when you mouseover an item. By default the tooltip is generated with the following properties that determine its position:
     * '''json
     *    position': {
     *        'my': 'center bottom-20',
     *        'at': 'center'
     *    }
     * '''
     * @example
       <doc:example module="mpTooltip">
        <doc:source>
        tooltipOptions = {'position': {'my': "center bottom-20", 'at': "left+60" }}
        form(ng-model="tooltipForm", name="tooltipForm")
          label(for="inputTooltip", mp-tooltip="'Tooltip en label'", mp-tooltip-options=JSON.stringify(tooltipOptions)) Label del input tooltip
          input#inputTooltip(type="text",mp-tooltip="'Tooltip en input'", ng-model="tooltipForm.inputTooltip")
        a.link(href="#", mp-tooltip="'Tooltip en enlace'") Tooltip
        </doc:source>
       </doc:example>
     */
    .directive('mpTooltip', ['Utils', function (Utils) {
        return {
            link: function(scope, elm, attrs) {
                var type = attrs.mpTooltipType,
                    options = attrs.mpTooltipOptions,
                    tooltipOptions = {
                        'position': {
                            'my': 'center bottom-20',
                            'at': 'center',
                            'collision': 'fit'
                        }
                    },
                    errorTooltipOptions = {
                        'position': {
                            'my': 'left-40 bottom-20',
                            'at': 'center',
                            'collision': 'fit'
                        }
                    };
                var unregisterWatch = scope.$watch(attrs.mpTooltip, function(title) {

                    /* Adds the attribute title in element like the jquery component */
                    elm.attr('title', title);

                    /* Adds custom options to tooltip*/
                    if (options) {
                        angular.extend(tooltipOptions, JSON.parse(attrs.mpTooltipOptions));
                    }

                    if (type) {
                        angular.extend(tooltipOptions, {
                            'tooltipClass': attrs.mpTooltipType
                        });
                        if (type === 'error') {
                            angular.extend(tooltipOptions, errorTooltipOptions);
                        }
                    }

                    tooltipOptions.content = title;

                    /* Runs the tooltip plugin */
                    elm.tooltip(tooltipOptions);

                }, true);

                function resetTooltip() {
                    elm.tooltip('close');
                    elm.tooltip(tooltipOptions, 'open');
                }
                if (Utils.platform.isTactile()) {
                    window.addEventListener('orientationchange', resetTooltip, false);
                }

                elm.on('$destroy', function () {
                    unregisterWatch();
                });
            }
        };
    }]);

/*global angular*/
angular.module('mpTooltipError', [])
    .directive('mpTooltipError', function () {
        return {
            template: function (element, attrs) {
                return  '<div class="error-alert">' +
                            '<img src="gaiafrontend/img/icons/contrlAmrll_S.png" ' +
                            // 'mp-tooltip="' + formCtrl.$name + '[\'' + ngModelCtrl.$name + '\'].$errorText" ' +
                            'mp-tooltip="' + attrs.mpTooltipError + '.$errorText" ' +
                            'mp-tooltip-type="error" />' +
                        '</div>';
            },
            replace: true,
            require: '^?form',
            scope: true,
            link: function(scope, element, attrs, formCtrl) {
                if (formCtrl) scope[attrs.mpTooltipError] = formCtrl[attrs.mpTooltipError];
            }
        };
    });

/*global angular */
/*
 * A directive that allows creation of custom onclick handlers that are defined as angular
 * expressions and are compiled and executed within the current scope.
 *
 * Events that are handled via these handler are always configured not to propagate further.
 */
angular.module('mpTouch', ['utils'])
    .config(['$compileProvider', 'Utils', function ($compileProvider, Utils) {
        var toCamelCase = Utils.string.toCamelCase,
            mpTouchEventDirectives = {};
        /**
         * @doc-component directive
         * @name gaiafrontend.directive.mpTouchstart
         * @description
         * The mpTouchstart directive allows you to specify custom behavior when an element is begining to being touched.
         *
         * Other touch events are supported through their respective directives.
         * @param {expression} mpTouchstart Expression to evaluate when the user makes contact with the touch surface. Event object is available as `$event`.
         * @example
           <doc:example module="mpValuesList">
             <doc:source>
             script
                function TouchEventsCtrl() {
                    $scope.output = 'Not touched.';

                    this.touchStarting = function () {
                        $scope.output = 'Touch starting...';
                    };
                    this.touchEnding = function () {
                        $scope.output = 'Touch ended.';
                    };
                }
                TouchEventsCtrl.$inject = ['$scope'];
             div(ng-controller="TouchEvenetsCtrl as Touch")
                pre {{output}}
                button.btn.btn-default(type="button", mp-touchstart="touchStarting()", mp-touchend="touchEnding()") Touch me
             </doc:source>
           </doc:example>
         */
        angular.forEach('touchstart touchmove touchend touchenter touchleave touchcancel'.split(' '), function (name) {
            var directiveName = toCamelCase('mp-' + name);
            mpTouchEventDirectives[directiveName] = ['$parse', function ($parse) {
                return {
                    compile: function (cElement, cAttr) {
                        var fn = $parse(cAttr[directiveName]);
                        return function postLink (scope, lElement) {
                            lElement.on(angular.lowercase(name), function(event) {
                                scope.$apply(function() {
                                    fn(scope, {
                                        $event: event
                                    });
                                });
                            });
                        };
                    }
                };
            }];
        });

        $compileProvider.directive(mpTouchEventDirectives);
    }]);

/*global angular, _ */
/*DEPRECATED*/
angular.module('mpTree', ['utils'])
    /**
     * @doc-component directive
     * @name gaiafrontend.directive.mpTree
     * @description
     * DEPRECATED
     * If you need this component ask for it through UX department
     */
    .directive('mpTree', ['Loader',
        function(Loader) {
            var loadPlugin = Loader.load;

            function writeJsonList(currentElement, listElements, text) {
                var i = 0;
                for (i = 0; i < listElements.length; i = i + 1) {
                    if (listElements[i].li.ul) {
                        currentElement.append('<li><a href="">' + listElements[i].li.ul[0].li + '</a><ul></ul></li>');
                        writeJsonList(currentElement.find('li ul'), listElements[i].li.ul, listElements[i].li.ul[0].li);
                    } else {
                        if (listElements[i].li !== text) {
                            text = '';
                            if (listElements[i]['class'] && listElements[i].href) {
                                currentElement.append('<li class=' + listElements[i]['class'] + '><a href=' + listElements[i].href + '>' + listElements[i].li + '</a> </li>');
                            } else if (listElements[i]['class']) {
                                currentElement.append('<li class=' + listElements[i]['class'] + '><a href="">' + listElements[i].li + '</a> </li>');
                            } else if (listElements[i].href) {
                                currentElement.append('<li><a href=' + listElements[i].href + '>' + listElements[i].li + '</a> </li>');
                            } else {
                                currentElement.append('<li><a href="">' + listElements[i].li + '</a> </li>');
                            }
                        }
                    }
                }
            }

            function readJsonListElements(currentElement, argument) {
                _.each(argument, function(datos) {
                    writeJsonList(currentElement, datos);
                });
            }
            return {
                templateUrl: 'gaiafrontend/html/tree.html',
                link: function(scope, elm, attrs) {

                    var treeElements = attrs.mpTree;
                    //console.log(JSON.parse(treeElements));
                    elm.find('.sampleTree').append('<ul></ul>');

                    angular.forEach(angular.fromJson(treeElements), function(datos) {
                        readJsonListElements(elm.find('.sampleTree ul'), datos);
                    });

                    function drawTree() {
                        elm.find('.sampleTree').jstree();
                    }

                    loadPlugin('jquery.cookie.js').then(function() {
                        loadPlugin('jquery.jstree.js').then(drawTree);
                    });

                }
            };
        }]);

/*global angular, nextUid */
/* jshint es3: false */
angular.module('mpType', [])
    // This directive is a copy&paste from the AngularJS input directive.
    // Created because IE8 do not support some HTML5 input types.
    .directive('mpType', ['$sniffer', '$browser',
        function($sniffer, $browser) {
            var URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/,
                EMAIL_REGEXP = /^[a-z0-9!#$%&'*+/=?^_`{|}~.-]+@[a-z0-9-]+(\.[a-z0-9-]+)*$/i,
                NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))\s*$/,
                inputType;
            function int(str) {
                return parseInt(str, 10);
            }

            function isWindow(obj) {
                return obj && obj.document && obj.location && obj.alert && obj.setInterval;
            }

            function isScope(obj) {
                return obj && obj.$evalAsync && obj.$watch;
            }

            function toJsonReplacer(key, value) {
                var val = value;

                if (typeof key === 'string' && key.charAt(0) === '$') {
                    val = undefined;
                } else if (isWindow(value)) {
                    val = '$WINDOW';
                } else if (value && document === value) {
                    val = '$DOCUMENT';
                } else if (isScope(value)) {
                    val = '$SCOPE';
                }

                return val;
            }

            function toJson(obj, pretty) {
                if (typeof obj === 'undefined') return undefined;
                return JSON.stringify(obj, toJsonReplacer, pretty ? '  ' : null);
            }

            function minErr(module) {
                return function() {
                    var code = arguments[0],
                        prefix = '[' + (module ? module + ':' : '') + code + '] ',
                        template = arguments[1],
                        templateArgs = arguments,
                        stringify = function(obj) {
                            if (typeof obj === 'function') {
                                return obj.toString().replace(/ \{[\s\S]*$/, '');
                            } else if (typeof obj === 'undefined') {
                                return 'undefined';
                            } else if (typeof obj !== 'string') {
                                return JSON.stringify(obj);
                            }
                            return obj;
                        },
                        message, i;

                    message = prefix + template.replace(/\{\d+\}/g, function(match) {
                        var index = +match.slice(1, -1),
                            arg;

                        if (index + 2 < templateArgs.length) {
                            arg = templateArgs[index + 2];
                            if (typeof arg === 'function') {
                                return arg.toString().replace(/ ?\{[\s\S]*$/, '');
                            } else if (typeof arg === 'undefined') {
                                return 'undefined';
                            } else if (typeof arg !== 'string') {
                                return toJson(arg);
                            }
                            return arg;
                        }
                        return match;
                    });

                    message = message + '\nhttp://errors.angularjs.org/1.2.16/' +
                        (module ? module + '/' : '') + code;
                    for (i = 2; i < arguments.length; i++) {
                        message = message + (i === 2 ? '?' : '&') + 'p' + (i - 2) + '=' +
                            encodeURIComponent(stringify(arguments[i]));
                    }

                    return new Error(message);
                };
            }

            function isObject(value) {
                return angular.isObject(value);
            }

            function isString(value) {
                return angular.isString(value);
            }

            function isNumber(value) {
                return angular.isNumber(value);
            }

            function isUndefined(value) {
                return typeof value === 'undefined';
            }

            function lowercase(string) {
                return isString(string) ? string.toLowerCase() : string;
            }

            function startingTag(element) {
                element = angular.element(element).clone();
                try {
                    // turns out IE does not let you set .html() on elements which
                    // are not allowed to have children. So we just ignore it.
                    element.empty();
                } catch (e) {}
                // As Per DOM Standards
                var TEXT_NODE = 3;
                var elemHtml = angular.element('<div>').append(element).html();
                try {
                    return element[0].nodeType === TEXT_NODE ? lowercase(elemHtml) :
                        elemHtml.
                    match(/^(<[^>]+>)/)[1].
                    replace(/^<([\w\-]+)/, function(match, nodeName) {
                        return '<' + lowercase(nodeName);
                    });
                } catch (e) {
                    return lowercase(elemHtml);
                }

            }

            var trim = (function() {
                // native trim is way faster: http://jsperf.com/angular-trim-test
                // but IE doesn't have it... :-(
                // TODO: we should move this into IE/ES5 polyfill
                if (!String.prototype.trim) {
                    return function(value) {
                        return isString(value) ? value.replace(/^\s\s*/, '').replace(/\s\s*$/, '') : value;
                    };
                }
                return function(value) {
                    return isString(value) ? value.trim() : value;
                };
            })();

            function toBoolean(value) {
                if (typeof value === 'function') {
                    value = true;
                } else if (value && value.length !== 0) {
                    var v = lowercase('' + value);
                    value = !(v === 'f' || v === '0' || v === 'false' || v === 'no' || v === 'n' || v === '[]');
                } else {
                    value = false;
                }
                return value;
            }

            function validate(ctrl, validatorName, validity, value) {
                ctrl.$setValidity(validatorName, validity);
                return validity ? value : undefined;
            }

            function addNativeHtml5Validators(ctrl, validatorName, element) {
                var validity = element.prop('validity');
                if (isObject(validity)) {
                    var validator = function(value) {
                        // Don't overwrite previous validation, don't consider valueMissing to apply (ng-required can
                        // perform the required validation)
                        if (!ctrl.$error[validatorName] && (validity.badInput || validity.customError ||
                                validity.typeMismatch) && !validity.valueMissing) {
                            ctrl.$setValidity(validatorName, false);
                            return;
                        }
                        return value;
                    };
                    ctrl.$parsers.push(validator);
                }
            }

            function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
                var validity = element.prop('validity');
                // In composition mode, users are still inputing intermediate text buffer,
                // hold the listener until composition is done.
                // More about composition events: https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent
                if (!$sniffer.android) {
                    var composing = false;

                    element.on('compositionstart', function() {
                        composing = true;
                    });

                    element.on('compositionend', function() {
                        composing = false;
                        listener();
                    });
                }

                var listener = function() {
                    if (composing) return;
                    var value = element.val();

                    // By default we will trim the value
                    // If the attribute ng-trim exists we will avoid trimming
                    // e.g. <input ng-model="foo" ng-trim="false">
                    if (toBoolean(attr.ngTrim || 'T')) {
                        value = trim(value);
                    }

                    if (ctrl.$viewValue !== value ||
                        // If the value is still empty/falsy, and there is no `required` error, run validators
                        // again. This enables HTML5 constraint validation errors to affect Angular validation
                        // even when the first character entered causes an error.
                        (validity && value === '' && !validity.valueMissing)) {
                        if (scope.$$phase) {
                            ctrl.$setViewValue(value);
                        } else {
                            scope.$apply(function() {
                                ctrl.$setViewValue(value);
                            });
                        }
                    }
                };

                // if the browser does support "input" event, we are fine - except on IE9 which doesn't fire the
                // input event on backspace, delete or cut
                if ($sniffer.hasEvent('input')) {
                    element.on('input', listener);
                } else {
                    var timeout;

                    var deferListener = function() {
                        if (!timeout) {
                            timeout = $browser.defer(function() {
                                listener();
                                timeout = null;
                            });
                        }
                    };

                    element.on('keydown', function(event) {
                        var key = event.keyCode;

                        // ignore
                        //    command            modifiers                   arrows
                        if (key === 91 || (15 < key && key < 19) || (37 <= key && key <= 40)) return;

                        deferListener();
                    });

                    // if user modifies input value using context menu in IE, we need "paste" and "cut" events to catch it
                    if ($sniffer.hasEvent('paste')) {
                        element.on('paste cut', deferListener);
                    }
                }

                // if user paste into input using mouse on older browser
                // or form autocomplete on newer browser, we need "change" event to catch it
                element.on('change', listener);

                ctrl.$render = function() {
                    element.val(ctrl.$isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue);
                };

                // pattern validator
                var pattern = attr.ngPattern,
                    patternValidator,
                    match;

                if (pattern) {
                    var validateRegex = function(regexp, value) {
                        return validate(ctrl, 'pattern', ctrl.$isEmpty(value) || regexp.test(value), value);
                    };
                    match = pattern.match(/^\/(.*)\/([gim]*)$/);
                    if (match) {
                        pattern = new RegExp(match[1], match[2]);
                        patternValidator = function(value) {
                            return validateRegex(pattern, value);
                        };
                    } else {
                        patternValidator = function(value) {
                            var patternObj = scope.$eval(pattern);

                            if (!patternObj || !patternObj.test) {
                                throw minErr('ngPattern')('noregexp',
                                    'Expected {0} to be a RegExp but was {1}. Element: {2}', pattern,
                                    patternObj, startingTag(element));
                            }
                            return validateRegex(patternObj, value);
                        };
                    }

                    ctrl.$formatters.push(patternValidator);
                    ctrl.$parsers.push(patternValidator);
                }

                // min length validator
                if (attr.ngMinlength) {
                    var minlength = int(attr.ngMinlength);
                    var minLengthValidator = function(value) {
                        return validate(ctrl, 'minlength', ctrl.$isEmpty(value) || value.length >= minlength, value);
                    };

                    ctrl.$parsers.push(minLengthValidator);
                    ctrl.$formatters.push(minLengthValidator);
                }

                // max length validator
                if (attr.ngMaxlength) {
                    var maxlength = int(attr.ngMaxlength);
                    var maxLengthValidator = function(value) {
                        return validate(ctrl, 'maxlength', ctrl.$isEmpty(value) || value.length <= maxlength, value);
                    };

                    ctrl.$parsers.push(maxLengthValidator);
                    ctrl.$formatters.push(maxLengthValidator);
                }
            }

            function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
                textInputType(scope, element, attr, ctrl, $sniffer, $browser);

                ctrl.$parsers.push(function(value) {
                    var empty = ctrl.$isEmpty(value);
                    if (empty || NUMBER_REGEXP.test(value)) {
                        ctrl.$setValidity('number', true);
                        return value === '' ? null : (empty ? value : parseFloat(value));
                    } else {
                        ctrl.$setValidity('number', false);
                        return undefined;
                    }
                });

                addNativeHtml5Validators(ctrl, 'number', element);

                ctrl.$formatters.push(function(value) {
                    return ctrl.$isEmpty(value) ? '' : '' + value;
                });

                if (attr.min) {
                    var minValidator = function(value) {
                        var min = parseFloat(attr.min);
                        return validate(ctrl, 'min', ctrl.$isEmpty(value) || value >= min, value);
                    };

                    ctrl.$parsers.push(minValidator);
                    ctrl.$formatters.push(minValidator);
                }

                if (attr.max) {
                    var maxValidator = function(value) {
                        var max = parseFloat(attr.max);
                        return validate(ctrl, 'max', ctrl.$isEmpty(value) || value <= max, value);
                    };

                    ctrl.$parsers.push(maxValidator);
                    ctrl.$formatters.push(maxValidator);
                }

                ctrl.$formatters.push(function(value) {
                    return validate(ctrl, 'number', ctrl.$isEmpty(value) || isNumber(value), value);
                });
            }

            function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
                textInputType(scope, element, attr, ctrl, $sniffer, $browser);

                var urlValidator = function(value) {
                    return validate(ctrl, 'url', ctrl.$isEmpty(value) || URL_REGEXP.test(value), value);
                };

                ctrl.$formatters.push(urlValidator);
                ctrl.$parsers.push(urlValidator);
            }

            function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
                textInputType(scope, element, attr, ctrl, $sniffer, $browser);

                var emailValidator = function(value) {
                    return validate(ctrl, 'email', ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value), value);
                };

                ctrl.$formatters.push(emailValidator);
                ctrl.$parsers.push(emailValidator);
            }

            function radioInputType(scope, element, attr, ctrl) {
                // make the name unique, if not defined
                if (isUndefined(attr.name)) {
                    element.attr('name', nextUid());
                }

                element.on('click', function() {
                    if (element[0].checked) {
                        scope.$apply(function() {
                            ctrl.$setViewValue(attr.value);
                        });
                    }
                });

                ctrl.$render = function() {
                    var value = attr.value;
                    element[0].checked = (value === ctrl.$viewValue);
                };

                attr.$observe('value', ctrl.$render);
            }

            function checkboxInputType(scope, element, attr, ctrl) {
                var trueValue = attr.ngTrueValue,
                    falseValue = attr.ngFalseValue;

                if (!isString(trueValue)) trueValue = true;
                if (!isString(falseValue)) falseValue = false;

                element.on('click', function() {
                    scope.$apply(function() {
                        ctrl.$setViewValue(element[0].checked);
                    });
                });

                ctrl.$render = function() {
                    element[0].checked = ctrl.$viewValue;
                };

                // Override the standard `$isEmpty` because a value of `false` means empty in a checkbox.
                ctrl.$isEmpty = function(value) {
                    return value !== trueValue;
                };

                ctrl.$formatters.push(function(value) {
                    return value === trueValue;
                });

                ctrl.$parsers.push(function(value) {
                    return value ? trueValue : falseValue;
                });
            }

            inputType = {
                'text': textInputType,
                'number': numberInputType,
                'url': urlInputType,
                'email': emailInputType,
                'radio': radioInputType,
                'checkbox': checkboxInputType,
                'hidden': angular.noop,
                'button': angular.noop,
                'submit': angular.noop,
                'reset': angular.noop,
                'file': angular.noop
            };

            return {
                require: '?ngModel',
                link: function(scope, element, attributes, ngModelCtrl) {
                    if (ngModelCtrl) {
                        (inputType[lowercase(attributes.mpType)] || inputType.text)(scope, element, attributes, ngModelCtrl, $sniffer, $browser);
                    }
                }
            };
        }
    ]);
/* jshint es3: true */

/*global angular */
angular.module('mpTypeahead', ['utils'])
    /*TODO: Use $typeahead to build a custom directive. Do not wrap bsTypeahead.*/
    /**
     * @doc-component directive
     * @name gaiafrontend.directive.mpTypeahead
     * @param {expression} mp-typeahead-model The selected suggestion will be assigned to the result of the expression.
     * @param {expression} mp-typeahead-options Expression `ngOptions` alike to dynamically generate suggestions. See [ngOptions](https://code.angularjs.org/1.2.16/docs/api/ng/directive/select#-ngoptions-) documentation for more info.
     * @param {expression=} mp-typeahead-config The result of evaluating this expression should be an options object. Supported options are listed [here](http://mgcrea.github.io/angular-strap/##typeaheads-usage).
     * @description
     * This directive allows you to display an input that shows suggestions while typing.
     *
     * This directive wraps the AngularStrap `bs-typeahead` directive.
     * @example
       <doc:example>
        <doc:source>
        script
            function TypeaheadCtrl ($scope, $http) {
                $scope.selectedState = '';
                $scope.states = ['Alabama', 'Alaska', 'Arizona', 'Arkansas', 'California', 'Colorado', 'Connecticut', 'Delaware', 'Florida', 'Georgia', 'Hawaii', 'Idaho', 'Illinois', 'Indiana', 'Iowa', 'Kansas', 'Kentucky', 'Louisiana', 'Maine', 'Maryland', 'Massachusetts', 'Michigan', 'Minnesota', 'Mississippi', 'Missouri', 'Montana', 'Nebraska', 'Nevada', 'New Hampshire', 'New Jersey', 'New Mexico', 'New York', 'North Dakota', 'North Carolina', 'Ohio', 'Oklahoma', 'Oregon', 'Pennsylvania', 'Rhode Island', 'South Carolina', 'South Dakota', 'Tennessee', 'Texas', 'Utah', 'Vermont', 'Virginia', 'Washington', 'West Virginia', 'Wisconsin', 'Wyoming'];

                $scope.selectedIcon = '';
                $scope.icons = [{
                    value: 'Gear',
                    label: '<i class="glyphicon glyphicon-cog"></i> Gear'
                }, {
                    value: 'Globe',
                    label: '<i class="glyphicon glyphicon-globe"></i> Globe'
                }, {
                    value: 'Heart',
                    label: '<i class="glyphicon glyphicon-heart"></i> Heart'
                }, {
                    value: 'Camera',
                    label: '<i class="glyphicon glyphicon-camera"></i> Camera'
                }];

                $scope.selectedAddress = '';
                $scope.getAddress = function(viewValue) {
                    var params = {
                        address: viewValue,
                        sensor: false
                    };
                    return $http.get('http://maps.googleapis.com/maps/api/geocode/json', {
                        params: params
                    }).then(function(res) {
                        return res.data.results;
                    });
                };

            }
            TypeaheadCtrl.$inject = ['$scope', '$http'];
        div(ng-controller="TypeaheadCtrl")
            form.form-horizontal(role="form", name="typeaheadForm")
                .row
                    .form-group.col-md-6
                        label.control-label.col-md-2(for="state") State
                        .validable.col-md-10
                            input.form-control(type="text", id="state", name="state", placeholder="Enter state", mp-typeahead, mp-typeahead-model="selectedState", mp-typeahead-options="state for state in states")
                    .form-group.col-md-6
                        label.control-label.col-md-2(for="icon") Icon
                        .validable.col-md-10
                            input.form-control(type="text", id="icon", name="icon", placeholder="Enter icon", required="required", mp-typeahead, mp-typeahead-model="selectedIcon", mp-typeahead-options="icon as icon.label for icon in icons", mp-typeahead-config="{minLength: 0, html: 1}")
                .row
                    .form-group.col-md-6
                        label.control-label.col-md-2(for="address") Address
                        .validable.col-md-10
                            input.form-control(type="text", id="address", name="address", placeholder="Enter address", mp-typeahead, mp-typeahead-model="selectedAddress", mp-typeahead-options="address.formatted_address as address.formatted_address for address in getAddress($viewValue)")
                        p.col-md-offset-2.col-md-10.help-block (async via maps.googleapis.com)
        </doc:source>
       </doc:example>
     */
    .directive('mpTypeahead', ['$parse', '$compile', 'Utils', function ($parse, $compile, Utils) {
        return {
            priority: 9999,
            terminal: true,
            link: function (scope, element, attrs) {
                var config = $parse(attrs.mpTypeaheadConfig)(scope) || {},
                    attributes = $parse(attrs.mpTypeaheadAttributes)(scope) || {};

                element.attr('bs-typeahead', attrs.mpTypeahead);
                element.attr('ng-model', attrs.mpTypeaheadModel);
                element.attr('ng-options', attrs.mpTypeaheadOptions);

                // FIX: IE8 needs a minimum delay to work as intended
                config.delay = !angular.isDefined(config.delay) || +config.delay < 100 ? '100' : config.delay;
                // FIX: Watch options when used by mpOptionsList
                config.watchOptions = !!attrs.mpOptionsList;
                angular.forEach(config, function (value, option) {
                    element.attr('data-' + Utils.string.toHyphens(option), value);
                });

                // TODO: REVIEW
                // Because of mpOptionsList directive
                // If mpOptionsList assign these attrs they will be compiled twice
                // and some directives might not work as intended (ngClick expression will be evaluated twice)
                angular.forEach(attributes, function (value, attr) {
                    element.attr(Utils.string.toHyphens(attr), value);
                });

                angular.forEach(attrs.$attr, function (attr) {
                    if (attr.indexOf('mp-typeahead') > -1) element.removeAttr(attr);
                });

                $compile(element)(scope);
            }
        };
    }]);

/*global angular, _ */
angular.module('mpValidations', [])
    .constant('VALIDATIONS', [
        'required',
        'minlength',
        'maxlength',
        'type',
        'number',
        'min',
        'max',
        'url',
        'email',
        'pattern',
        'iban',
        'ccc',
        'date',
        'document'//,
        // 'past',
        // 'future',
        // 'digits',
        // 'decimalMin',
        // 'decimalMax'
    ])
    .constant('VALIDATION_ATTRIBUTES', [
        'required',
        'ng-required',
        'ng-minlength',
        'ng-maxlength',
        'ng-pattern',
        'mp-type',
        'min',
        'max'
    ])
    /**
     * @doc-component directive
     * @name gaiafrontend.directive.mpValidations
     * @param {string} mp-validations A JSON with the validations to apply to the form.
     * @param {string} mp-validations-model The model of the `form`. The one is going to be sent. The directive will create a 'gaiaFormName' property with the form name.
     * @param {string=} mp-validations-watch Angular expression we want to watch. When this expression changes its value the `form` is re-compiled applying the new value as validations to the `form`.
     * @description
     * This directive is used to validate forms and display input errors.
     * The form must have a `name` attribute. The inputs we want to validate must have a `name` aswell and its value must be the path of its `ngModel` from `mpValidationsModel`.
     * @example
       <doc:example module="mpValidations">
        <doc:source>
        validations = {"name":{"notNull":true},"secondLastName":{"notNull":true,"size":{"min":3,"max":10}}}
        div(ng-controller="UserController")
            button.btn.btn-danger(type="button", ng-click="changeValidation()") Change validation
            form.form-horizontal(name='userForm', mp-validations-model='user', mp-validations=JSON.stringify(validations), mp-validations-watch="validationsWatch")
                h3 User info
                .control-group
                    label.control-label(for="name") Name
                    .controls
                        input#name(type="text", name="name", ng-model="user.name", placeholder="John")
                .control-group
                    label.control-label(for="secondLastName") Last name
                    .controls
                        input#secondLastName(type="text", name="secondLastName", ng-model="user.secondLastName", placeholder="Doe")
                .form-actions
                    button.btn.btn-danger(type="button", ng-disabled="!userForm.$valid", ng-click="updateUserInfo()") Update
                h3 Model sent
                .control-group
                    pre(ng-bind="userModelSent | json")
            script
                function UserController($scope) {
                    var flag = true;

                    $scope.changeValidation = function() {
                        var originalValidation = {
                            "name": {
                                "notNull": true
                            },
                            "secondLastName": {
                                "notNull": true,
                                "size": {
                                    "min": 3,
                                    "max": 10
                                }
                            }
                        }, newValidation = {
                            "name": {},
                            "secondLastName": {
                                "notNull": true
                            }
                        };

                        flag = !flag;

                        $scope.validationsWatch = flag ? originalValidation : newValidation;
                    }

                    $scope.updateUserInfo = function() {
                        $scope.userModelSent = angular.copy($scope.user);
                    }
                }

                UserController.$inject = ['$scope'];
        </doc:source>
       </doc:example>
     */
    .directive('mpValidations', ['$parse', '$compile', 'VALIDATION_ATTRIBUTES',
        function($parse, $compile, VALIDATION_ATTRIBUTES) {
            var oldValidations;

            function addFormControlValidation(formControl, validation) {
                if (validation.notNull) {
                    formControl.attr('required', true);
                }

                if (validation.size) {
                    if (validation.size.min) {
                        formControl.prop('type', 'text');
                        formControl.attr('ng-minlength', validation.size.min);
                    }
                    if (validation.size.max) {
                        formControl.prop('type', 'text');
                        formControl.attr('ng-maxlength', validation.size.max);
                    }
                }

                if (validation.email) {
                    formControl.prop('type', 'text');
                    formControl.attr('mp-type', 'email');
                }

                if (validation.url) {
                    formControl.prop('type', 'text');
                    formControl.attr('mp-type', 'url');
                }

                if (validation.pattern) {
                    if (validation.pattern.regexp) {
                        formControl.prop('type', 'text');
                        formControl.attr('ng-pattern', validation.pattern.regexp);
                    }
                }

                if (validation.min) {
                    formControl.prop('type', 'text');
                    formControl.attr('mp-type', 'number');
                    formControl.attr('min', validation.min.value);
                }

                if (validation.max) {
                    formControl.prop('type', 'text');
                    formControl.attr('mp-type', 'number');
                    formControl.attr('max', validation.max.value);
                }

                // if (validation.past) {
                //     formControl.attr('past', true);
                // }

                // if (validation.future) {
                //     formControl.attr('future', true);
                // }

                // if (validation.digits) {
                //     formControl.attr('ng-pattern', new RegExp('^-?[0-9]+(.[0-9]+)?$'));
                // }

                // if (validation.decimalMin) {
                //     formControl.attr('min', parseInt(validation.decimalMin.value, 10));
                // }

                // if (validation.decimalMax) {
                //     formControl.attr('max', parseInt(validation.decimalMax.value, 10));
                // }
            }

            function addFormValidations(form, validations) {
                angular.forEach(validations, function(validation, formControlName) {
                    // Look for name+'Code' and name+'Desc' controls because of mpOptionsList
                    var formControl = form.find('[name="' + formControlName + '"], [name="' + formControlName + 'Code"], [name="' + formControlName + 'Desc"]');

                    if (formControl.length) {
                        addFormControlValidation(angular.element(formControl), validation);
                    }
                });
            }

            function removeFormControlValidations(formControl) {
                angular.forEach(VALIDATION_ATTRIBUTES, function(attribute) {
                    if (!_.isUndefined(formControl.attr(attribute))) {
                        formControl.removeAttr(attribute);
                    }
                });
            }

            function removeAllFormValidations(form) {
                var formControls = form.find('[ng-model]');

                angular.forEach(formControls, function(formControl) {
                    removeFormControlValidations(angular.element(formControl));
                });
            }

            return {
                restrict: 'A',
                require: '?form',
                compile: function(cElem) {
                    if (oldValidations) {
                        addFormValidations(cElem, oldValidations);
                    }

                    cElem.html(cElem.html());
                    return function(scope, lElem, lAttrs, formCtrl) {
                        var validations = lAttrs.mpValidations,
                            model = lAttrs.mpValidationsModel,
                            formName = lAttrs.name;

                        function manageValidations(newValidations) {
                            if (!_.isEqual(newValidations, oldValidations)) {
                                oldValidations = newValidations;
                                removeAllFormValidations(lElem);
                                $compile(lElem)(scope);
                            }
                        }

                        function watchFormValidations() {
                            return scope.$watch(function() {
                                return $parse(validations)(scope);
                            }, manageValidations, true);
                        }

                        function watchFormModel() {
                            return scope.$watch(model, function(newModel) {
                                if (newModel) {
                                    newModel.gaiaFormName = formName;
                                }
                            }, true);
                        }

                        formCtrl['$' + formName + 'ValidationsWatcher'] = formCtrl['$' + formName + 'ValidationsWatcher'] || watchFormValidations();

                        formCtrl['$' + formName + 'ModelWatcher'] = formCtrl['$' + formName + 'ModelWatcher'] || watchFormModel();
                    };
                }
            };
        }]);

/*TODO: TODO UPDATE DOC*/
/**
* @doc-component directive
* @name gaiafrontend.directive.mpValuesList
* @description
* Documentation pending.
*/
/*global angular */
angular.module('mpValuesList', [])
    .constant('ValuesListConfig', {
        url: 'api/valuesList'
    })
    .factory('ValuesListSrv', ['HttpSrv', 'ValuesListConfig', function (HttpSrv, ValuesListConfig) {
        return {
            get: function getValuesList(data) {
                return HttpSrv.post(ValuesListConfig.url, data);
            }
        };
    }])
    .controller('ValuesListCtrl', ['$scope', '$parse', '$modal', '$filter', function ($scope, $parse, $modal, $filter) {
        $scope.model = $scope.model = {};

        function translateColNames(deferred) {
            return function (valuesListResponse) {
                if (valuesListResponse.config && valuesListResponse.config.colNames) {
                    angular.forEach(valuesListResponse.config.colNames, function (colName, index, colNames) {
                        colNames[index] = $filter('translate')(colName);
                    });
                }
                return deferred.resolve(valuesListResponse);
            }
        }

        this.open = function () {
            $modal.open({
                backdrop: 'static',
                template: '<div class="modal-container">' +
                    '<div class="modal-body">' +
                    '<div mp-grid="valuesListGrid" mp-grid-pager="valuesListPager" mp-grid-options="valuesList.config" mp-grid-model="valuesList.model" mp-grid-data="valuesList.data">' +
                    '</div>' +
                    '<div class="modal-footer">' +
                    '<button type="button" class="btn btn-navigation pull-left" ng-click="cancel()">' + $filter('translate')('mpValuesList.cancel') + '</button>' +
                    '<button type="button" class="btn btn-navigation" ng-click="accept()">' + $filter('translate')('mpValuesList.accept') + '</button' +
                    '</div>' +
                    '</div>',
                scope: $scope,
                controller: ['$scope', '$modalInstance', 'valuesListResponse', '$rootScope',
                    function ($scope, $modalInstance, valuesListResponse, $rootScope) {
                        var valuesListInputData = $scope.inputData || {},
                            inputData = valuesListInputData.data || valuesListInputData;

                        if (angular.isUndefined(inputData.insVal) || angular.isUndefined(inputData.lstIdn) || angular.isUndefined(inputData.lstVrs)) {
                            throw new Error('"insVal", "lstIdn" and "lstVrs" are mandatory input data properties');
                        }

                        $scope.valuesList = valuesListResponse;

                        $scope.$parent.config = $scope.valuesList.config;

                        $scope.cancel = function () {
                            $modalInstance.dismiss();
                        };

                        $scope.accept = function () {
                            if ($scope.valuesList && $scope.valuesList.model) {
                                $modalInstance.close($scope.valuesList.model);
                            } else {
                                $scope.cancel();
                            }
                        };

                        var unRegisterStateEvent = $rootScope.$on('$stateChangeSuccess', function (event, toState, toParams, fromState, fromParams) {
                            $scope.cancel();
                            });

                        $scope.$on('$destroy', function() {
                            unRegisterStateEvent();
                        });

                        $scope.$on('valuesListGridSet', function (event, grid) {
                            grid.jqGrid('navGrid', '#valuesListPager', {
                                edit: false,
                                add: false,
                                del: false,
                                search: false,
                                refresh: false
                            });

                            grid.jqGrid('navButtonAdd', '#valuesListPager', {
                                caption: $filter('translate')('mpValuesList.search'),
                                buttonicon: 'ui-icon-search',
                                onClickButton: function () {
                                    grid[0].triggerToolbar();
                                }
                            });

                            grid.jqGrid('filterToolbar', {
                                searchOperators: true,
                                searchOnEnter: true,
                                autosearch: true
                            });

                            if ($scope.filter) $scope.filter({$scope: $scope});

                            //TODO: searchOptions.sopt could come from the service
                            grid.jqGrid('getGridParam', 'colModel').forEach(function (col) {
                                grid.jqGrid('setColProp', col.name, {
                                    searchoptions: {
                                        defaultValue: $parse(col.name)($scope.model) || '',
                                        sopt: ['cn', 'nc', 'eq', 'ne', 'lt', 'le', 'gt', 'ge', 'bw', 'bn', 'in', 'ni', 'ew', 'en']
                                    }
                                });
                            });

                            grid[0].clearToolbar();
                            grid[0].triggerToolbar();
                        });
                    }
                ],
                size: 'lg',
                resolve: {
                    valuesListResponse: ['ValuesListSrv', '$q', function (ValuesListSrv, $q) {
                        var deferred = $q.defer();

                        ValuesListSrv.get($scope.inputData)
                            .then(translateColNames(deferred), deferred.reject);

                        return deferred.promise;
                    }]
                }
            }).result
                .then(function (data) {
                    $scope.model = data;
                });
        };
    }])
    .directive('mpValuesList', function () {
        return {
            templateUrl: 'gaiafrontend/html/valuesList.html',
            replace: true,
            scope: {
                inputData: '=mpValuesList',
                model: '=mpValuesListModel',
                config: '=?mpValuesListConfig',
                filter: '&?mpValuesListFilter'
            },
            controller: 'ValuesListCtrl',
            require: 'mpValuesList',
            link: function (scope, element, attrs, ValuesList) {
                element.on('click', ValuesList.open);
                element.on('$destroy', function () {
                    element.off('click', ValuesList.open);
                })
            }
        };
    });

/*global angular */
/*DEPRECATED*/
/**
 * @doc-component directive
 * @name gaiafrontend.directive.mpVideo
 * @param {string} mpVideo Video path without extension.
 * @description
 * DEPRECATED
 * If you need this component ask for it through UX department
 */
angular.module('mpVideo', [])
    .directive('mpVideo', function() {
        return {
            scope: {
                mpVideo: '@'
            },
            templateUrl: 'gaiafrontend/html/video.html',
            link: function(scope, elm, attrs) {
                elm.find('video').attr('poster', attrs.mpVideo + '.jpg');
            }
        };
    });

/*TODO: REVIEW*/
/**
 * @doc-component directive
 * @name gaiafrontend.directive.mpWysiwyg
 * @param {string=} mp-wysiwyg-options to activate the plugin with custom options you can use the attribute mp-wysiwyg-optionsque receive a JSON with wysiwyg options as shown in the example above.
 * @description
 * DEPRECATED
 * Use mpRichTextEditor instead
 */
/*global angular */
angular.module('mpWysiwyg', ['utils'])
    .directive('mpWysiwyg', ['Loader',
        function(Loader) {
            var loadPlugin = Loader.load;

            return {
                templateUrl: 'gaiafrontend/html/wysiwyg.html',
                link: function(scope, elm, attrs) {
                    function drawWysiwyg() {
                        var containerWidth = elm.css('width').toString(),
                            containerWidthParts,
                            containerWidthBigger,
                            textarea = elm.find('textarea');

                        containerWidthParts = containerWidth.split('px');
                        containerWidthBigger = parseInt(containerWidthParts[0], 10) + 20;
                        textarea.css('width', containerWidthBigger + 'px');

                        if (attrs.mpWysiwygOptions) {
                            textarea.wysiwyg(JSON.parse(attrs.mpWysiwygOptions));
                        } else {
                            textarea.wysiwyg();
                        }
                    }

                    loadPlugin('wysiwyg.js').then(function() {
                        loadPlugin('jquery.wysiwyg.js').then(drawWysiwyg);
                    });

                }
            };
        }]);

/*global angular, Shadowbox */
/*DEPRECATED*/
/**
 * @doc-component directive
 * @name gaiafrontend.directive.mpZoom
 * @description
 * DEPRECATED
 * If you need this component ask for it through UX department
 */
angular.module('mpZoom', ['utils'])
    .directive('mpZoom', ['Loader',
        function(Loader) {
            var loadPlugin = Loader.load;

            return {
                scope: {
                    mpZoom: '@'
                },
                link: function() {
                    function zoom() {
                        Shadowbox.init();
                    }

                    loadPlugin('shadowbox.js').then(zoom);
                }
            };
        }]);

/*global angular, _ */
angular.module('ngModel', ['ng', 'mpValidations'])
    .config(['$provide', function($provide) {
        function ngModelDirectiveDecorator($delegate, $compile, $locale, $timeout, $filter, $interpolate, $parse, VALIDATIONS, Events) {
            var ngModelDirective = $delegate[0],
                compile = ngModelDirective.compile;

            ngModelDirective.compile = function() {
                var postLink = compile.apply(this, arguments);
                
                return function(scope, element, attributes, controllers) {
                   
                    postLink.post.apply(this, arguments);

                    if (angular.isDefined(attributes.novalidate)) {
                        return;
                    }
                    var ngModelCtrl = controllers[0],
                        formCtrl = controllers[1],
                        ngModelErrors = $parse(attributes.ngModelErrors)(),
                        elementName = ngModelCtrl.$name,
                        formName = formCtrl ? formCtrl.$name : undefined,
                        deregisterOnFocusOutEventListeners,
                        deregisterOnFocusInEventListeners,
                        deregisterOnSetErrorAngularEventListener,
                        deregisterOnFocusAngularEventListener,
                        deregisterOnClickAngularEventListener,
                        deregisterWatcher;

                    // Overwritten here since we cannot access to formCtrl inside ngModelCtrl
                    ngModelCtrl.$dirtify = function() {
                        element.removeClass('ng-pristine').addClass('ng-dirty');
                        ngModelCtrl.$dirty = true;
                        ngModelCtrl.$pristine = false;
                        formCtrl.$setDirty();
                    };

                    function insertErrorElement() {
                        var errorElement = element.next();

                        if (errorElement.is('.error-alert')) errorElement.remove();

                        errorElement = angular.element('<div mp-tooltip-error="' + ngModelCtrl.$name + '"></div>');
                        element.after(errorElement);
                        $compile(errorElement)(scope);
                    }

                    function getErrorType(errors) {
                        var failingErrors = _.pick(errors, function(value) {
                            return value;
                        }), errorType;

                        _.every(failingErrors, function (value, type) {
                            errorType = type;
                            if (_.keys(failingErrors).length > 1 && type === 'required') {
                                errorType = null;
                            }
                            return !errorType;
                        });

                        return errorType;
                    }

                    function manageLabelStyles(required) {
                        var formGroup = element.closest('.form-group');

                        if (required) {
                            formGroup.find('label').eq(0).addClass('required');
                        } else {
                            formGroup.find('label').eq(0).removeClass('required');
                        }
                    }

                    function addErrorStyles(formGroup, style) {
                        formGroup.addClass('has-error');
                        if (style) {
                            formGroup.addClass(style);
                        }
                    }

                    function removeErrorStyles(formGroup, style) {
                        formGroup.removeClass('has-error');
                        if (style) {
                            formGroup.addClass(style);
                        }
                    }

                    function manageErrorStyles(isInvalidAndDirty) {
                        var formGroup = element.closest('.form-group');

                        if (isInvalidAndDirty) {
                            addErrorStyles(formGroup);
                        } else {
                            removeErrorStyles(formGroup);
                        }
                    }

                    function manageErrorText(errors) {
                        var failingErrors = _.pick(errors, function(value) {
                                return value;
                            }),
                            errorText;

                        function getErrorTranslation(literal) {
                            if (!literal) {
                                return '';
                            }

                            return $filter('translate')(literal, {
                                min: attributes.ngMinlength || attributes.min,
                                max: attributes.ngMaxlength || attributes.max
                            });
                        }

                        function getErrorText(errorType) {
                            var errorText = '',
                                errorLiteral;

                            if (errorType) {

                                if (ngModelErrors) {
                                    errorText = ngModelErrors[errorType];
                                }

                                if (!errorText) {
                                    errorLiteral = 'ngModel.' + errorType;
                                    errorText = getErrorTranslation(errorLiteral);

                                    if (errorLiteral === errorText) {
                                        errorLiteral = errorType;
                                        errorText = getErrorTranslation(errorLiteral);
                                    }

                                    if (errorLiteral === errorText) {
                                        errorText = '';
                                    }
                                }
                            }

                            return errorText;
                        }

                        errorText = getErrorText(getErrorType(errors));

                        // $errorText is overwritten only when there are not any custom error faling
                        if (_.union(VALIDATIONS, _.keys(failingErrors)).length === VALIDATIONS.length) {
                            formCtrl[elementName].$errorText = errorText;
                        }
                    }

                    function clearCustomError() {
                        if (!formCtrl[elementName]) return;

                        angular.forEach(formCtrl[elementName].$customError, function(errorText, error) {
                            formCtrl[elementName].$setValidity(error, true);
                        });
                    }

                    function setCustomError(error) {
                        formCtrl[elementName].$customError = error;
                        angular.forEach(error, function(errorText, error) {
                            formCtrl[elementName].$errorText = errorText;
                            formCtrl[elementName].$setValidity(error, false);
                        });
                        ngModelCtrl.$dirtify();
                    }

                    function listenOnSetErrorAngularEvent() {
                        function setError(event, error) {
                            setCustomError(error);
                        }

                        return scope.$on(Events.$formControlError(formName + elementName), setError);
                    }

                    function listenOnFocusAngularEvent() {
                        function focus() {
                            element.focus();
                        }
                        return scope.$on(Events.$formControlFocus(formName + elementName), focus);
                    }

                    function listenOnClicksAngularEvent() {
                        function click() {
                            element.click();
                        }
                        return scope.$on(Events.$formControlClick(formName + elementName), click);
                    }

                    function watchControlAndRequiredAttribute() {
                        // Just one watcher because of performance issues https://trello.com/c/ssgQToEX
                        return scope.$watch(function () {
                            return {
                                invalidAndDirty: formCtrl[elementName] && formCtrl[elementName].$invalid && formCtrl[elementName].$dirty,
                                error: formCtrl[elementName] && formCtrl[elementName].$error,
                                hasRequiredAttribute: attributes.required
                            }
                        }, function (values) {
                            manageErrorStyles(values.invalidAndDirty);
                            manageErrorText(values.error || {});
                            manageLabelStyles(values.hasRequiredAttribute);
                        }, true);
                    }

                    // FIX: Avoid $apply already in progress error
                    // https://docs.angularjs.org/error/$rootScope/inprog?p0=$apply#triggering-events-programmatically
                    function applyLater(fn) {
                        $timeout(fn);
                    }

                    function listenOnFocusOutEvent() {
                        function onFocusOutFn() {
                            applyLater(function() {
                                ngModelCtrl.$dirtify();
                            });
                        }

                        element.on('focusout', onFocusOutFn);
                        return function() {
                            element.off('focusout', onFocusOutFn);
                        };
                    }

                    function listenOnFocusInEvent() {
                        function onFocusInFn() {
                            applyLater(function() {
                                clearCustomError();
                            });
                        }

                        element.on('focusin', onFocusInFn);
                        return function() {
                            element.off('focusin', onFocusInFn);
                        };
                    }

                    function deregisterListenersAndWatchers() {
                        deregisterOnFocusOutEventListeners();
                        deregisterOnFocusInEventListeners();
                        deregisterOnSetErrorAngularEventListener();
                        deregisterOnFocusAngularEventListener();
                        deregisterOnClickAngularEventListener();
                        deregisterWatcher();
                    }

                    function listenEventsAndWatchChanges() {
                        deregisterOnFocusOutEventListeners = listenOnFocusOutEvent();
                        deregisterOnFocusInEventListeners = listenOnFocusInEvent();
                        deregisterOnSetErrorAngularEventListener = listenOnSetErrorAngularEvent();
                        deregisterOnFocusAngularEventListener = listenOnFocusAngularEvent();
                        deregisterOnClickAngularEventListener = listenOnClicksAngularEvent();
                        deregisterWatcher = watchControlAndRequiredAttribute();

                        element.on('$destroy', deregisterListenersAndWatchers);
                    }

                    if (formName && elementName) {
                        insertErrorElement();
                        listenEventsAndWatchChanges();
                    }

                };
            };

            return $delegate;
        }

        ngModelDirectiveDecorator.$inject = ['$delegate', '$compile', '$locale', '$timeout', '$filter', '$interpolate', '$parse', 'VALIDATIONS', 'Events'];
        
        //$provide.decorator('ngModelDirective', ngModelDirectiveDecorator);
    }]);

/*global angular, _ */
(function() {
    function tabTitle($parse, $filter, $window, Utils) {
        var computedWidth = 0
        return {
            restrict: 'A',
            scope: {
                mpOnClose: '=',
                title: '@',
                ngDisabled: '&'
            },
            controller: ['$scope', function($scope) {

            }],
            link: function(scope, elements, attrs) {
                var closeButton = angular.element("<span class='closeable'></span>"),
                    titleLayer = angular.element('<span class="truncate"></span>'),
                    attrTitle = attrs.title.replace('@@', ''),
                    computedTabs = angular.element('li.tab-title'),
                    width = angular.element('ul.tabSet').width(),
                    finalTabWidth = parseInt(width / computedTabs.length, 10),
                    mediaMatch = window.matchMedia('(max-width: 800px)').matches;

                elements.append(titleLayer);

                scope.$parent.$watch(attrs.ngDisabled, function(newValue, oldValue) {
                    if (newValue !== oldValue) {
                        if (elements.hasClass('disabled'))
                            elements.removeClass('disabled');
                        else
                            elements.addClass('disabled')
                    }
                });


                if (_.has(scope.$parent, attrs.title)) {
                    scope.$parent.$watch(attrs.title, function(newValue, oldValue) {
                        //elements.append('<span class="truncate">' + newValue + '</span>');
                        titleLayer.text(newValue);
                        computedWidth += angular.element(elements).width();
                    });
                } else {
                    //elements.html('<span class="truncate">' + $filter('translate')(attrTitle) + '</span>');
                    titleLayer.text($filter('translate')(attrTitle));
                    computedWidth += angular.element(elements).width();
                }

                scope.$parent.$watch(attrs.closeable, function() {
                    if (attrs.closeable === 'true' && !elements.hasClass('disabled')) {
                        elements.append(closeButton);
                    }
                });


                function setTabWidth(elem, computed) {
                    if (!angular.isUndefined(computed)) {
                        elements = elem;
                        computedTabs = computed;
                    }

                    if (computedWidth > width && !mediaMatch) {
                        var finalTabWidth = parseInt(width / computedTabs.length, 10)
                        angular.element(elements).outerWidth(finalTabWidth - 1);
                    }
                }

                function removedTabWidth() {
                    var computedTabs = angular.element('li.tab-title');
                    _.forEach(computedTabs, function(tab) {
                        setTabWidth(tab, computedTabs);
                    });
                }

                scope.tabToRemove = function() {
                    if (elements.hasClass('active')) {
                        var tabSelectable = angular.element("li.tab-title[disabled!='disabled']");
                        tabSelectable.each(function(index, value) {
                            if (!angular.element(value).hasClass('active')) {
                                angular.element(value).trigger('click');
                                return false;
                            }
                        });
                    }
                    if (_.has(attrs, 'mpOnClose'))
                        scope.mpOnClose();

                    elements.next().remove();
                    elements.remove();
                    removedTabWidth();
                };

                closeButton
                    .on('click', function(event) {
                        scope.tabToRemove();
                        event.stopPropagation();
                    })
                    .on('$destroy', function() {
                        closeButton.off('click', scope.tabToRemove);
                    })

                if (Utils.platform.isTactile()) {
                    angular.element(window).on("orientationchange", function(event) {
                        setTabWidth();
                    });
                } else {
                    angular.element(window).on("resize", function(event) {
                        setTabWidth();
                    });
                }

                setTabWidth();
            }
        }
    }
    (angular.module('tabTitle', []))
    .directive('tabTitle', ['$parse', '$filter', '$window', 'Utils', tabTitle])
}());

/*global angular, _, $script */
(function () {
    var uid = ['0', '0', '0'];

    angular.module('utils', [])
        .constant('Utils', {
            id: {
                next: function nextUid() {
                    var index = uid.length;
                    var digit;

                    while (index) {
                        index--;
                        digit = uid[index].charCodeAt(0);
                        if (digit === 57 /*'9'*/ ) {
                            uid[index] = 'A';
                            return uid.join('');
                        }
                        if (digit === 90 /*'Z'*/ ) {
                            uid[index] = '0';
                        } else {
                            uid[index] = String.fromCharCode(digit + 1);
                            return uid.join('');
                        }
                    }
                    uid.unshift('0');
                    return uid.join('');
                }
            },
            string: {
                trim: function (string) {
                    if (angular.isString(string)) {
                        string = string.replace(/^\s+|\s+$/g, '');
                    }

                    return string;
                },
                replaceDiacritics: function (string) {
                    var defaultDiacriticsRemovalMap = [{
                            'base': 'A',
                            'letters': /[\u0041\u24B6\uFF21\u00C0\u00C1\u00C2\u1EA6\u1EA4\u1EAA\u1EA8\u00C3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\u00C4\u01DE\u1EA2\u00C5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F]/g
                        }, {
                            'base': 'AA',
                            'letters': /[\uA732]/g
                        }, {
                            'base': 'AE',
                            'letters': /[\u00C6\u01FC\u01E2]/g
                        }, {
                            'base': 'AO',
                            'letters': /[\uA734]/g
                        }, {
                            'base': 'AU',
                            'letters': /[\uA736]/g
                        }, {
                            'base': 'AV',
                            'letters': /[\uA738\uA73A]/g
                        }, {
                            'base': 'AY',
                            'letters': /[\uA73C]/g
                        }, {
                            'base': 'B',
                            'letters': /[\u0042\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181]/g
                        }, {
                            'base': 'C',
                            'letters': /[\u0043\u24B8\uFF23\u0106\u0108\u010A\u010C\u00C7\u1E08\u0187\u023B\uA73E]/g
                        }, {
                            'base': 'D',
                            'letters': /[\u0044\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779]/g
                        }, {
                            'base': 'DZ',
                            'letters': /[\u01F1\u01C4]/g
                        }, {
                            'base': 'Dz',
                            'letters': /[\u01F2\u01C5]/g
                        }, {
                            'base': 'E',
                            'letters': /[\u0045\u24BA\uFF25\u00C8\u00C9\u00CA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\u00CB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E]/g
                        }, {
                            'base': 'F',
                            'letters': /[\u0046\u24BB\uFF26\u1E1E\u0191\uA77B]/g
                        }, {
                            'base': 'G',
                            'letters': /[\u0047\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E]/g
                        }, {
                            'base': 'H',
                            'letters': /[\u0048\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D]/g
                        }, {
                            'base': 'I',
                            'letters': /[\u0049\u24BE\uFF29\u00CC\u00CD\u00CE\u0128\u012A\u012C\u0130\u00CF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197]/g
                        }, {
                            'base': 'J',
                            'letters': /[\u004A\u24BF\uFF2A\u0134\u0248]/g
                        }, {
                            'base': 'K',
                            'letters': /[\u004B\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2]/g
                        }, {
                            'base': 'L',
                            'letters': /[\u004C\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780]/g
                        }, {
                            'base': 'LJ',
                            'letters': /[\u01C7]/g
                        }, {
                            'base': 'Lj',
                            'letters': /[\u01C8]/g
                        }, {
                            'base': 'M',
                            'letters': /[\u004D\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C]/g
                        }, {
                            'base': 'N',
                            'letters': /[\u004E\u24C3\uFF2E\u01F8\u0143\u00D1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4]/g
                        }, {
                            'base': 'NJ',
                            'letters': /[\u01CA]/g
                        }, {
                            'base': 'Nj',
                            'letters': /[\u01CB]/g
                        }, {
                            'base': 'O',
                            'letters': /[\u004F\u24C4\uFF2F\u00D2\u00D3\u00D4\u1ED2\u1ED0\u1ED6\u1ED4\u00D5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\u00D6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\u00D8\u01FE\u0186\u019F\uA74A\uA74C]/g
                        }, {
                            'base': 'OI',
                            'letters': /[\u01A2]/g
                        }, {
                            'base': 'OO',
                            'letters': /[\uA74E]/g
                        }, {
                            'base': 'OU',
                            'letters': /[\u0222]/g
                        }, {
                            'base': 'P',
                            'letters': /[\u0050\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754]/g
                        }, {
                            'base': 'Q',
                            'letters': /[\u0051\u24C6\uFF31\uA756\uA758\u024A]/g
                        }, {
                            'base': 'R',
                            'letters': /[\u0052\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782]/g
                        }, {
                            'base': 'S',
                            'letters': /[\u0053\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784]/g
                        }, {
                            'base': 'T',
                            'letters': /[\u0054\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786]/g
                        }, {
                            'base': 'TZ',
                            'letters': /[\uA728]/g
                        }, {
                            'base': 'U',
                            'letters': /[\u0055\u24CA\uFF35\u00D9\u00DA\u00DB\u0168\u1E78\u016A\u1E7A\u016C\u00DC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244]/g
                        }, {
                            'base': 'V',
                            'letters': /[\u0056\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245]/g
                        }, {
                            'base': 'VY',
                            'letters': /[\uA760]/g
                        }, {
                            'base': 'W',
                            'letters': /[\u0057\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72]/g
                        }, {
                            'base': 'X',
                            'letters': /[\u0058\u24CD\uFF38\u1E8A\u1E8C]/g
                        }, {
                            'base': 'Y',
                            'letters': /[\u0059\u24CE\uFF39\u1EF2\u00DD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE]/g
                        }, {
                            'base': 'Z',
                            'letters': /[\u005A\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762]/g
                        }, {
                            'base': 'a',
                            'letters': /[\u0061\u24D0\uFF41\u1E9A\u00E0\u00E1\u00E2\u1EA7\u1EA5\u1EAB\u1EA9\u00E3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\u00E4\u01DF\u1EA3\u00E5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250]/g
                        }, {
                            'base': 'aa',
                            'letters': /[\uA733]/g
                        }, {
                            'base': 'ae',
                            'letters': /[\u00E6\u01FD\u01E3]/g
                        }, {
                            'base': 'ao',
                            'letters': /[\uA735]/g
                        }, {
                            'base': 'au',
                            'letters': /[\uA737]/g
                        }, {
                            'base': 'av',
                            'letters': /[\uA739\uA73B]/g
                        }, {
                            'base': 'ay',
                            'letters': /[\uA73D]/g
                        }, {
                            'base': 'b',
                            'letters': /[\u0062\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253]/g
                        }, {
                            'base': 'c',
                            'letters': /[\u0063\u24D2\uFF43\u0107\u0109\u010B\u010D\u00E7\u1E09\u0188\u023C\uA73F\u2184]/g
                        }, {
                            'base': 'd',
                            'letters': /[\u0064\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A]/g
                        }, {
                            'base': 'dz',
                            'letters': /[\u01F3\u01C6]/g
                        }, {
                            'base': 'e',
                            'letters': /[\u0065\u24D4\uFF45\u00E8\u00E9\u00EA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\u00EB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD]/g
                        }, {
                            'base': 'f',
                            'letters': /[\u0066\u24D5\uFF46\u1E1F\u0192\uA77C]/g
                        }, {
                            'base': 'g',
                            'letters': /[\u0067\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F]/g
                        }, {
                            'base': 'h',
                            'letters': /[\u0068\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265]/g
                        }, {
                            'base': 'hv',
                            'letters': /[\u0195]/g
                        }, {
                            'base': 'i',
                            'letters': /[\u0069\u24D8\uFF49\u00EC\u00ED\u00EE\u0129\u012B\u012D\u00EF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131]/g
                        }, {
                            'base': 'j',
                            'letters': /[\u006A\u24D9\uFF4A\u0135\u01F0\u0249]/g
                        }, {
                            'base': 'k',
                            'letters': /[\u006B\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3]/g
                        }, {
                            'base': 'l',
                            'letters': /[\u006C\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747]/g
                        }, {
                            'base': 'lj',
                            'letters': /[\u01C9]/g
                        }, {
                            'base': 'm',
                            'letters': /[\u006D\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F]/g
                        }, {
                            'base': 'n',
                            'letters': /[\u006E\u24DD\uFF4E\u01F9\u0144\u00F1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5]/g
                        }, {
                            'base': 'nj',
                            'letters': /[\u01CC]/g
                        }, {
                            'base': 'o',
                            'letters': /[\u006F\u24DE\uFF4F\u00F2\u00F3\u00F4\u1ED3\u1ED1\u1ED7\u1ED5\u00F5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\u00F6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\u00F8\u01FF\u0254\uA74B\uA74D\u0275]/g
                        }, {
                            'base': 'oi',
                            'letters': /[\u01A3]/g
                        }, {
                            'base': 'ou',
                            'letters': /[\u0223]/g
                        }, {
                            'base': 'oo',
                            'letters': /[\uA74F]/g
                        }, {
                            'base': 'p',
                            'letters': /[\u0070\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755]/g
                        }, {
                            'base': 'q',
                            'letters': /[\u0071\u24E0\uFF51\u024B\uA757\uA759]/g
                        }, {
                            'base': 'r',
                            'letters': /[\u0072\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783]/g
                        }, {
                            'base': 's',
                            'letters': /[\u0073\u24E2\uFF53\u00DF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B]/g
                        }, {
                            'base': 't',
                            'letters': /[\u0074\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787]/g
                        }, {
                            'base': 'tz',
                            'letters': /[\uA729]/g
                        }, {
                            'base': 'u',
                            'letters': /[\u0075\u24E4\uFF55\u00F9\u00FA\u00FB\u0169\u1E79\u016B\u1E7B\u016D\u00FC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289]/g
                        }, {
                            'base': 'v',
                            'letters': /[\u0076\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C]/g
                        }, {
                            'base': 'vy',
                            'letters': /[\uA761]/g
                        }, {
                            'base': 'w',
                            'letters': /[\u0077\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73]/g
                        }, {
                            'base': 'x',
                            'letters': /[\u0078\u24E7\uFF58\u1E8B\u1E8D]/g
                        }, {
                            'base': 'y',
                            'letters': /[\u0079\u24E8\uFF59\u1EF3\u00FD\u0177\u1EF9\u0233\u1E8F\u00FF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF]/g
                        }, {
                            'base': 'z',
                            'letters': /[\u007A\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763]/g
                        }],
                        defaultDiacriticsRemovalMapLength = defaultDiacriticsRemovalMap.length,
                        i;

                    if (angular.isString(string)) {
                        for (i = 0; i < defaultDiacriticsRemovalMapLength; i += 1) {
                            string = string.replace(defaultDiacriticsRemovalMap[i].letters, defaultDiacriticsRemovalMap[i].base);
                        }
                    }

                    return string;
                },
                toCamelCase: function (string) { // any:case | any-case | any_case > anyCase
                    return string.replace(/([\:\-\_]+(.))/g, function (_, separator, letter, offset) {
                        return offset ? letter.toUpperCase() : letter;
                    });
                },
                toColons: function (camelCase) { // camelCase > camel:case
                    return camelCase.replace(/[A-Z]/g, function (letter, pos) {
                        return (pos ? ':' : '') + letter.toLowerCase();
                    });
                },
                toHyphens: function (camelCase) { // camelCase > camel-case
                    return camelCase.replace(/[A-Z]/g, function (letter, pos) {
                        return (pos ? '-' : '') + letter.toLowerCase();
                    });
                },
                toSnakeCase: function (camelCase) { // camelCase > camel_case
                    return camelCase.replace(/[A-Z]/g, function (letter, pos) {
                        return (pos ? '-' : '') + letter.toLowerCase();
                    });
                }
            },
            platform: {
                isIE8: function () {
                    var IE_REGEX = /MSIE ([0-8]{1,}[\.0-8]{0,})/ig;

                    return IE_REGEX.test(navigator.userAgent) ? true : false
                },
                isTactile: function () {
                    var PHONE_REGEX = /(ip(a|o)d|iphone|android|blackBerry|windows phone)/ig;

                    return PHONE_REGEX.test(navigator.userAgent) ? true : false;
                },
                isWPhone: function () {
                    var IE_REGEX = /windows phone/ig;

                    return IE_REGEX.test(navigator.userAgent) ? true : false
                }
            }
        })
        .factory('Loader', ['$q', '$rootScope',
            function ($q, $rootScope) {
                var COMPONENTS_PATH = 'gaiafrontend/js/vendor/components/',
                    loadedPlugins = {};

                function getPath(plugin) {
                    return COMPONENTS_PATH + plugin;
                }

                function getAlias(plugin) {
                    return plugin.substring(0, plugin.indexOf('.js'));
                }

                function load(plugin) {
                    var deferred = $q.defer(),
                        path = getPath(plugin),
                        alias = getAlias(plugin);

                    function loadPlugin(path, alias) {
                        var timestamp = (new Date()).getTime(),
                            pluginAlias = plugin + '?' + timestamp;

                        function removeHeadScript(scriptSrc) {
                            var headScripts = angular.element('head script');

                            angular.forEach(headScripts, function (script) {
                                var scriptElement = angular.element(script),
                                    src = scriptElement.attr('src');
                                if (_.contains(src, scriptSrc)) {
                                    scriptElement.remove();
                                    scriptElement = null;
                                }
                            });
                        }

                        if (alias.indexOf('i18n/') === 0) {

                            $script(path + '?' + timestamp, pluginAlias);

                            $script.ready(pluginAlias, function () {
                                $rootScope.$apply(function () {
                                    deferred.resolve();
                                    removeHeadScript(path + '?' + timestamp);
                                });
                            });
                        } else {
                            $script(path, alias);

                            $script.ready(alias, function () {
                                loadedPlugins[alias] = true;
                                $rootScope.$apply(function () {
                                    deferred.resolve();
                                });
                            });
                        }
                    }

                    if (loadedPlugins[alias]) {
                        deferred.resolve();
                    } else {
                        loadPlugin(path, alias);
                    }

                    return deferred.promise;
                }

                return {
                    load: load
                };
            }
        ]);

}());

/*TODO: REVIEW*/
/**
 * @doc-component filter
 * @name gaiafrontend.filter.active
 * @description
 * This filter indicates if input is active.
 * @example
   <doc:example module="Active">
    <doc:source>
    input(ng-model="input", placeholder="Escribe para aplicar filtro")
    pre {{input | active}}
    </doc:source>
   </doc:example>
 */
/*global angular */
angular.module('active', [])
    .filter('active', function() {
        return function(input) {
            return input ? ' active' : '';
        };
    });

/*TODO: REVIEW*/
/**
 * @doc-component filter
 * @name gaiafrontend.filter.capitalize
 * @description
 * This filter capitalize each word from input
 * @example
   <doc:example module="Capitalize">
    <doc:source>
    input(ng-model="input", placeholder="Escribe para aplicar filtro")
    pre {{input | capitalize}}
    </doc:source>
   </doc:example>
 */
/*global angular */
angular.module('capitalize', [])
    .filter('capitalize', function() {
        return function(input) {
            return typeof input === 'string' ? input.replace(/\w\S*/g, function(inputString) {
                return inputString.charAt(0).toUpperCase() + inputString.substr(1).toLowerCase();
            }) : input;
        };
    });

/*TODO: REVIEW*/
/**
 * @doc-component filter
 * @name gaiafrontend.filter.disabled
 * @description
 * This filter indicates if input is disabled.
 * @example
   <doc:example module="Disabled">
    <doc:source>
    input(ng-model="input", placeholder="Escribe para aplicar filtro")
    pre {{input | disabled}}
    </doc:source>
   </doc:example>
 */
/*global angular */
angular.module('disabled', [])
    .filter('disabled', function() {
        return function(input) {
            return input ? ' disabled' : '';
        };
    });

/*TODO: REVIEW*/
/**
 * @doc-component filter
 * @name gaiafrontend.filter.exclude
 * @description
 * This filter exclude results that are indicated by the filter
 * @example
   <doc:example module="Exclude">
    <doc:source>
    input(ng-model="input", placeholder="Escribe para aplicar filtro")
    pre {{input | exclude}}
    </doc:source>
   </doc:example>
 */
/*global angular, _ */
angular.module('exclude', [])
    .filter('exclude', ['$filter',
        function($filter) {
            var allResults,
                resultsToExculde,
                resultado;
            return function(input, expressionToExclude) {
                allResults = $filter('filter')(input, '');
                resultsToExculde = $filter('filter')(input, expressionToExclude);
                resultado = _.difference(allResults, resultsToExculde);
                return resultado;
            };
        }]);

angular.module('filterByPath', [])
    .filter('filterByPath', ['$parse',
        function($parse) {
            var regExp = /^\w+/g;

            return function(array, path, expression) {
                var context = {},
                    propName = path.match(regExp)[0],
                    results = [];

                if (!expression && expression !== 0 || expression === '') {
                    return array;
                }
                (function filter(array, collection) {
                    collection.push.apply(collection, _.filter(array, function(item) {
                        var input;
                        context[propName] = item;
                        input = $parse(path)(context) === 0 || angular.isNumber($parse(path)(context)) || angular.isString($parse(path)(context)) ? $parse(path)(context) : '';
                        return angular.isString(expression) && String(input).toLowerCase().search(expression.toLowerCase()) >= 0;
                    }));
                }(array, results));
                return results;
            }
        }
    ]);

/*TODO: REVIEW*/
/**
 * @doc-component filter
 * @name gaiafrontend.filter.formatCurrency
 * @description
 * This filter applys to the input to convert to proper currency
 * @example
   <doc:example module="FormatCurrency">
    <doc:source>
    input(ng-model="input", placeholder="Escribe para aplicar filtro")
    pre {{input | formatCurrency}}
    </doc:source>
   </doc:example>
 */
/*global angular */
angular.module('formatCurrency', [])
    .filter('formatCurrency', ['$locale', 'UserSrv',
        function($locale, UserSrv) {
            return function(input) {
                var userInfo = UserSrv.info,
                    decimalSep,
                    groupSep,
                    numDecimals,
                    removeDecimalSepRegExp;

                function updateRegExp() {
                    removeDecimalSepRegExp = new RegExp('[' + decimalSep + ']', 'gi');
                }

                function updateSeparators() {
                    if (userInfo && userInfo.applicationData && userInfo.applicationData.formattingAndMask && userInfo.applicationData.formattingAndMask.decimalSeparator) {
                        decimalSep = userInfo.applicationData.formattingAndMask.decimalSeparator;
                    } else {
                        decimalSep = $locale.NUMBER_FORMATS.DECIMAL_SEP;
                    }

                    if (userInfo && userInfo.applicationData && userInfo.applicationData.formattingAndMask && userInfo.applicationData.formattingAndMask.groupSeparator) {
                        groupSep = userInfo.applicationData.formattingAndMask.groupSeparator;
                    } else {
                        groupSep = $locale.NUMBER_FORMATS.GROUP_SEP;
                    }

                    if (userInfo && userInfo.applicationData && userInfo.applicationData.formattingAndMask && userInfo.applicationData.formattingAndMask.decimalLength) {
                        numDecimals = userInfo.applicationData.formattingAndMask.decimalLength;
                    } else {
                        numDecimals = 2;
                    }
                    updateRegExp();
                }

                function formatNumber(numberString) {
                    numberString = numberString || '';
                    updateSeparators();

                    var num = numberString.split(decimalSep)[0],
                        decimal = numberString.split(decimalSep)[1],
                        chain = '',
                        aux,
                        count = 1,
                        m,
                        formattedNumber;

                    if (num < 0) {
                        aux = 1;
                    } else {
                        aux = 0;
                    }

                    num = num.toString();

                    for (m = num.length - 1; m >= 0; m = m - 1) {

                        chain = num.charAt(m) + chain;

                        if (count % 3 === 0 && m > aux) {
                            chain = groupSep + chain;
                        }


                        if (count === 3) {
                            count = 1;
                        } else {
                            count = count + 1;
                        }

                    }

                    // chain = chain.replace(/.,/, ",");

                    if (decimal !== undefined) {
                        formattedNumber = chain.concat(decimalSep + decimal);
                    } else {
                        formattedNumber = chain;
                    }

                    return formattedNumber;
                }

                function removeDecimalSep(numberString) {
                    return numberString.replace(removeDecimalSepRegExp, '');
                }

                function addZerosToDecimalPart(numberString) {
                    if (numberString !== '') {
                        var position = numberString.indexOf(decimalSep),
                            integerPart,
                            decimalPart,
                            i,
                            len;

                        if (position === -1) {
                            position = numberString.length;
                        }

                        numberString = removeDecimalSep(numberString);
                        integerPart = numberString.slice(0, position);
                        decimalPart = numberString.slice(position, numberString.length);

                        if (decimalPart.length < numDecimals) {
                            for (i = 0, len = numDecimals - decimalPart.length; i < len; i = i + 1) {
                                decimalPart = decimalPart + '0';
                            }
                        }

                        numberString = integerPart.concat(decimalSep);
                        numberString = numberString.concat(decimalPart);

                        return numberString;
                    }

                    return numberString;
                }

                return addZerosToDecimalPart(formatNumber(input));
            };
        }]);

/*TODO: REVIEW*/
/**
 * @doc-component filter
 * @name gaiafrontend.filter.formatNumber
 * @description
 * This filter formats the number from the input.
 * @example
   <doc:example module="FormatNumber">
    <doc:source>
    input(ng-model="input", placeholder="Escribe para aplicar filtro")
    pre {{input | formatNumber}}
    </doc:source>
   </doc:example>
 */
/*global angular */
angular.module('formatNumber', [])
    .filter('formatNumber', ['$locale', 'UserSrv',
        function($locale, UserSrv) {
            return function(input) {
                var userInfo = UserSrv.info,
                    decimalSep,
                    groupSep;

                function updateSeparators() {
                    if (userInfo && userInfo.applicationData && userInfo.applicationData.formattingAndMask && userInfo.applicationData.formattingAndMask.decimalSeparator) {
                        decimalSep = userInfo.applicationData.formattingAndMask.decimalSeparator;
                    } else {
                        decimalSep = $locale.NUMBER_FORMATS.DECIMAL_SEP;
                    }

                    if (userInfo && userInfo.applicationData && userInfo.applicationData.formattingAndMask && userInfo.applicationData.formattingAndMask.groupSeparator) {
                        groupSep = userInfo.applicationData.formattingAndMask.groupSeparator;
                    } else {
                        groupSep = $locale.NUMBER_FORMATS.GROUP_SEP;
                    }
                }

                function formatNumber(numberString) {
                    numberString = numberString || '';
                    updateSeparators();

                    var num = numberString.split(decimalSep)[0],
                        decimal = numberString.split(decimalSep)[1],
                        chain = '',
                        aux,
                        count = 1,
                        m,
                        formattedNumber;

                    if (num < 0) {
                        aux = 1;
                    } else {
                        aux = 0;
                    }

                    num = num.toString();

                    for (m = num.length - 1; m >= 0; m = m - 1) {

                        chain = num.charAt(m) + chain;

                        if (count % 3 === 0 && m > aux) {
                            chain = groupSep + chain;
                        }


                        if (count === 3) {
                            count = 1;
                        } else {
                            count = count + 1;
                        }

                    }

                    // chain = chain.replace(/.,/, ",");

                    if (decimal !== undefined) {
                        formattedNumber = chain.concat(decimalSep + decimal);
                    } else {
                        formattedNumber = chain;
                    }

                    return formattedNumber;
                }

                return formatNumber(input);
            };
        }]);

/*TODO: REVIEW*/
/**
 * @doc-component filter
 * @name gaiafrontend.filter.plural
 * @description
 * This filter indicates if input number is greater than one.
 * @example
   <doc:example module="plural">
    <doc:source>
    input(ng-model="input", placeholder="Quantity")
    pre Quantity: {{(input || '0') + ' item' | plural:input}}
    </doc:source>
   </doc:example>
 */
/*global angular */
angular.module('plural', [])
    .filter('plural', function() {
        return function(input, quantity) {
            var isPlural = !isNaN(quantity) && parseInt(quantity, 10) !== 1;
            return isPlural ? input + 's' : input;
        };
    });

/*TODO: REVIEW*/
/**
 * @doc-component filter
 * @name gaiafrontend.filter.removeWhitespaces
 * @description
 * This filter has been migrated to "GAIA Site"
 * There you will find its documentation and several examples.
 * "GAIA Site" is an application created by the Architecture Area to learn and play with GAIA. Is available in RAS. Direct links are available below in this page.
 * @example
    <doc:example>
         <doc:source>
         label GAIA site direct links are:
         a(href='https://wportalinterno.es.mapfre.net/com.ibm.ram.repository.web/faces/_rlvid.jsp?_rap=!assetDetails&_rvip=/home.jsp&guid=13A33828-B921-8DC5-DEDA-8B8D7C0EBC81') Intranet /
         a(href='https://wportalinterno.mapfre.com/com.ibm.ram.repository.web/faces/_rlvid.jsp?_rap=!assetDetails&_rvip=/home.jsp&guid=13A33828-B921-8DC5-DEDA-8B8D7C0EBC81') Internet
         </doc:source>
    </doc:example>
 */
/*global angular */
angular.module('removeWhitespaces', [])
    .filter('removeWhitespaces', function() {
        return function(input) {
            return (typeof input === 'string') ? input.replace(/\s/g, '') : input;
        };
    });

/*TODO: REVIEW*/
/**
 * @doc-component filter
 * @name gaiafrontend.filter.startFrom
 * @description
 * This filter has been migrated to "GAIA Site"
 * There you will find its documentation and several examples.
 * "GAIA Site" is an application created by the Architecture Area to learn and play with GAIA. Is available in RAS. Direct links are available below in this page.
 * @example
    <doc:example>
         <doc:source>
         label GAIA site direct links are:
         a(href='https://wportalinterno.es.mapfre.net/com.ibm.ram.repository.web/faces/_rlvid.jsp?_rap=!assetDetails&_rvip=/home.jsp&guid=13A33828-B921-8DC5-DEDA-8B8D7C0EBC81') Intranet /
         a(href='https://wportalinterno.mapfre.com/com.ibm.ram.repository.web/faces/_rlvid.jsp?_rap=!assetDetails&_rvip=/home.jsp&guid=13A33828-B921-8DC5-DEDA-8B8D7C0EBC81') Internet
         </doc:source>
    </doc:example>
*/
/*global angular */
angular.module('startFrom', [])
    .filter('startFrom', function() {
        return function(input, start) {
            start = +start; //parse to int
            return input.slice(start);
        };
    });

/*global angular, navigator, ActiveXObject */
angular.module('acrobatReaderSrv', [])
    /**
     * @doc-component service
     * @name gaiafrontend.service.acrobatReaderSrv
     * @description
     * This service has been migrated to "GAIA Site"
     * There you will find its documentation and several examples.
     * "GAIA Site" is an application created by the Architecture Area to learn and play with GAIA. Is available in RAS. Direct links are available below in this page.
     */
    .factory('AcrobatReaderSrv', function() {

        function getAcrobatInfo() {

            var getBrowserName = function() {
                return (function() {
                    var userAgent = navigator ? navigator.userAgent.toLowerCase() : 'other';

                    if (userAgent.indexOf('chrome') > -1) {
                        return 'chrome';
                    } else if (userAgent.indexOf('safari') > -1) {
                        return 'safari';
                    } else if (userAgent.indexOf('msie') > -1) {
                        return 'ie';
                    } else if (userAgent.indexOf('firefox') > -1) {
                        return 'firefox';
                    }
                    return userAgent;
                }());
            };

            var getActiveXObject = function(name) {
                try {
                    return new ActiveXObject(name);
                } catch (e) {}
            };

            var getNavigatorPlugin = function(name) {
                var key;
                for (key in navigator.plugins) {
                    if (navigator.plugins.hasOwnProperty(key)) {
                        var plugin = navigator.plugins[key];
                        if (plugin.name === name) {
                            return plugin;
                        }
                    }
                }
            };

            var getWebKitPlugin = function() {
                // Hack for webkit
                var key;
                for (key in navigator.plugins) {
                    if (navigator.plugins.hasOwnProperty(key)) {
                        var plugin = navigator.plugins[key];
                        if (plugin.name && plugin.name.substring(0, 6) === 'WebKit' && (plugin.name.indexOf('pdf') !== -1 || plugin.name.indexOf('PDF') !== -1)) {
                            return plugin;
                        }
                    }
                }
            };

            var getPDFPlugin = function() {
                return (function() {
                    if (getBrowserName() === 'ie') {
                        // load the activeX control
                        // AcroPDF.PDF is used by version 7 and later
                        // PDF.PdfCtrl is used by version 6 and earlier
                        return getActiveXObject('AcroPDF.PDF') || getActiveXObject('PDF.PdfCtrl');
                    } else {
                        return getNavigatorPlugin('Adobe Acrobat') || getNavigatorPlugin('Chrome PDF Viewer') || getWebKitPlugin() || getNavigatorPlugin('WebKit built-in PDF');
                    }
                }());
            };

            var isAcrobatInstalled = function() {
                return !!getPDFPlugin();
            };

            var getAcrobatVersion = function() {
                try {
                    var plugin = getPDFPlugin();

                    if (getBrowserName() === 'ie') {
                        var versions = plugin.GetVersions().split(',');
                        var latest = versions[0].split('=');
                        return parseFloat(latest[1]);
                    }

                    if (plugin.version) {
                        return parseInt(plugin.version, 10);
                    }
                    return plugin.name;
                } catch (e) {
                    return null;
                }
            };

            return {
                browser: getBrowserName(),
                isAcrobatInstalled: isAcrobatInstalled() ? true : false,
                acrobatVersion: getAcrobatVersion()
            };
        }

        return {
            getAcrobatInfo: getAcrobatInfo
        };
    });

/*global angular */
angular.module('avoidCacheInterceptor', [])
    /**
     * @doc-component service
     * @name gaiafrontend.service.avoidCacheInterceptor
     * @description
     * This service has been migrated to "GAIA Site"
     * There you will find its documentation and several examples.
     * "GAIA Site" is an application created by the Architecture Area to learn and play with GAIA. Is available in RAS. Direct links are available below in this page.
     */
    .factory('avoidCacheInterceptor', ['Utils', function (Utils) {

        function isHtmlRequest(config) {
            var htmlRegExp = new RegExp('\\.html(\\?.*)?', 'g');
            return config.method === 'GET' && htmlRegExp.test(config.url);
        }

        function isVendorTpl(config) {
            // ui.bootstrap templates pattern: template/*/*.html
            // mgcrea.ngStrap templates pattern: */*.tpl.html
            var tplRegExp = new RegExp('(template\\/.*\\/.*\\.html|.*\\/.*\\.tpl\\.html)(\\?.*)?');
            return config.method === 'GET' && tplRegExp.test(config.url);
        }

        function avoidCache(config) {
            config.cache = false;
            // HTTP 1.1
            config.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate';
            // HTTP 1.0
            config.headers.Pragma = 'no-cache';
            // Proxies
            config.headers.Expires = '0';
            // IE8
            if (Utils.platform.isIE8()) {
                var cacheBuster = new Date().getTime();
                config.url = config.url.replace(/[?|&]cacheBuster=\d+/,'');
                config.url += config.url.indexOf('?') === -1 ? '?' : '&'; // Some url's already have '?' attached
                config.url += 'cacheBuster=' + cacheBuster;
            }
        }

        return {
            request: function(config) {
                if ((isHtmlRequest(config) && !isVendorTpl(config))) {
                    avoidCache(config);
                }
                return config;
            }
        };
    }]);

/*global angular */
angular.module('browserDetectSrv', [])
    /**
     * @doc-component service
     * @name gaiafrontend.service.browserDetectSrv
     * @description
     * This service has been migrated to "GAIA Site"
     * There you will find its documentation and several examples.
     * "GAIA Site" is an application created by the Architecture Area to learn and play with GAIA. Is available in RAS. Direct links are available below in this page.
     */
    .factory('BrowserDetectSrv', function() {

        function getBrowser() {
            var browserData,
                BrowserDetect = {
                    searchString: function(data) {
                        var dataString,
                            dataProp,
                            i;
                        for (i = 0; i < data.length; i += 1) {
                            dataString = data[i].string;
                            dataProp = data[i].prop;
                            this.versionSearchString = data[i].versionSearch || data[i].identity;
                            if (dataString) {
                                if (dataString.indexOf(data[i].subString) !== -1)
                                    return data[i].identity;
                            } else if (dataProp)
                                return data[i].identity;
                        }
                    },
                    searchVersion: function(dataString) {
                        var index = dataString.indexOf(this.versionSearchString);
                        if (index === -1) return;
                        return parseFloat(dataString.substring(index + this.versionSearchString.length + 1));
                    },
                    dataBrowser: [{
                        string: navigator.userAgent,
                        subString: 'OmniWeb',
                        versionSearch: 'OmniWeb/',
                        identity: 'OmniWeb'
                    }, {
                        string: navigator.vendor,
                        subString: 'Apple',
                        identity: 'Safari'
                    }, {
                        prop: window.opera,
                        identity: 'Opera'
                    }, {
                        string: navigator.vendor,
                        subString: 'iCab',
                        identity: 'iCab'
                    }, {
                        string: navigator.vendor,
                        subString: 'KDE',
                        identity: 'Konqueror'
                    }, {
                        string: navigator.userAgent,
                        subString: 'Firefox',
                        identity: 'Firefox'
                    }, {
                        string: navigator.vendor,
                        subString: 'Camino',
                        identity: 'Camino'
                    }, { // for newer Netscapes (6+)
                        string: navigator.userAgent,
                        subString: 'Netscape',
                        identity: 'Netscape'
                    }, {
                        string: navigator.userAgent,
                        subString: 'MSIE',
                        identity: 'Explorer',
                        versionSearch: 'MSIE'
                    }, {
                        string: navigator.userAgent,
                        subString: 'Trident',
                        identity: 'Explorer',
                        versionSearch: 'rv'
                    }, {
                        string: navigator.userAgent,
                        subString: 'Edge',
                        identity: 'Edge'
                    }, {
                        string: navigator.userAgent,
                        subString: 'Gecko',
                        identity: 'Chrome',
                        versionSearch: 'Chrome\/'
                    }],
                    dataOS: [{
                        string: navigator.platform,
                        subString: 'Win',
                        identity: 'Windows'
                    }, {
                        string: navigator.platform,
                        subString: 'Mac',
                        identity: 'Mac'
                    }, {
                        string: navigator.platform,
                        subString: 'Linux',
                        identity: 'Linux'
                    }, {
                        string: navigator.platform,
                        subString: 'android',
                        identity: 'Android'
                    }, {
                        string: navigator.platform,
                        subString: 'ipad',
                        identity: 'iOS'
                    }, {
                        string: navigator.platform,
                        subString: 'iphone',
                        identity: 'iOS'
                    }],
                    init: function() {
                        browserData = {
                            name: this.searchString(this.dataBrowser) || 'An unknown browser',
                            version: this.searchVersion(navigator.userAgent) || this.searchVersion(navigator.appVersion) || 'an unknown version',
                            os: this.searchString(this.dataOS) || 'an unknown OS'
                        };
                    }
                };

            BrowserDetect.init();
            return browserData;

        }

        return {
            getBrowser: getBrowser
        };
    });

/*global angular */
angular.module('constantsSrv', [])
    /**
     * @doc-component service
     * @name gaiafrontend.service.ConstantsSrv
     * @description
     * NewTronian applications service now deprecated.
     */
    .factory('ConstantsSrv', ['HttpSrv', '$q',
        function(HttpSrv, $q) {
            var constantDefSrvBaseUrl = '../api/constantsdef/',
                constants = {};

            function resolveConstant(deferred, constantName) {
                deferred.resolve(constants[constantName]);
            }

            function saveAndResolveConstant(deferred, constantName) {
                return function(constant) {
                    constants[constantName] = constant;
                    deferred.resolve(constants[constantName]);
                };
            }

            function retrieveConstant(deferred, constantName) {
                HttpSrv.get(constantDefSrvBaseUrl + constantName)
                    .then(saveAndResolveConstant(deferred, constantName), deferred.reject);
            }

            function getConstant(constantName) {
                var deferred = $q.defer();

                if (constants[constantName]) {
                    resolveConstant(deferred, constantName);
                } else {
                    retrieveConstant(deferred, constantName);
                }

                return deferred.promise;
            }

            return {
                get: getConstant
            };
        }]);

/*global angular, _, unescape, escape */
/*TODO: REVIEW */
angular.module('cookieSrv', [])
    /**
     * @doc-component service
     * @name gaiafrontend.service.cookieSrv
     * @description
     * Soon...
     */
    .factory('CookieSrv', function() {
         /**
         * @doc-component method
         * @methodOf gaiafrontend.service.cookieSrv
         * @name gaiafrontend.service.cookieSrv#getCookie
         * @param {string} name The name for the cookie to get.
         * @return {string} cookie that matches name parameter.
         * @description
         * This method obtains a cookie from the parameter name.
         */
        function getCookie(name) {
            var i,
                cookie,
                cookieName,
                cookieValue,
                cookiesArray = window.document.cookie.split(';');

            for (i = 0; i < cookiesArray.length; i += 1) {
                cookieName = cookiesArray[i].substr(0, cookiesArray[i].indexOf('='));
                cookieValue = cookiesArray[i].substr(cookiesArray[i].indexOf('=') + 1);
                cookieName = cookieName.replace(/^\s+|\s+$/g, '');
                if (cookieName === name) {
                    try {
                        cookie = angular.isObject(JSON.parse(unescape(cookieValue))) ? JSON.parse(unescape(cookieValue)) : cookieValue;
                    } catch (e) {
                        cookie = unescape(cookieValue);
                    }
                }
            }
            return cookie;
        }
         /**
         * @doc-component method
         * @methodOf gaiafrontend.service.cookieSrv
         * @name gaiafrontend.service.cookieSrv#setCookie
         * @param {string} cookieName The name for the cookie to be set.
         * @param {string} cookieValue The value for the cookie to be set.
         * @param {string=} expires The value for the cookie to be expired.
         * @description
         * This method set a cookie with a name, value and expires values from parameters.
         */
        function setCookie(cookieName, cookieValue, expires) {
            var expirationDate = new Date(),
                finalCookie;

            expirationDate.setTime(expirationDate.getTime() + expires);
            finalCookie = escape(_.isPlainObject(cookieValue) ? JSON.stringify(cookieValue) : cookieValue) + ((expires === null) ? '' : '; expires=' + expirationDate.toUTCString());
            window.document.cookie = cookieName + '=' + finalCookie;
        }
        /**
         * @doc-component method
         * @methodOf gaiafrontend.service.cookieSrv
         * @name gaiafrontend.service.cookieSrv#removeCookie
         * @param {string} cookieName The name for the cookie to be delete.
         * @description
         * This method delete a cookie with a name.
         */
        function removeCookie(cookieName) {
            window.document.cookie = cookieName + '=;expires=Thu, 01 Jan 1970 00:00:01 GMT;';
        }

        return {
            getCookie: getCookie,
            setCookie: setCookie,
            removeCookie: removeCookie
        };
    });

/*global angular */
angular.module('dataSrv', [])
    /**
     * @doc-component service
     * @name gaiafrontend.service.dataSrv
     * @description
     * This service allows you create an object instance of Data.
     * Data is an object that tries to replicate AngularJS Scope inheritance behaviour.
     *
     * Data has the following properties:
     *
     * - `this`. A self reference to the current Data instance.
     * - `$current`. Same as `this`.
     * - `$parent`. A reference to the parent Data instance.
     * - `$name`. The name of the Data instance.
     *
     * A Data object also has a `$new` method.
     * This method receives as an argument the name of the child Data instance we want to create.
     *
     * This service is used to manage the states flow data.
     *
     */
    .factory('DataSrv', function() {
        return {
            /**
             * @doc-component method
             * @methodOf gaiafrontend.service.dataSrv
             * @name gaiafrontend.service.dataSrv#$new
             * @param {string} name The Data instance name property.
             * @param {object=} Data The parent Data instance.
             * @description
             * This method creates a Data instance with the name provided.
             * If a Data instance is also provided, it will be assigned as the parent.
             */
            $new: function $new(name, parentData) {
                var Data = function() {},
                    data;

                if (parentData) {
                    Data.prototype = parentData;
                }
                data = new Data();
                data.$current = data['this'] = data;
                data.$parent = parentData || null;
                data.$name = name;
                data.$new = function (name) {
                    return $new(name, data);
                };

                return data;
            }
        };
    });

/**
     * @doc-component service
     * @name gaiafrontend.value.documentValidator
     * @description
     * Value that exposes a functions to validate a documents. Functions exposed:
     *
     */
/*global angular */
/*jshint maxlen:100 */
(function () {

    'use strict';

    var LETTERS = 'TRWAGMYFPDXBNJZSQVHLCKE';

    angular.module('documentValidator', [])
        .value('DocumentValidator', {
            /**
             * @doc-component method
             * @methodOf gaiafrontend.value.documentValidator
             * @name gaiafrontend.value.documentValidator#nif
             * @param {string} value Fiscal identification number to validate
             * @return {boolean} `true` if the document is `valid`, false otherwise.
             * @description
             * Validate fiscal identification number(DNI).
             */
            nif: function (value) {
                var DNI_REGEX = /^[0-9]{8}[A-Z]{1}$/;

                value = value.toUpperCase();

                if (angular.isDefined(value) && value.length > 0 && DNI_REGEX.test(value)) {
                    return LETTERS.charAt(value.substring(8, 0) % 23) === value.charAt(8);
                }
                return false;
            },
            /**
             * @doc-component method
             * @methodOf gaiafrontend.value.documentValidator
             * @name gaiafrontend.value.documentValidator#nie
             * @param {string} value Foreigner identification number to validate
             * @return {boolean} `true` if the document is `valid`, false otherwise.
             * @description
             * Validate foreigner identification number.
             */
            nie: function (value) {
                var NIE_REGEX = /^[XYZ]{1}[0-9]{7}[A-Z]{1}/;

                value = value.toUpperCase();

                if (angular.isUndefined(value) && value.length < 1 && !NIE_REGEX.test(value)) {
                    return false;
                }
                return value[8] === LETTERS.charAt(value.replace('X', '0')
                                                        .replace('Y', '1')
                                                        .replace('Z', '2').substring(0, 8) % 23);
            }
        });
}());

/*global angular, _ */
angular.module('errorInterceptor', [])
    .constant('ErrorSrvConfig', {
        loginUrl: window.location.pathname
    })
    /**
     * @doc-component service
     * @name gaiafrontend.service.errorSrv
     * @description
     * This service manages $http error responses.
     * It wraps `AlertsSrv` implementation to create error alerts inside `mp-alerts` element from response objects.
     */
    .provider('ErrorSrv', function () {
        var ignoredUrls = ['api/register-event'];

        return {
            ignore: function (urlsArray) {
                Array.prototype.push.apply(ignoredUrls, urlsArray);
            },
            $get: ['$rootScope', 'AlertsSrv', 'Events', '$window', 'ErrorSrvConfig', function ($rootScope, AlertsSrv, Events, $window, ErrorSrvConfig) {
               /**
                * @doc-component method
                * @methodOf gaiafrontend.service.errorSrv
                * @name gaiafrontend.service.errorSrv#getErrorData
                * @param {object} response The response object.
                * @return {object} The `errorData` property of the response body.
                */
                function getErrorData(response) {
                    return response.errorData || (response.data && response.data.errorData);
                }

               /**
                * @doc-component method
                * @methodOf gaiafrontend.service.errorSrv
                * @name gaiafrontend.service.errorSrv#hasErrorData
                * @param {object} response The response object.
                * @return {boolean} `true` if an `errorData` property is defined in the response body. `false` if it is not.
                */
                function hasErrorData(response) {
                    return !!getErrorData(response);
                }

                function createAlert(title, description, errors) {
                    var alert = new AlertsSrv.Alert(title, description);

                    angular.forEach(errors, function (error) {
                        alert.addError(error.description, error.form, error.formControl);
                    });

                    return alert;
                }

                function createErrorsFrom(bindingErrors) {
                    var errors = [];

                    angular.forEach(bindingErrors, function (bindingError) {
                        errors.push({
                            form: bindingError.objectName,
                            formControl: bindingError.field,
                            description: bindingError.defaultMessage
                        });
                    });

                    return errors;
                }

                function broadCastBindingErrors(errorDataItem) {
                    angular.forEach(errorDataItem.bindingErrors, function (bindingError) {
                        $rootScope.$broadcast(Events.$formControlError(bindingError.objectName + bindingError.field), {
                            server: bindingError.defaultMessage
                        });
                    });
                }

                function displayErrorData(response) {
                    var errorData = getErrorData(response);

                    angular.forEach(errorData, function (errorDataItem) {
                        broadCastBindingErrors(errorDataItem);
                        AlertsSrv.error(createAlert('Error ' + errorDataItem.status, errorDataItem.errorMessage || 'An error has occurred. Click on the plus sign at the corner to see the details.', createErrorsFrom(errorDataItem.bindingErrors)), response);
                    });
                }

                function isAborted(response) {
                    return response.status === 0 && response.data === null && _.isEmpty(response.headers());
                }

               /**
                * @doc-component method
                * @methodOf gaiafrontend.service.errorSrv
                * @name gaiafrontend.service.errorSrv#display
                * @param {object} response The response object.
                * @description
                * This method adds a new error alert in `mp-alerts` element. To display a custom error it has to have `errorData` format.
                */
                function display(response) {
                    if (_.contains(ignoredUrls, response.config && response.config.url) || isAborted(response)) {
                        return;
                    }

                    var errorData = getErrorData(response);

                    if (errorData && errorData.length) {
                        displayErrorData(response);
                    } else if (response.status === 401) {
                        $window.location.href = ErrorSrvConfig.loginUrl;
                    } else {
                        AlertsSrv.error(createAlert('Error ' + response.status, 'An unexpected error has occurred. Click on the plus sign at the corner to see the details.'), response);
                    }
                }

                return {
                    getErrorData: getErrorData,
                    hasErrorData: hasErrorData,
                    display: display
                };
            }]
        };
    })
    /**
     * @doc-component service
     * @name gaiafrontend.service.errorInterceptor
     * @description
     * This service is meant to be used as a `$http` interceptor.
     *
     * This interceptor manages GAIA response errors with `ErrorSrv`. It works in conjunction with `mpAlert` directive. This interceptor uses `AlertsSrv` to add errors to `mp-alerts` element.
     *
     * To use this interceptor in your application you only have to add this service to the `$httpProvider.interceptors` Array of your application like follows:
     *
     *  ```js
     *  var appModule = angular.module('myAppName', ['gaiafrontend']);
     *  appModule
     *     .config(['$httpProvider', function ($httpProvider) {
     *         $httpProvider.interceptors.push('ErrorInterceptor');
     *     ]);
     *  ```
     *
     * If we need `ErrorInterceptor` to ignore response errors from spcific URLs we only have to add these URLs like this:
     *
     *  ```js
     *  var appModule = angular.module('myAppName', ['gaiafrontend']);
     *  appModule
     *     .config(['ErrorSrvProvider', function (ErrorSrvProvider) {
     *         ErrorSrvProvider.ignore(['url/to/ignore']);
     *     ]);
     *  ```
     */
    .factory('ErrorInterceptor', ['ErrorSrv', '$q', function (ErrorSrv, $q) {
        function responseErrorInterceptor(rejection) {
            ErrorSrv.display(rejection);
            return $q.reject(rejection);
        }

        function responseInterceptor(response) {
            if (ErrorSrv.hasErrorData(response)) {
                return responseErrorInterceptor(response);
            }

            return response;
        }

        return {
            response: responseInterceptor,
            responseError: responseErrorInterceptor
        };
    }])

/*global angular */
'use strict';
angular.module('exportDataToCSVSrv', [])
    /**
     * @doc-component service
     * @name gaiafrontend.service.exportDataToCSVSrv
     * @description
     * This service is available in "GAIA Site"
     * There you will find its documentation and several examples.
     * "GAIA Site" is an application created by the Architecture Area to learn and play with GAIA. Is available in RAS. Direct links are available below in this page.
     */
    .factory('ExportDataToCSVSrv', ['BrowserDetectSrv', function(BrowserDetectSrv) {
        var sepCharacter = ',';

        function createString(grid, colNames, cellName) {
            var str = '',
                array = grid.data,
                i, index, line = '';
            for (i = 0; i < array.length; i++) {
                line = '';
                for (index = 0; index < cellName.length; index++) {
                    line += array[i][cellName[index].name] + sepCharacter;
                }
                str += line + '\r\n';
            }
            str = colNames.toString().replace(/,/g, sepCharacter) + '\r\n' + str;
            return str;
        }

        function mozCSV(oData) {
            var uri = 'data:application/csv;charset=utf-8,' + encodeURI(oData),
                olink = document.createElement("a");
            olink.href = uri;
            olink.download = "data.csv";
            document.body.appendChild(olink);
            olink.click();
            document.body.removeChild(olink);
        }

        function ieCSV(oData) {
            var w = window.open(),
                doc = w.document,
                uri = 'data:application/csv;charset=utf-8';
            doc.open(uri, 'replace');
            doc.write(oData);
            doc.close();
            doc.execCommand("SaveAs", null, 'data.csv');
            w.close();
        }

        function exportData(grid, character) {
            var browserDetectSrv = {};

            if (!angular.isUndefined(character))
                sepCharacter = character;

            browserDetectSrv = BrowserDetectSrv.getBrowser();

            /* TODO: This must be replaced by the browserDetectSrv */
            if (navigator.userAgent.indexOf('MSIE') !== -1)
                ieCSV(createString(grid, grid.options.colNames, grid.options.colModel))
            else
                mozCSV(createString(grid, grid.options.colNames, grid.options.colModel));
        }

        return {
            exportData: exportData
        }
    }]);

/*global angular, _ */
angular.module('httpInterceptor', [])
    /**
     * @doc-component service
     * @name gaiafrontend.service.httpInterceptor
     * @description
     * DEPRECATED.
     *
     * See *i18nInterceptor*, *ErrorInterceptor*, *GaiaFormNameInterceptor*, *NwtErrorInterceptor* and *ThemeInterceptor*.
     */
    .provider('HttpInterceptor', function() {
        var UNAUTHORIZED_CODE = 401,
            options = {
                suffixLanguageToHTMLsAndJSONs: false,
                interceptGaiaFormName: false,
                setThemeOnResponse: false,
                redirectWhenUnauthorized: false,
                redirectionUrl: '#/login',
                ignoreErrors: false,
                ignoredUrls: ['api/register-event']
            };

        function setOption(opt, value) {
            options[opt] = value;
        }

        function setOptions(opts) {
            _.extend(options, opts);
        }

        function set(arg1, arg2) {
            if (_.isPlainObject(arg1)) {
                setOptions(arg1);
            } else if (_.isString(arg1) && !_.isUndefined(arg2)) {
                setOption(arg1, arg2);
            }
        }

        return {
            set: set,
            $get: ['$q', '$window', '$rootScope', 'AlertsSrv', 'Theme', 'Language', 'Events',
                function($q, $window, $rootScope, AlertsSrv, Theme, Language, Events) {
                    var cache = {};

                    function isHtmlOrJsonRequest(config) {
                        var method = config.method,
                            url = config.url;

                        return method === 'GET' && (url.indexOf('.html') > -1 || url.indexOf('messages.json') > -1);
                    }

                    function isNotUIBootstrapTpl(config) {
                        return config.url.indexOf('template/') !== 0;
                    }

                    function isNotAngularStrapTpl(config) {
                        var notAngularStrapTpl = true;

                        if (config.url === 'aside/aside.tpl.html' ||
                                config.url === 'alert/alert.tpl.html' ||
                                config.url === 'datepicker/datepicker.tpl.html' ||
                                config.url === 'dropdown/dropdown.tpl.html' ||
                                config.url === 'modal/modal.tpl.html' ||
                                config.url === 'popover/popover.tpl.html' ||
                                config.url === 'select/select.tpl.html' ||
                                config.url === 'tab/tab.tpl.html' ||
                                config.url === 'timepicker/timepicker.tpl.html' ||
                                config.url === 'tooltip/tooltip.tpl.html' ||
                                config.url === 'typeahead/typeahead.tpl.html') {
                            notAngularStrapTpl = false;
                        }

                        return notAngularStrapTpl;
                    }

                    function suffixLanguage(config) {
                        var url = config.url,
                            language = Language.get().languageId,
                            filePath = url.substring(0, url.lastIndexOf('.')),
                            extension = url.substring(url.lastIndexOf('.')),
                            languageSuffix = language ? '_' + language : '';

                        config.url = filePath + languageSuffix + extension;
                    }

                    function findGaiaFormNameObject(data) {
                        var gaiaFormName;

                        _.each(data, function(element) {
                            gaiaFormName = _.isPlainObject(element) && element.gaiaFormName ? element : undefined;
                            return !gaiaFormName;
                        });

                        return gaiaFormName;
                    }

                    function findGaiaFormNameIndex(data) {
                        var gaiaFormNameIndex;

                        _.each(data, function(element, index) {
                            gaiaFormNameIndex = _.isPlainObject(element) && element.gaiaFormName ? index : -1;
                            return gaiaFormNameIndex !== -1 ? false : true;
                        });

                        return gaiaFormNameIndex;
                    }

                    function getGaiaFormName(configData) {
                        var data = configData && configData.data ? configData.data : configData,
                            gaiaFormName;

                        if (_.isArray(data)) {
                            gaiaFormName = (findGaiaFormNameObject(data) || {}).gaiaFormName;
                        } else if (_.isPlainObject(data)) {
                            gaiaFormName = data.gaiaFormName;
                        }

                        return gaiaFormName;
                    }

                    function saveLastGaiaFormSent(url, gaiaFormName) {
                        cache.lastGaiaFormSent = cache.lastGaiaFormSent || {};
                        cache.lastGaiaFormSent.url = url;
                        cache.lastGaiaFormSent.gaiaFormName = gaiaFormName;
                    }

                    function removeGaiaFormName(configData) {
                        var data = configData && configData.data ? configData.data : configData;

                        if (_.isArray(data)) {
                            delete (data[findGaiaFormNameIndex(data)] || {}).gaiaFormName;
                        } else if (_.isPlainObject(data)) {
                            delete data.gaiaFormName;
                        }

                        return data;
                    }

                    function saveAndRemoveGaiaFormName(config, gaiaFormName) {
                        saveLastGaiaFormSent(config.url, gaiaFormName);
                        removeGaiaFormName(config.data);
                    }

                    function retrieveLastGaiaFormSent() {
                        var lastGaiaFormSent = angular.copy(cache.lastGaiaFormSent);
                        delete cache.lastGaiaFormSent;
                        return lastGaiaFormSent;
                    }

                    function defaultErrorData(status) {
                        return {
                            'title': 'Server error',
                            'description': 'An error (' + status + ') has occurred. Please, try again later.'
                        };
                    }

                    function serverValidationErrorData(error) {

                        function parseBindingErrors(bindingErrors) {
                            var parsedBindingErrors = [];

                            angular.forEach(bindingErrors, function (bindingError) {
                                parsedBindingErrors.push({
                                    form: bindingError.objectName,
                                    formControl: bindingError.field,
                                    description: bindingError.defaultMessage
                                });
                            });

                            return parsedBindingErrors;
                        }

                        return {
                            'title': 'Server validation error',
                            'description': error.errorMessage || 'An error has occurred. Please, check the following data:',
                            'errors': parseBindingErrors(error.bindingErrors)
                        };
                    }

                    function displayError(error, response) {
                        var responseUrl = response.config ? response.config.url : '',
                            errorAlertData = {};

                        function urlHasToBeIgnored(url) {
                            return !!_.find(options.ignoredUrls, function (urlToIgnore) {
                                return url.indexOf(urlToIgnore) > -1;
                            });
                        }

                        function isErrorData(error) {
                            return _.isArray(error);
                        }

                        function createErrorDataAlert(error) {
                            var errorData = angular.copy(error);

                            function setValidationErrors(errorData) {
                                _.each(errorData, function(error) {
                                    var lastGaiaFormSent = retrieveLastGaiaFormSent() || {};

                                    function hasValidationErrors(error) {
                                        return !!error.bindingErrors;
                                    }

                                    function setObjectNameProperty(error) {
                                        _.each(error.bindingErrors, function(validationError) {
                                            validationError.objectName = validationError.objectName || (lastGaiaFormSent.url === responseUrl && lastGaiaFormSent.gaiaFormName);
                                        });
                                    }

                                    if (hasValidationErrors(error)) {
                                        setObjectNameProperty(error);
                                    }
                                });
                            }

                            if (options.interceptGaiaFormName) {
                                setValidationErrors(errorData);
                            }

                            return errorData;
                        }

                        if (options.ignoreErrors && urlHasToBeIgnored(responseUrl)) {
                            return;
                        }

                        if (isErrorData(error)) {
                            _.extend(errorAlertData, createErrorDataAlert(error));
                            angular.forEach(errorAlertData, function(error) {
                                angular.forEach(error.bindingErrors, function (bindingError) {
                                    $rootScope.$broadcast(Events.$formControlError(bindingError.objectName + bindingError.field), {
                                        server: bindingError.defaultMessage
                                    });
                                });
                                AlertsSrv.error(serverValidationErrorData(error), response);
                            });
                        } else {
                            _.extend(errorAlertData, error);
                            AlertsSrv.error(serverValidationErrorData(errorAlertData), response);
                        }
                    }

                    function saveDestinationUrlAndRedirectToLogin() {
                        cache.destinationUrl = $window.location.hash;
                        $window.location = options.redirectionUrl;
                    }

                    function getDestinationUrl() {
                        return cache.destinationUrl;
                    }

                    return {
                        getDestinationUrl: getDestinationUrl,
                        request: function(config) {
                            var gaiaFormName = getGaiaFormName(config.data);

                            if (options.suffixLanguageToHTMLsAndJSONs && isHtmlOrJsonRequest(config) && isNotUIBootstrapTpl(config) && isNotAngularStrapTpl(config)) {
                                suffixLanguage(config);
                            }

                            if (options.interceptGaiaFormName && gaiaFormName) {
                                saveAndRemoveGaiaFormName(config, gaiaFormName);
                            }

                            return config;
                        },
                        response: function(response) {
                            var errorData = response.data.errorData,
                                themeId = response.headers('X-User-theme');

                            if (options.setThemeOnResponse && themeId && themeId !== Theme.get()) {
                                Theme.set(themeId);
                            }

                            if (errorData) {
                                displayError(errorData, response);
                                return $q.reject(response);
                            }

                            return response;
                        },
                        responseError: function(rejection) {
                            var status = rejection.status,
                                error = rejection.data && rejection.data.errorData ? rejection.data.errorData : defaultErrorData(status);

                            if (options.redirectWhenUnauthorized && status === UNAUTHORIZED_CODE) {
                                saveDestinationUrlAndRedirectToLogin();
                            } else {
                                displayError(error, rejection);
                            }

                            return $q.reject(rejection);
                        }
                    };
                }]
        };
    });

/*TODO: WebFlow management */
/*global angular, _ */
angular.module('httpSrv', [])
    .constant('HttpSrvConfig', {
        wrapRequests: 'smart',
        unwrapResponses: true
    })
    /**
     * @doc-component service
     * @name gaiafrontend.service.httpSrv
     * @description
     * This service is meant to be used to communicate with GAIA server side applications.
     *
     * It wraps the original request body with a `data` property and extract the `data` property value from the response body.
     *
     * This behaviour can be modified by changing the `HttpSrvConfig` constant object.
     * You can disable the request wrapping by changing `HttpSrvConfig.wrapRequests` property to `false`.
     * You can disable the response unwrapping by changing `HttpSrvConfig.unwrapResponses` property to `false`.
     *
     * It is recommended to change the default behaviour in the `config` method of the main AngularJS module of the application.
     *
     */
    .factory('HttpSrv', ['$http', '$q', 'HttpSrvConfig',
        function($http, $q, HttpSrvConfig) {
            function getData(obj) {
                var data = angular.copy(obj) || {};

                while (angular.isObject(data) && data.data) {
                    data = data.data;
                }

                return data;
            }

            function includeParamsInUrl(params, url) {
                var finalUrl = url;

                if (params) {
                    _.each(_.keys(params), function(param) {
                        var paramRegExp = new RegExp(':' + param, 'g');

                        finalUrl = finalUrl.replace(paramRegExp, params[param]);
                    });
                }

                return finalUrl;
            }

            function isWebFlow(response) {
                return !!response.flowData;
            }

            function resolve(deferred) {
                return function(response) {
                    if (isWebFlow(response)) {
                        deferred.resolve(response);
                    } else {
                        deferred.resolve(HttpSrvConfig.unwrapResponses === true ? response.data || response : response);
                    }
                };
            }

            function reject(deferred) {
                return function(error) {
                    deferred.reject(error && error.errorData ? error.errorData : error);
                };
            }

            function httpWrapper(method, url, dataOrConfig, config) {
                var deferred = $q.defer();

                $http[method](url, dataOrConfig, config)
                    .success(resolve(deferred))
                    .error(reject(deferred));

                return deferred.promise;
            }

            /**
             * @doc-component method
             * @methodOf gaiafrontend.service.httpSrv
             * @name gaiafrontend.service.httpSrv#get
             * @param {string} url Url of the requested resource.
             * @param {object} params Map of variables to replace in an url with placeholders. The url placeholders follow the pattern `:placholder`. For example, if the url is "api/:companyName/:employeeId" and the params object is {companyName: "MAPFRE", employeeId: "123"} the final url will be "api/MAPFRE/123".
             * @param {object} config Object describing the request to be made and how it should be processed. You can see its supported properties [here](https://code.angularjs.org/1.2.16/docs/api/ng/service/$http#usage).
             * @return {promise} An $http promise.
             * @description
             * Shortcut method to perform GET request.
             */
            function httpGet(url, params, config) {
                return httpWrapper('get', includeParamsInUrl(params, url), config);
            }

            /**
             * @doc-component method
             * @methodOf gaiafrontend.service.httpSrv
             * @name gaiafrontend.service.httpSrv#delete
             * @param {string} url Url of the requested resource.
             * @param {object} params Map of variables to replace in an url with placeholders. The url placeholders follow the pattern `:placholder`. For example, if the url is "api/:companyName/:employeeId" and the params object is {companyName: "MAPFRE", employeeId: "123"} the final url will be "api/MAPFRE/123".
             * @param {object} config Object describing the request to be made and how it should be processed. You can see its supported properties [here](https://code.angularjs.org/1.2.16/docs/api/ng/service/$http#usage).
             * @return {promise} It will pass the requested dictionary object to the success callback.
             * @description
             * Shortcut method to perform DELETE request.
             */
            function httpDelete(url, params, config) {
                return httpWrapper('delete', includeParamsInUrl(params, url), config);
            }

            /**
             * @doc-component method
             * @methodOf gaiafrontend.service.httpSrv
             * @name gaiafrontend.service.httpSrv#head
             * @param {string} url Url of the requested resource.
             * @param {object} params Map of variables to replace in an url with placeholders. The url placeholders follow the pattern `:placholder`. For example, if the url is "api/:companyName/:employeeId" and the params object is {companyName: "MAPFRE", employeeId: "123"} the final url will be "api/MAPFRE/123".
             * @param {object} config Object describing the request to be made and how it should be processed. You can see its supported properties [here](https://code.angularjs.org/1.2.16/docs/api/ng/service/$http#usage).
             * @return {promise} It will pass the requested dictionary object to the success callback.
             * @description
             * Shortcut method to perform HEAD request.
             */
            function httpHead(url, params, config) {
                return httpWrapper('head', includeParamsInUrl(params, url), config);
            }

            /**
             * @doc-component method
             * @methodOf gaiafrontend.service.httpSrv
             * @name gaiafrontend.service.httpSrv#jsonp
             * @param {string} url Url of the requested resource.
             * @param {object} params Map of variables to replace in an url with placeholders. The url placeholders follow the pattern `:placholder`. For example, if the url is "api/:companyName/:employeeId" and the params object is {companyName: "MAPFRE", employeeId: "123"} the final url will be "api/MAPFRE/123".
             * @param {object} config Object describing the request to be made and how it should be processed. You can see its supported properties [here](https://code.angularjs.org/1.2.16/docs/api/ng/service/$http#usage).
             * @return {promise} It will pass the requested dictionary object to the success callback.
             * @description
             * Shortcut method to perform JSONP request.
             */
            function httpJsonp(url, params, config) {
                return httpWrapper('jsonp', includeParamsInUrl(params, url), config);
            }

            /**
             * @doc-component method
             * @methodOf gaiafrontend.service.httpSrv
             * @name gaiafrontend.service.httpSrv#post
             * @param {string} url Url of the requested resource.
             * @param {object} params Map of variables to replace in an url with placeholders. The url placeholders follow the pattern `:placholder`. For example, if the url is "api/:companyName/:employeeId" and the params object is {companyName: "MAPFRE", employeeId: "123"} the final url will be "api/MAPFRE/123".
             * @param {object} config Object describing the request to be made and how it should be processed. You can see its supported properties [here](https://code.angularjs.org/1.2.16/docs/api/ng/service/$http#usage).
             * @return {promise} It will pass the requested dictionary object to the success callback.
             * @description
             * Shortcut method to perform POST request.
             */
            function httpPost(url, data, params, config) {
                return httpWrapper('post', includeParamsInUrl(params, url), HttpSrvConfig.wrapRequests === 'smart' ? {data: getData(data)} : HttpSrvConfig.wrapRequests === true ? {data: data} : data, config);
            }

            /**
             * @doc-component method
             * @methodOf gaiafrontend.service.httpSrv
             * @name gaiafrontend.service.httpSrv#put
             * @param {string} url Url of the requested resource.
             * @param {object} params Map of variables to replace in an url with placeholders. The url placeholders follow the pattern `:placholder`. For example, if the url is "api/:companyName/:employeeId" and the params object is {companyName: "MAPFRE", employeeId: "123"} the final url will be "api/MAPFRE/123".
             * @param {object} config Object describing the request to be made and how it should be processed. You can see its supported properties [here](https://code.angularjs.org/1.2.16/docs/api/ng/service/$http#usage).
             * @return {promise} It will pass the requested dictionary object to the success callback.
             * @description
             * Shortcut method to perform PUT request.
             */
            function httpPut(url, data, params, config) {
                return httpWrapper('put', includeParamsInUrl(params, url), HttpSrvConfig.wrapRequests === 'smart' ? {data: getData(data)} : HttpSrvConfig.wrapRequests === true ? {data: data} : data, config);
            }

            return {
                get: httpGet,
                'delete': httpDelete,
                head: httpHead,
                jsonp: httpJsonp,
                post: httpPost,
                put: httpPut
            };
        }]);

/*TODO: Review. See current angular-translate project (https://github.com/angular-translate/angular-translate). It now supports asynchronous loading */
/*global angular */
angular.module('i18n', [])
    /**
     * @doc-component service
     * @name gaiafrontend.service.i18n
     * @description
     * This service manages the dictionary used by Pascal Precht 'translate' filter.
     *
     * It is used by the framework when navigating to a state with a 'dictionary' property defined in its state object (or in any of its parent states).
     */
    .provider('i18n', function () {
        var translateProvider = {};

        function setTranslateProviderTranslations(translations) {
            translateProvider.translations = translations;
        }

        return {
            setTranslateProviderTranslations: setTranslateProviderTranslations,
            $get: ['Language', '$q', 'HttpSrv', function (Language, $q, HttpSrv) {
                function setDictionary(dictionary) {
                    var lang = Language.get().languageId;
                    translateProvider.translations(lang, dictionary);
                }

                /**
                 * @doc-component method
                 * @methodOf gaiafrontend.service.i18n
                 * @name gaiafrontend.service.i18n#getDictionary
                 * @param {string} url Url to the JSON dictionary.
                 * @return {promise} It will pass the requested dictionary object to the success callback.
                 * @description
                 * This method obtains the requested dictionary JSON.
                 * If succeeds it will be registered in $translateProvider.
                 */
                function getDictionary() {
                    var urls = Array.prototype.slice.call(arguments),
                        deferred = $q.defer();

                    if (urls.length) {
                        var dictionaryPromises = _.map(urls, function (url) {
                            return HttpSrv.get(url);
                        })

                        $q.all(dictionaryPromises)
                            .then(function (dictionaries) {
                                var dictionary = angular.extend.apply(null, Array.prototype.concat({}, dictionaries));
                                setDictionary(dictionary);
                                deferred.resolve(dictionary);
                            }, deferred.reject);
                    }

                    return deferred.promise;
                }

                return {
                    getDictionary: getDictionary
                };
            }]
        };
    });

/*global angular */
angular.module('i18nInterceptor', [])
    /**
     * @doc-component service
     * @name gaiafrontend.service.i18nInterceptor
     * @description
     * This service is meant to be used as a `$http` interceptor.
     *
     * This interceptor affixes the language/locale to some resources so GAIA internationalization works as intended.
     *
     * To use this interceptor in your application you only have to add this service to the `$httpProvider.interceptor` Array of your application as follows:
     *
     *  ```js
     *  var appModule = angular.module('myAppName', ['gaiafrontend']);
     *  appModule
     *     .config(['$httpProvider', function ($httpProvider) {
     *         $httpProvider.interceptors.push('i18nInterceptor');
     *     ]);
     *  ```
     */
    .factory('i18nInterceptor', ['Language', function (Language) {
        function isDictionaryRequest(config) {
            var jsonRegExp = new RegExp('messages\\.json(\\?.*)?', 'g');
            return config.method === 'GET' && jsonRegExp.test(config.url);
        }

        function isHtmlRequest(config) {
            var htmlRegExp = new RegExp('\\.html(\\?.*)?', 'g');
            return config.method === 'GET' && htmlRegExp.test(config.url);
        }

        function isVendorTpl(config) {
            // ui.bootstrap templates pattern: template/*/*.html
            // mgcrea.ngStrap templates pattern: */*.tpl.html
            var tplRegExp = new RegExp('(template\\/.*\\/.*\\.html|.*\\/.*\\.tpl\\.html)(\\?.*)?');
            return config.method === 'GET' && tplRegExp.test(config.url);
        }

        function affixLanguage(config) {
            var urlRegExp = new RegExp('(.*\\/)*(.*)(\\..*$)'),
                urlParts = config.url.match(urlRegExp),
                filePath = urlParts[1],
                fileName = urlParts[2],
                extension = urlParts[3],
                language = Language.get(),
                languageId = language.languageId,
                countryId = language.countryId,
                languageAffix = '';

                if (languageId) {
                    languageAffix += '_' + languageId;
                }

                if (countryId) {
                    languageAffix += '-' + countryId;
                }

            config.url = filePath + fileName + languageAffix + extension;
        }

        return {
            request: function(config) {
                if (isDictionaryRequest(config) || (isHtmlRequest(config) && !isVendorTpl(config))) {
                    affixLanguage(config);
                }

                return config;
            }
        };
    }]);

/*global angular, _ */
angular.module('language', [])
    .constant('LanguageConfig', {
        COOKIE_NAME: 'gaiaLanguage',
        // WARNING! Any change made in LanguageConfig.supportedLanguages involve changes in gaiafrontend/js/vendor/components/i18n folder (in angular-locale files).
        supportedLanguages: ['en','es','pt','tr','fr','it','el','de','zh','nl','ar','sv','ru']
    })
    /**
     * @doc-component service
     * @name gaiafrontend.service.language
     * @description
     * This service manages the application language. A lot of services dependes on `Language`.
     */
    .factory('Language', ['$window', '$locale', '$rootScope', '$timeout', '$translate', 'CookieSrv', 'LanguageConfig', 'Events', 'Loader',
        function($window, $locale, $rootScope, $timeout, $translate, CookieSrv, LanguageConfig, Events, Loader) {
            // userLanguage is for IE8
            var browsersLanguage = $window.navigator.language || $window.navigator.userLanguage,
                initialLanguage = CookieSrv.getCookie(LanguageConfig.COOKIE_NAME) || browsersLanguage,
                supportedLanguages = angular.isDefined($window.gaiaapplication) ? $window.gaiaapplication.languages.toLowerCase().split(',') : LanguageConfig.supportedLanguages,
                languageRegExp = /([A-Za-z]{2,3})-?([A-Za-z]{2,3})?/,
                locale = {
                    languageId: '',
                    countryId: ''
                };

            function isLanguageSupported(supportedLanguages, language) {
                return _.find(supportedLanguages, function (supportedLanguage) {
                    return supportedLanguage === language;
                });
            }

            function estimateLanguage (language) {
                var matches = language.match(languageRegExp);
                if (isLanguageSupported(supportedLanguages, matches[1])) {
                    return matches[1];
                } else {
                    return supportedLanguages[0];
                }
            }

            function saveLocale(languageId, countryId) {
                var baseUrl = 'i18n/angular-locale_languageId-countryId.js',
                    localeString = countryId ? languageId + '-' + countryId : languageId;

                if (languageId === locale.languageId && countryId === locale.countryId) {
                    return;
                }

                if (!isLanguageSupported(supportedLanguages, localeString)) {
                    languageId = estimateLanguage(localeString);
                    countryId = '';
                    localeString = languageId;
                }

                // Save in locale object the currant language
                locale.languageId = languageId;
                locale.countryId = countryId;
                // Tell translate filter which language to use
                $translate.uses(localeString);
                // Set a cookie with the current language
                CookieSrv.setCookie(LanguageConfig.COOKIE_NAME, localeString);
                // Retrieve the angular-locale file
                Loader.load(baseUrl.replace('languageId', languageId).replace('-countryId', countryId ? '-' + countryId : ''))
                    .then(function() {
                        // replace the current $locale
                        angular.extend($locale, angular.injector(['ngLocale']).get('$locale'));
                        // Notify the application that the current language has been changed
                        $rootScope.$emit(Events.$languageChanged);
                    });
            }

            /**
             * @doc-component method
             * @methodOf gaiafrontend.service.language
             * @name gaiafrontend.service.language#set
             * @param {string} language Language to be set as locale. The language set might be in one of the following formats: 'languageId' or 'languageId-countryId'.
             * @description
             * This method sets the web application locale object.
             * If the language we are trying to set is not available it will be set in english ('en').
             * A cookie `LanguageConfig.COOKIE_NAME` is set with the current locale.
             * An event `Events.$languageChanged` is emitted every time the method is called.
             */
            function setLanguage(language) {
                var matches = language.match(languageRegExp),
                    languageId = (matches[1] || supportedLanguages[0]).toLowerCase(),
                    countryId = (matches[2] || '').toLowerCase();

                saveLocale(languageId, countryId);
            }

            /**
             * @doc-component method
             * @methodOf gaiafrontend.service.language
             * @name gaiafrontend.service.language#get
             * @return {object} Current locale object
             * @description
             * This method obtains the web application locale object.
             */

            function getLanguage() {
                return locale;
            }

            // Defaults locale object with language-cookie > browser language
            setLanguage(initialLanguage);

            return {
                set: setLanguage,
                get: getLanguage,
                /*TODO: DEPRECATE */
                LANGUAGE_CHANGED_EVENT: Events.$languageChanged
            };
        }]);

/*global angular, localStorage */
angular.module('localStorageSrv', [])
    /**
     * @doc-component service
     * @name gaiafrontend.service.localStorageSrv
     * @description
     * This service allows manage localStorage
     */
    .factory('LocalStorageSrv', ['$location', function ($location) {

         /**
         * @doc-component method
         * @methodOf gaiafrontend.service.localStorageSrv
         * @name gaiafrontend.service.localStorageSrv#get
         * @param {string} key The identifier we want recover from localStorage.
         * @return {object} object that matches key parameter.
         * @description
         * This method recover the property key from localStorage
         */
        function get(key) {
            return JSON.parse(localStorage.getItem(key));
        }

        /**
         * @doc-component method
         * @methodOf gaiafrontend.service.localStorageSrv
         * @name gaiafrontend.service.localStorageSrv#set
         * @param {string} key The identifier we want to save in localStorage.
         * @param {object} object The object we want to save.
         * @return {object} object with boolean result, and error message if it happens.
         * {
         *      result: "true/false",
         *      message: "message"
         * }
         * @description
         * This method save the object in the property key in localStorage
         */
        function set(key, object) {
            //localStorage.setItem(key, JSON.stringify(object));

            try {
                localStorage.setItem(key, JSON.stringify(object));
                return {result: true, message: 'success'};
            } catch (e) {
                return {result: false, message: e.message};
            }
        }

        /**
         * @doc-component method
         * @methodOf gaiafrontend.service.localStorageSrv
         * @name gaiafrontend.service.localStorageSrv#removeItem
         * @param {string} key The identifier we want remove in localStorage.
         * @description
         * This method removes the property key in localStorage
         */
        function removeItem(key) {
            localStorage.removeItem(key);
        }

        /**
         * @doc-component method
         * @methodOf gaiafrontend.service.localStorageSrv
         * @name gaiafrontend.service.localStorageSrv#getKey
         * @return {string} string contains absolut app URL.
         * @description
         * This method obtains the key to save data
         */
        function getKey() {
            return $location.absUrl();
        }


        /* Disabled
            function clear() {
                return localStorage.clear();
            }
        */

        return {
            get: get,
            set: set,
            removeItem: removeItem,
            getKey: getKey
        };
    }]);

/*TODO: Review */
/*global angular, _ */
angular.module('loggerSrv', [])
    .constant('LoggerConfig', {
        monitoringDelay: 60000
    })
    /**
     * @doc-component service
     * @name gaiafrontend.service.loggerSrv
     * @description
     * This service allows you to POST to "api/register-event" any relevant information.
     * This information is logged in the server side.
     */
    .factory('LoggerSrv', ['HttpSrv', 'LoggerConfig', '$timeout', '$window',
        function(HttpSrv, LoggerConfig, $timeout, $window) {
            var registerEventUrl = 'api/register-event',
                firstPerformance = true,
                monitoringPerformance = false,
                monitoringPromise;

            function getErrorItem(responseData, item) {
                var response = responseData.errorData[item];

                return response || '';
            }

            function getErrorMessage(responseData) {
                if (responseData.errorData) {
                    return getErrorItem(responseData, 'errorMessage');
                }
                return 'Unknown error';
            }

            function getErrorCode(responseData) {
                if (responseData.errorData) {
                    return getErrorItem(responseData, 'errorCode');
                }
                return 'Unknown error code';
            }

            function errorMessage(responseData) {
                return {
                    'logLevel': 'ERROR',
                    'errorCode': getErrorCode(responseData),
                    'message': getErrorMessage(responseData),
                    'messageDescription': getErrorMessage(responseData)
                };
            }

            function infoMessage(description, data) {
                return {
                    'logLevel': 'INFO',
                    'message': description,
                    'data': data
                };
            }

            function performanceMessage(performanceObject) {
                var performanceData;

                if (firstPerformance) {
                    firstPerformance = false;
                    performanceData = performanceObject;
                } else {
                    performanceData = _.pick(performanceObject, 'memory');
                }

                return {
                    'logLevel': 'INFO',
                    'performanceInfo': performanceData
                };
            }

            function postLog(message) {
                HttpSrv.post(registerEventUrl, {
                    data: message
                });
            }

            /**
             * @doc-component method
             * @methodOf gaiafrontend.service.loggerSrv
             * @name gaiafrontend.service.loggerSrv#error
             * @param {object} responseData response where message error is obtained.
             * @description
             * This method POSTs an error message to "api/register-event".
             */
            function logError(responseData) {
                var message = errorMessage(responseData);
                postLog(message);
            }

            /**
             * @doc-component method
             * @methodOf gaiafrontend.service.loggerSrv
             * @name gaiafrontend.service.loggerSrv#info
             * @param {object} responseData response where message information is obtained.
             * @description
             * This method POSTs an info message to "api/register-event".
             */
            function logInfo(description, data) {
                var message = infoMessage(description, data);
                postLog(message);
            }

            /**
             * @doc-component method
             * @methodOf gaiafrontend.service.loggerSrv
             * @name gaiafrontend.service.loggerSrv#performance
             * @description
             * This method POSTs the browser performance (<IE9 not allowed) to "api/register-event".
             */
            function performance() {
                var performanceObject = $window.performance || {}, // In <IE9 window.performance is undefined
                    message = performanceMessage(performanceObject);

                postLog(message);
            }

            function performanceTimeout() {
                performance();
                monitoringPromise = $timeout(performanceTimeout, LoggerConfig.monitoringDelay);
            }

            /**
             * @doc-component method
             * @methodOf gaiafrontend.service.loggerSrv
             * @name gaiafrontend.service.loggerSrv#monitorPerformance
             * @description
             * This method POSTs the browser performance (<IE9 not allowed) to "api/register-event" every fixed milliseconds.
             * The milliseconds interval can becondifured via `monitoringDelay` property of `LoggerConfig` constant.
             */
            function monitorPerformance(monitor) {
                if (monitor === monitoringPerformance) {
                    return;
                }

                if (monitor) {
                    performanceTimeout();
                } else {
                    $timeout.cancel(monitoringPromise);
                }

                monitoringPerformance = monitor;

            }

            return {
                error: logError,
                log: logInfo,
                monitorPerformance: monitorPerformance,
                performance: performance
            };
        }]);

/*global angular */
angular.module('objectDefSrv', [])
    /**
     * @doc-component service
     * @name gaiafrontend.service.ObjectDefSrv
     * @description
     * NewTronian applications service now deprecated.
     */
    .factory('ObjectDefSrv', ['HttpSrv', '$q',
        function(HttpSrv, $q) {
            var objectDefSrvBaseUrl = '../api/objectdef/',
                objectDefinitions = {};

            function resolveObjectDefinition(deferred, objectName) {
                deferred.resolve(angular.copy(objectDefinitions[objectName]));
            }

            function saveAndResolveObjectDefinition(deferred, objectName) {
                return function(objectDefinition) {
                    objectDefinitions[objectName] = objectDefinition;
                    deferred.resolve(angular.copy(objectDefinitions[objectName]));
                };
            }

            function retireveObjectDefinition(deferred, objectName) {
                HttpSrv.get(objectDefSrvBaseUrl + objectName)
                    .then(saveAndResolveObjectDefinition(deferred, objectName), deferred.reject);
            }

            function newObject(objectName) {
                var deferred = $q.defer();

                if (objectDefinitions[objectName]) {
                    resolveObjectDefinition(deferred, objectName);
                } else {
                    retireveObjectDefinition(deferred, objectName);
                }

                return deferred.promise;
            }

            return {
                newObject: newObject
            };
        }]);

/*global angular */
angular.module('parallelNavigationSrv', [])
    /**
     * @doc-component service
     * @name gaiafrontend.service.ParallelNavigationSrv
     * @description
     * This service lets mantaining a parallel navigation among processes, keeping the data in the aplication's flow.
     *
     * To use this service in your application you only have to add it into the Array of your application as follows:
     *
     *  ```js
     *  (appModule.lazy || appModule)
     *     .controller('myControllerName', ['ParallelNavigationSrv', function (parallelNavigationSrv) {
     *          parallelNavigationSrv('state', data);
     *     }]);
     *  ```
     */
    .factory('ParallelNavigationSrv', ['$q', '$state', '$window', function($q, $state, $window) {
        return function(state, data) {
            var deferred = $q.defer(),
                body,
                bodyContent,
                iframe;

            function removeParallelNavigation() {
                iframe.remove();
                iframe = null;
                body.removeAttr('style');
                body = null;
                bodyContent.show();
                bodyContent = null;
            }

            (function createParallelNavigation() {
                body = angular.element('body').attr('style', 'padding: 0; margin: 0; overflow: hidden;');
                bodyContent = angular.element('body').children().hide();
                iframe = angular.element('<iframe />')
                    // IE8 FIX
                    //FF FIX use $window.innerXXX
                    .attr('frameBorder', '0')
                    .attr('style', 'border: 0')
                    .attr('width', $window.innerWidth)
                    .attr('height', $window.innerHeight).appendTo(body);
                // IE8 FIX
                iframe[0].contentWindow.document.location = window.document.location.href.split(window.document.location.hash)[0] + ($state.href(state) || state);

                // IE8 FIX
                iframe[0].onload = function() {
                    if (angular.isDefined(data)) {
                        iframe[0].contentWindow.sessionStorage.setItem(state, angular.toJson(data));
                    }

                    iframe[0].contentWindow.resolve = function(data) {
                        deferred.resolve(data);
                        removeParallelNavigation();
                    }

                    iframe[0].contentWindow.reject = function(reason) {
                        deferred.reject(reason);
                        removeParallelNavigation();
                    }
                }

                window.onpopstate = function() {
                    removeParallelNavigation();
                    window.onpopstate = null;
                };

                angular.element($window).bind('resize', function(){
                    var myIframe = angular.element('iframe')
                        .attr('width', $window.innerWidth)
                        .attr('height', $window.innerHeight);
                });
            }());

            return deferred.promise;
        }
    }]);

/*global angular */
angular.module('sessionInterceptor', [])
    .factory('sessionInterceptor', ['SessionConfig', 'SessionCounterSrv', '$q', function (SessionConfig, SessionCounterSrv, $q) {
        function sessionInspector(config) {
            if(SessionConfig.time){
                SessionCounterSrv.reset();
            }
            return config;
        }
        return {
            request: sessionInspector
        };
    }])


/*global angular, sessionStorage */
angular.module('sessionStorageSrv', [])
    /**
     * @doc-component service
     * @name gaiafrontend.service.sessionStorage
     * @description
     * This service allows manage sessionStorage
     */
    .factory('SessionStorageSrv', ['$location', function ($location) {

         /**
         * @doc-component method
         * @methodOf gaiafrontend.service.sessionStorage
         * @name gaiafrontend.service.sessionStorage#get
         * @param {string} key The identifier we want recover from sessionStorage.
         * @return {object} object that matches key parameter.
         * @description
         * This method recover the property key from sessionStorage
         */
        function get(key) {
            return JSON.parse(sessionStorage.getItem(key));
        }

        /**
         * @doc-component method
         * @methodOf gaiafrontend.service.sessionStorage
         * @name gaiafrontend.service.sessionStorage#set
         * @param {string} key The identifier we want to save in sessionStorage.
         * @param {object} object The object we want to save.
         * @return {object} object with boolean result, and error message if it happens.
         * {
         *      result: "true/false",
         *      message: "message"
         * }
         * @description
         * This method save the object in the property key in sessionStorage
         */
        function set(key, object) {
            //sessionStorage.setItem(key, JSON.stringify(object));

            try {
                sessionStorage.setItem(key, JSON.stringify(object));
                return {result: true, message: 'success'};
            } catch (e) {
                return {result: false, message: e.message};
            }
        }

        /**
         * @doc-component method
         * @methodOf gaiafrontend.service.sessionStorage
         * @name gaiafrontend.service.sessionStorage#removeItem
         * @param {string} key The identifier we want remove in sessionStorage.
         * @description
         * This method removes the property key in sessionStorage
         */
        function removeItem(key) {
            sessionStorage.removeItem(key);
        }

        /**
         * @doc-component method
         * @methodOf gaiafrontend.service.sessionStorage
         * @name gaiafrontend.service.sessionStorage#getKey
         * @return {string} string contains absolut app URL.
         * @description
         * This method obtains the key to save data
         */
        function getKey() {
            return $location.absUrl();
        }


        /* Disabled
            function clear() {
                return sessionStorage.clear();
            }
        */

        return {
            get: get,
            set: set,
            removeItem: removeItem,
            getKey: getKey
        };
    }]);

/*TODO: Refactor to decorator */
/*global angular, _, $script */
 angular.module('state', ['ui.router'])
    .provider('State', function ($stateProvider) {
        var GAIA_DICTIONARY = 'gaiafrontend/i18n/messages.json',
            DEFAULT_DICTIONARY = 'commons/i18n/messages.json';

        function resolveDependencies(dependencies) {
           return ['$q', '$state', '$rootScope', function($q, $state, $rootScope) {
                var deferred = $q.defer(),
                    currentState = $state.$current;

                delete currentState.resolve.dependencies;

                $script(dependencies, function() {
                    $rootScope.$apply(function() {
                        deferred.resolve();
                    });
                });

                return deferred.promise;
            }];
        }

        function resolveDictionary(dictionary) {
            return ['$state', 'i18n', function($state, i18n) {
                var currentState = $state.$current;

                delete currentState.resolve.dictionary;

                return i18n.getDictionary(dictionary);
            }];
        }

        function resolveDictionaryCollection(dictionaryCollection) {
            return ['$state', 'i18n', function($state, i18n) {
                var currentState = $state.$current;

                delete currentState.resolve.dictionary;

                return i18n.getDictionary.apply(this, dictionaryCollection);
            }];
        }

        function resolveDictionaryEndpoint(endpoint) {
            return ['$state', 'i18n', 'Language', function($state, i18n, Language) {
                var currentState = $state.$current,
                    lang = Language.get().languageId,
                    endpoint2 = [GAIA_DICTIONARY];

                if(angular.isArray(endpoint)){
                    for(var i=0;i<endpoint.length;i++){
                        endpoint2.push(endpoint[i].replace(/:lang|{lang}/, lang));
                    }

                }else{
                     endpoint2.push(endpoint.replace(/:lang|{lang}/, lang));
                }

                delete currentState.resolve.dictionary;

                return i18n.getDictionary.apply(this, endpoint2);
            }];
        }

        function resolveState(config) {
            var state = {
                    resolve: {}
                };

            _.extend(state, config);

            function manageDependenciesProperty() {
                if (config.dependencies && config.dependencies.length) {
                    state.resolve.dependencies = resolveDependencies(config.dependencies);
                }
            }

            function manageDictionaryProperty() {
                if (angular.isString(config.dictionary)) {
                    // A dictionary is mandatory so gaiafrontend text translations are displayed properly
                    state.resolve.dictionary = resolveDictionary(config.dictionary || DEFAULT_DICTIONARY);
                } else if (angular.isObject(config.dictionary)) {
                    if(angular.isArray(config.dictionary)){
                        state.resolve.dictionary = resolveDictionaryCollection(config.dictionary || DEFAULT_DICTIONARY);
                    }else{
                        state.resolve.dictionary = resolveDictionaryEndpoint(config.dictionary.endpoint);
                    }
                }
            }

            manageDependenciesProperty();
            manageDictionaryProperty();

            return $stateProvider.state(state);
        }

        function resolveStates(states) {
            var sortedStates = [],
                pendingStatesToFindChildren = [];

            function removeStateFromStates(statesIndex) {
                states.splice(statesIndex, 1);
            }

            function addStateToSortedStates(state) {
                sortedStates.push(state);
            }

            function addToPendingStatesToFindChildren(stateName) {
                pendingStatesToFindChildren.push(stateName);
            }

            function getStatesWhoseParentIs(parentStateName) {
              console.log("Nuevos estados:" + JSON.stringify(states));
                return _.where(states, {
                    parent: parentStateName
                }) || [];
            }

            function manageStates(statesToManage) {
                _.forEach(statesToManage, function(stateToManage) {
                    removeStateFromStates(_.findIndex(states, stateToManage));
                    addStateToSortedStates(stateToManage);
                    addToPendingStatesToFindChildren(stateToManage.name);
                });
            }

            (function sortStates() {
                manageStates(getStatesWhoseParentIs(undefined));

                while (pendingStatesToFindChildren.length) {
                    manageStates(getStatesWhoseParentIs(pendingStatesToFindChildren.shift()));
                }
            }());

            _.forEach(sortedStates, function(state) {
                resolveState(state);
            });
        }

        return {
            resolve: function (states) {
                resolveStates(states);
                // To allow retro-compatibility
                return angular.noop;
            },
            resolveState: function (state) {
                resolveState(state);
                return angular.noop;
            },
            $get: function () {
                return {
                    resolve: resolveStates,
                    resolveState: resolveState
                };
            }
        };
    });

/*global angular*/
(function () {
    'use strict';

    var CREATING_TAB_ERROR = 'There was an error during TBID creation and the application cannot be initialized.';

    var TBID = {
        header: 'X-TBID',
        api: 'api/tab'
    };

    function getSearchPart(location) {
        var search = location.search || location.hash;
        return search.split('?')[1] || '';
    }

    function tryDecodeURIComponent(value) {
        try {
            return decodeURIComponent(value);
        } catch (ignore) {}
    }

    function parseSearchPart(search) {
        var obj = {},
            keyValueArray, key;

        angular.forEach((search || '').split('&'), function (keyValue) {
            if (keyValue) {
                keyValueArray = keyValue.split('=');
                key = tryDecodeURIComponent(keyValueArray[0]);
                if (angular.isDefined(key)) {
                    var val = angular.isDefined(keyValueArray[1]) ? tryDecodeURIComponent(keyValueArray[1]) : true;
                    if (!obj[key]) obj[key] = val;
                    else if (angular.isArray(obj[key])) obj[key].push(val);
                    else obj[key] = [obj[key], val];
                }
            }
        });

        return obj;
    }

    function TbidProvider() {
        var Tbid = this;

        Tbid.header = {
            get: function () {
                return TBID.header;
            },
            set: function (header) {
                if (header) {
                    TBID.header = header;
                    return;
                }
            }
        }

        Tbid.api = {
            get: function () {
                return TBID.api;
            },
            set: function (api) {
                if (api) {
                    TBID.api = api;
                    return;
                }
            }
        }

        Tbid.$get = ['$q', 'HttpSrv', 'SessionStorageSrv', function tbidFactory($q, Http, SessionStorage) {
            function currentTbidInfo(tbidInfo) {
                if (tbidInfo) return SessionStorage.set(Tbid.header.get(), tbidInfo);
                return SessionStorage.get(Tbid.header.get());
            }

            function getTbid(tbid) {
                return Http.get(Tbid.api.get() + '/:tbid', {tbid: tbid});
            }

            function postTbid() {
                return Http.post(Tbid.api.get());
            }

            function saveTbidInfo(deferred) {
                return function saveTbidInfo(tbidInfo) {
                    if (tbidInfo) currentTbidInfo(tbidInfo);
                    deferred.resolve(tbidInfo);
                };
            }

            function readTbid(tbid) {
                var deferred = $q.defer();
                getTbid(tbid).then(saveTbidInfo(deferred), deferred.reject);
                return deferred.promise;
            }

            function deleteTbid(tbid) {
                var req = new XMLHttpRequest();
                req.open('DELETE', TBID.api + '/' + tbid, false); // Sync
                req.send(null);
                SessionStorage.removeItem(TBID.header)
            }

            function createTbid() {
                var deferred = $q.defer();
                postTbid().then(saveTbidInfo(deferred), deferred.reject);
                return deferred.promise;
            }

            function init() {
                var deferred = $q.defer(),
                    tbidInfo = currentTbidInfo(),
                    tbid = parseSearchPart(getSearchPart(window.location)).tbid;

                // Prioritize tbidInfo saved in SessionStorage
                if (tbidInfo) deferred.resolve(tbidInfo);
                // Get tbidInfo provided via search-param
                else if (tbid) readTbid(tbid).then(deferred.resolve, deferred.reject);
                // Create a new tbid
                else createTbid().then(deferred.resolve, deferred.reject);

                return deferred.promise;
            }

            return {
                header: Tbid.header,
                api: Tbid.api,
                create: createTbid,
                read: readTbid,
                deleteTbid: deleteTbid,
                current: currentTbidInfo,
                init: init
            };
        }];
    }

    /**
     * @doc-component service
     * @name gaiafrontend.service.tbidInterceptor
     * @description
     * This interceptor implements and manages the TBID functionality for GAIA applications.
     *
     *  ```js
     *  var appModule = angular.module('myAppName', ['gaiafrontend']);
     *  appModule
     *     .config(['$httpProvider', function ($httpProvider) {
     *         $httpProvider.interceptors.push('TbidInterceptor');
     *     ]);
     *  ```
     */

    function TbidInterceptorProvider(TbidProvider) {
        this.$get = ['SessionStorageSrv', function TbidInterceptor(SessionStorage) {
            return {
                request: function tbidRequestInterceptor(config) {
                    var header = TbidProvider.header.get(),
                        tbidInfo = SessionStorage.get(header);

                    if (tbidInfo && tbidInfo.tbid)
                        config.headers[header] = tbidInfo.tbid;

                    return config;
                }
            };
        }];
    }

    function bootstrap(name) {
        angular.element(document).ready(function () {
            var searchObj = parseSearchPart(getSearchPart(window.location)),
                Http = angular.injector(['httpSrv', 'ng']).get('HttpSrv'),
                tbidInfo = {};

            function createTbid() {
                return Http.post(TBID.api);
            }

            function readTbid(tbid) {
                return Http.get(TBID.api + '/:tbid', {tbid: tbid});
            }

            function deleteTbid(tbid) {
                //TODO no llamar cuando la sesion haya caído.
                var sessionCounterDigits = angular.element('strong', angular.element('.sessionContainer'));

                if(sessionCounterDigits.text() !== "0" ){
                    var req = new XMLHttpRequest();
                    req.open('DELETE', TBID.api + '/' + tbid, false); // Sync
                    req.send(null);
                    sessionStorage.removeItem(TBID.header);
                }
            }

            function success(response) {
                angular.extend(tbidInfo, response);
                window.sessionStorage.setItem(TBID.header, JSON.stringify(tbidInfo));
                angular.bootstrap(document, [name]);
            }

            function error() {
                window.alert(CREATING_TAB_ERROR);
            }

            if (searchObj.tbid) {
                readTbid(searchObj.tbid).then(success, error);
            } else {
                createTbid().then(function (response) {
                    success(response);
                    window.onbeforeunload = function () {
                        deleteTbid(tbidInfo.tbid);
                    };
                }, error)
            }
        });
    }

    angular.module('tbidInterceptor', [])
        .provider('Tbid', TbidProvider)
        .provider('TbidInterceptor', TbidInterceptorProvider)
        .bootstrap = bootstrap;
}());

/*TODO: REVIEW */
/*global angular */
angular.module('theme', [])
    /**
     * @doc-component service
     * @name gaiafrontend.service.theme
     * @description
     * This service manages the application's skin/theme.
     *
     * See `ThemeInterceptor` and `ThemeCtrl` for more info.
     *
     */
    .factory('Theme', function() {
        var theme = {};
        /**
         * @doc-component method
         * @methodOf gaiafrontend.service.theme
         * @name gaiafrontend.service.theme#get
         * @return {object} theme for application.
         * @description
         * This method obtains the application's theme.
         */
        function get() {
            return theme;
        }
        /**
         * @doc-component method
         * @methodOf gaiafrontend.service.theme
         * @name gaiafrontend.service.theme#set
         * @param {string} name The id for the theme to be set as the application's theme.
         * @description
         * This method sets the application's theme.
         */
        function set(themeId) {
            theme.id = themeId;
            if (window.respond) {
                window.respond.update();
            }
        }

        return {
            get: get,
            set: set
        };
    });

/*global angular */
angular.module('themeInterceptor', [])
    /**
     * @doc-component service
     * @name gaiafrontend.service.themeInterceptor
     * @description
     * This service is meant to be used as a `$http` interceptor.
     *
     * This interceptor manages GAIA themes. It works in conjuntion with `ThemeCtrl`.
     *
     * To use this interceptor in your application you only have to add this service to the `$httpProvider.interceptor` Array of your application as follows:
     *
     *  ```js
     *  var appModule = angular.module('myAppName', ['gaiafrontend']);
     *  appModule
     *     .config(['$httpProvider', function ($httpProvider) {
     *         $httpProvider.interceptors.push('ThemeInterceptor');
     *     ]);
     *  ```
     *
     * See `Theme` and `ThemeCtrl` for more info.
     *
     */
    .factory('ThemeInterceptor', ['Theme', function (Theme) {
        return {
            response: function(response) {
                var themeId = response.headers('X-User-theme');

                if (themeId && themeId !== Theme.get()) {
                    Theme.set(themeId);
                }

                return response;
            }
        };
    }]);

/*global angular */
angular.module('unauthorizedInterceptor', [])
    .constant('UnauthorizedConfig', {
        status: 401,
        redirectionUrl: '#/login'
    })
    /**
     * @doc-component service
     * @name gaiafrontend.service.unauthorizedInterceptor
     * @description
     * This service is meant to be used as a `$http` interceptor.
     *
     * This interceptor redirects our GAIA application to a defined URL when the response status code is 401.
     *
     * To use this interceptor in your application you only have to add this service to the `$httpProvider.interceptor` Array of your application as follows:
     *
     *  ```js
     *  var appModule = angular.module('myAppName', ['gaiafrontend']);
     *  appModule
     *     .config(['$httpProvider', function ($httpProvider) {
     *         $httpProvider.interceptors.push('UnauthorizedInterceptor');
     *     ]);
     *  ```
     *
     * We can set the `redirectionUrl` in the config method of our main module like follows:
     *
     *  ```js
     *  var appModule = angular.module('myAppName', ['gaiafrontend']);
     *  appModule
     *     .config(['$httpProvider', 'UnauthorizedConfig', function ($httpProvider, UnauthorizedConfig) {
     *         UnauthorizedConfig.redirectionUrl = '/login.html';
     *         $httpProvider.interceptors.push('UnauthorizedInterceptor');
     *     ]);
     *  ```
     */
    .factory('UnauthorizedInterceptor', ['$q', '$window', 'UnauthorizedConfig', function ($q, $window, config) {
        var cache = {};

        return {
            getDestinationUrl: function () {
                return cache.destinationUrl;
            },
            responseError: function(rejection) {
                if (+rejection.status === config.UNAUTHORIZED_CODE) {
                    cache.destinationUrl = $window.location.hash;
                    $window.location = config.redirectionUrl;
                }

                return $q.reject(rejection);
            }
        };
    }]);

/*TODO: REVIEW */
/*global angular, _ */
angular.module('userSrv', [])
    /**
     * @doc-component service
     * @name gaiafrontend.service.userSrv
     * @description
     * This service retrieves and holds the current user information.
     */
    .factory('UserSrv', ['$q', 'HttpSrv', 'Language',
        function ($q, HttpSrv, Language) {
            var userInfoUrl = 'api/userinfo',
                user = {
                    info: {}
                };

            function setInfo(info) {
                if (info.applicationData.language) {
                    Language.set(info.applicationData.language);
                }
                return _.extend(user.info, info);
            }

            function requestInfo() {
                return HttpSrv.get(userInfoUrl);
            }

            function reject(deferred) {
                return function(error) {
                    return deferred.reject(error.errorData || error);
                };
            }

            function saveUserInfo(deferred) {
                return function(info) {
                    return deferred.resolve(setInfo(info));
                };
            }

            /**
             * @doc-component method
             * @methodOf gaiafrontend.service.userSrv
             * @name gaiafrontend.service.userSrv#getInfo
             * @param {boolean} force Forces the service to retrieve again the user information instead of return the saved info.
             * @return {promise} It will pass the requested user info object to the success callback.
             * @description
             * This methods retrieves the current user info.
             */
            function getInfo(force) {
                var deferred = $q.defer();

                if (force || _.isEmpty(user.info)) {
                    requestInfo()
                        .then(saveUserInfo(deferred), reject(deferred));
                } else {
                    deferred.resolve(user.info);
                }

                return deferred.promise;
            }

            return _.extend(user, {
                getInfo: getInfo
            });
        }]);

/**
 * angular-strap
 * @version v2.1.1 - 2014-09-26
 * @link http://mgcrea.github.io/angular-strap
 * @author Olivier Louvignes (olivier@mg-crea.com)
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */
(function(window, document, undefined) {
    'use strict';
    // Source: module.js
    angular.module('mgcrea.ngStrap', [
        'mgcrea.ngStrap.button',
        'mgcrea.ngStrap.select',
        'mgcrea.ngStrap.datepicker',
        'mgcrea.ngStrap.timepicker',
        'mgcrea.ngStrap.navbar',
        'mgcrea.ngStrap.tooltip',
        'mgcrea.ngStrap.popover',
        'mgcrea.ngStrap.dropdown',
        'mgcrea.ngStrap.typeahead',
        'mgcrea.ngStrap.scrollspy',
        'mgcrea.ngStrap.affix',
        'mgcrea.ngStrap.tab',
        'mgcrea.ngStrap.collapse'
    ]);

    // Source: affix.js
    angular.module('mgcrea.ngStrap.affix', ['mgcrea.ngStrap.helpers.dimensions', 'mgcrea.ngStrap.helpers.debounce'])

    .provider('$affix', function() {

        var defaults = this.defaults = {
            offsetTop: 'auto'
        };

        this.$get = ["$window", "debounce", "dimensions", function($window, debounce, dimensions) {

            var bodyEl = angular.element($window.document.body);
            var windowEl = angular.element($window);

            function AffixFactory(element, config) {

                var $affix = {};

                // Common vars
                var options = angular.extend({}, defaults, config);
                var targetEl = options.target;

                // Initial private vars
                var reset = 'affix affix-top affix-bottom',
                    initialAffixTop = 0,
                    initialOffsetTop = 0,
                    offsetTop = 0,
                    offsetBottom = 0,
                    affixed = null,
                    unpin = null;

                var parent = element.parent();
                // Options: custom parent
                if (options.offsetParent) {
                    if (options.offsetParent.match(/^\d+$/)) {
                        for (var i = 0; i < (options.offsetParent * 1) - 1; i++) {
                            parent = parent.parent();
                        }
                    } else {
                        parent = angular.element(options.offsetParent);
                    }
                }

                $affix.init = function() {

                    $affix.$parseOffsets();
                    initialOffsetTop = dimensions.offset(element[0]).top + initialAffixTop;

                    // Bind events
                    targetEl.on('scroll', $affix.checkPosition);
                    targetEl.on('click', $affix.checkPositionWithEventLoop);
                    windowEl.on('resize', $affix.$debouncedOnResize);

                    // Both of these checkPosition() calls are necessary for the case where
                    // the user hits refresh after scrolling to the bottom of the page.
                    $affix.checkPosition();
                    $affix.checkPositionWithEventLoop();

                };

                $affix.destroy = function() {

                    // Unbind events
                    targetEl.off('scroll', $affix.checkPosition);
                    targetEl.off('click', $affix.checkPositionWithEventLoop);
                    windowEl.off('resize', $affix.$debouncedOnResize);

                };

                $affix.checkPositionWithEventLoop = function() {

                    setTimeout($affix.checkPosition, 1);

                };

                $affix.checkPosition = function() {
                    // if (!this.$element.is(':visible')) return

                    var scrollTop = getScrollTop();
                    var position = dimensions.offset(element[0]);
                    var elementHeight = dimensions.height(element[0]);

                    // Get required affix class according to position
                    var affix = getRequiredAffixClass(unpin, position, elementHeight);

                    // Did affix status changed this last check?
                    if (affixed === affix) return;
                    affixed = affix;

                    // Add proper affix class
                    element.removeClass(reset).addClass('affix' + ((affix !== 'middle') ? '-' + affix : ''));

                    if (affix === 'top') {
                        unpin = null;
                        element.css('position', (options.offsetParent) ? '' : 'relative');
                        element.css('top', '');
                    } else if (affix === 'bottom') {
                        if (options.offsetUnpin) {
                            unpin = -(options.offsetUnpin * 1);
                        } else {
                            // Calculate unpin threshold when affixed to bottom.
                            // Hopefully the browser scrolls pixel by pixel.
                            unpin = position.top - scrollTop;
                        }
                        element.css('position', (options.offsetParent) ? '' : 'relative');
                        element.css('top', (options.offsetParent) ? '' : ((bodyEl[0].offsetHeight - offsetBottom - elementHeight - initialOffsetTop) + 'px'));
                    } else { // affix === 'middle'
                        unpin = null;
                        element.css('position', 'fixed');
                        element.css('top', initialAffixTop + 'px');
                    }

                };

                $affix.$onResize = function() {
                    $affix.$parseOffsets();
                    $affix.checkPosition();
                };
                $affix.$debouncedOnResize = debounce($affix.$onResize, 50);

                $affix.$parseOffsets = function() {
                    var initialPosition = element.css('position');
                    // Reset position to calculate correct offsetTop
                    element.css('position', (options.offsetParent) ? '' : 'relative');

                    if (options.offsetTop) {
                        if (options.offsetTop === 'auto') {
                            options.offsetTop = '+0';
                        }
                        if (options.offsetTop.match(/^[-+]\d+$/)) {
                            initialAffixTop = -options.offsetTop * 1;
                            if (options.offsetParent) {
                                offsetTop = dimensions.offset(parent[0]).top + (options.offsetTop * 1);
                            } else {
                                offsetTop = dimensions.offset(element[0]).top - dimensions.css(element[0], 'marginTop', true) + (options.offsetTop * 1);
                            }
                        } else {
                            offsetTop = options.offsetTop * 1;
                        }
                    }

                    if (options.offsetBottom) {
                        if (options.offsetParent && options.offsetBottom.match(/^[-+]\d+$/)) {
                            // add 1 pixel due to rounding problems...
                            offsetBottom = getScrollHeight() - (dimensions.offset(parent[0]).top + dimensions.height(parent[0])) + (options.offsetBottom * 1) + 1;
                        } else {
                            offsetBottom = options.offsetBottom * 1;
                        }
                    }

                    // Bring back the element's position after calculations
                    element.css('position', initialPosition);
                };

                // Private methods

                function getRequiredAffixClass(unpin, position, elementHeight) {

                    var scrollTop = getScrollTop();
                    var scrollHeight = getScrollHeight();

                    if (scrollTop <= offsetTop) {
                        return 'top';
                    } else if (unpin !== null && (scrollTop + unpin <= position.top)) {
                        return 'middle';
                    } else if (offsetBottom !== null && (position.top + elementHeight + initialAffixTop >= scrollHeight - offsetBottom)) {
                        return 'bottom';
                    } else {
                        return 'middle';
                    }

                }

                function getScrollTop() {
                    return targetEl[0] === $window ? $window.pageYOffset : targetEl[0].scrollTop;
                }

                function getScrollHeight() {
                    return targetEl[0] === $window ? $window.document.body.scrollHeight : targetEl[0].scrollHeight;
                }

                $affix.init();
                return $affix;

            }

            return AffixFactory;

        }];

    })

    .directive('bsAffix', ["$affix", "$window", function($affix, $window) {

        return {
            restrict: 'EAC',
            require: '^?bsAffixTarget',
            link: function postLink(scope, element, attr, affixTarget) {

                var options = {
                    scope: scope,
                    offsetTop: 'auto',
                    target: affixTarget ? affixTarget.$element : angular.element($window)
                };
                angular.forEach(['offsetTop', 'offsetBottom', 'offsetParent', 'offsetUnpin'], function(key) {
                    if (angular.isDefined(attr[key])) options[key] = attr[key];
                });

                var affix = $affix(element, options);
                scope.$on('$destroy', function() {
                    affix && affix.destroy();
                    options = null;
                    affix = null;
                });

            }
        };

    }])

    .directive('bsAffixTarget', function() {
        return {
            controller: ["$element", function($element) {
                this.$element = $element;
            }]
        };
    });

    // Source: button.js
    angular.module('mgcrea.ngStrap.button', [])

    .provider('$button', function() {

        var defaults = this.defaults = {
            activeClass: 'active',
            toggleEvent: 'click'
        };

        this.$get = function() {
            return {
                defaults: defaults
            };
        };

    })

    .directive('bsCheckboxGroup', function() {

        return {
            restrict: 'A',
            require: 'ngModel',
            compile: function postLink(element, attr) {
                element.attr('data-toggle', 'buttons');
                element.removeAttr('ng-model');
                var children = element[0].querySelectorAll('input[type="checkbox"]');
                angular.forEach(children, function(child) {
                    var childEl = angular.element(child);
                    childEl.attr('bs-checkbox', '');
                    childEl.attr('ng-model', attr.ngModel + '.' + childEl.attr('value'));
                });
            }

        };

    })

    .directive('bsCheckbox', ["$button", "$$rAF", function($button, $$rAF) {

        var defaults = $button.defaults;
        var constantValueRegExp = /^(true|false|\d+)$/;

        return {
            restrict: 'A',
            require: 'ngModel',
            link: function postLink(scope, element, attr, controller) {

                var options = defaults;

                // Support label > input[type="checkbox"]
                var isInput = element[0].nodeName === 'INPUT';
                var activeElement = isInput ? element.parent() : element;

                var trueValue = angular.isDefined(attr.trueValue) ? attr.trueValue : true;
                if (constantValueRegExp.test(attr.trueValue)) {
                    trueValue = scope.$eval(attr.trueValue);
                }
                var falseValue = angular.isDefined(attr.falseValue) ? attr.falseValue : false;
                if (constantValueRegExp.test(attr.falseValue)) {
                    falseValue = scope.$eval(attr.falseValue);
                }

                // Parse exotic values
                var hasExoticValues = typeof trueValue !== 'boolean' || typeof falseValue !== 'boolean';
                if (hasExoticValues) {
                    controller.$parsers.push(function(viewValue) {
                        // console.warn('$parser', element.attr('ng-model'), 'viewValue', viewValue);
                        return viewValue ? trueValue : falseValue;
                    });
                    // Fix rendering for exotic values
                    scope.$watch(attr.ngModel, function(newValue, oldValue) {
                        controller.$render();
                    });
                }

                // model -> view
                controller.$render = function() {
                    // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);
                    var isActive = angular.equals(controller.$modelValue, trueValue);
                    $$rAF(function() {
                        if (isInput) element[0].checked = isActive;
                        activeElement.toggleClass(options.activeClass, isActive);
                    });
                };

                // view -> model
                element.bind(options.toggleEvent, function() {
                    scope.$apply(function() {
                        // console.warn('!click', element.attr('ng-model'), 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue, 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue);
                        if (!isInput) {
                            controller.$setViewValue(!activeElement.hasClass('active'));
                        }
                        if (!hasExoticValues) {
                            controller.$render();
                        }
                    });
                });

            }

        };

    }])

    .directive('bsRadioGroup', function() {

        return {
            restrict: 'A',
            require: 'ngModel',
            compile: function postLink(element, attr) {
                element.attr('data-toggle', 'buttons');
                element.removeAttr('ng-model');
                var children = element[0].querySelectorAll('input[type="radio"]');
                angular.forEach(children, function(child) {
                    angular.element(child).attr('bs-radio', '');
                    angular.element(child).attr('ng-model', attr.ngModel);
                });
            }

        };

    })

    .directive('bsRadio', ["$button", "$$rAF", function($button, $$rAF) {

        var defaults = $button.defaults;
        var constantValueRegExp = /^(true|false|\d+)$/;

        return {
            restrict: 'A',
            require: 'ngModel',
            link: function postLink(scope, element, attr, controller) {

                var options = defaults;

                // Support `label > input[type="radio"]` markup
                var isInput = element[0].nodeName === 'INPUT';
                var activeElement = isInput ? element.parent() : element;

                var value = constantValueRegExp.test(attr.value) ? scope.$eval(attr.value) : attr.value;

                // model -> view
                controller.$render = function() {
                    // console.warn('$render', element.attr('value'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);
                    var isActive = angular.equals(controller.$modelValue, value);
                    $$rAF(function() {
                        if (isInput) element[0].checked = isActive;
                        activeElement.toggleClass(options.activeClass, isActive);
                    });
                };

                // view -> model
                element.bind(options.toggleEvent, function() {
                    scope.$apply(function() {
                        // console.warn('!click', element.attr('value'), 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue, 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue);
                        controller.$setViewValue(value);
                        controller.$render();
                    });
                });

            }

        };

    }]);

    // Source: collapse.js
    angular.module('mgcrea.ngStrap.collapse', [])

    .provider('$collapse', function() {

        var defaults = this.defaults = {
            animation: 'am-collapse',
            disallowToggle: false,
            activeClass: 'in',
            startCollapsed: false
        };

        var controller = this.controller = function($scope, $element, $attrs) {
            var self = this;

            // Attributes options
            self.$options = angular.copy(defaults);
            angular.forEach(['animation', 'disallowToggle', 'activeClass', 'startCollapsed'], function(key) {
                if (angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];
            });

            self.$toggles = [];
            self.$targets = [];

            self.$viewChangeListeners = [];

            self.$registerToggle = function(element) {
                self.$toggles.push(element);
            };
            self.$registerTarget = function(element) {
                self.$targets.push(element);
            };

            self.$targets.$active = !self.$options.startCollapsed ? 0 : -1;
            self.$setActive = $scope.$setActive = function(value) {
                if (!self.$options.disallowToggle) {
                    self.$targets.$active = self.$targets.$active === value ? -1 : value;
                } else {
                    self.$targets.$active = value;
                }
                self.$viewChangeListeners.forEach(function(fn) {
                    fn();
                });
            };

        };

        this.$get = function() {
            var $collapse = {};
            $collapse.defaults = defaults;
            $collapse.controller = controller;
            return $collapse;
        };

    })

    .directive('bsCollapse', ["$window", "$animate", "$collapse", function($window, $animate, $collapse) {

        var defaults = $collapse.defaults;

        return {
            require: ['?ngModel', 'bsCollapse'],
            controller: ['$scope', '$element', '$attrs', $collapse.controller],
            link: function postLink(scope, element, attrs, controllers) {

                var ngModelCtrl = controllers[0];
                var bsCollapseCtrl = controllers[1];

                if (ngModelCtrl) {

                    // Update the modelValue following
                    bsCollapseCtrl.$viewChangeListeners.push(function() {
                        ngModelCtrl.$setViewValue(bsCollapseCtrl.$targets.$active);
                    });

                    // modelValue -> $formatters -> viewValue
                    ngModelCtrl.$formatters.push(function(modelValue) {
                        // console.warn('$formatter("%s"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);
                        if (bsCollapseCtrl.$targets.$active !== modelValue * 1) {
                            bsCollapseCtrl.$setActive(modelValue * 1);
                        }
                        return modelValue;
                    });

                }

            }
        };

    }])

    .directive('bsCollapseToggle', function() {

        return {
            require: ['^?ngModel', '^bsCollapse'],
            link: function postLink(scope, element, attrs, controllers) {

                var ngModelCtrl = controllers[0];
                var bsCollapseCtrl = controllers[1];

                // Add base attr
                element.attr('data-toggle', 'collapse');

                // Push pane to parent bsCollapse controller
                bsCollapseCtrl.$registerToggle(element);
                element.on('click', function() {
                    var index = attrs.bsCollapseToggle || bsCollapseCtrl.$toggles.indexOf(element);
                    bsCollapseCtrl.$setActive(index * 1);
                    scope.$apply();
                });

            }
        };

    })

    .directive('bsCollapseTarget', ["$animate", function($animate) {

        return {
            require: ['^?ngModel', '^bsCollapse'],
            // scope: true,
            link: function postLink(scope, element, attrs, controllers) {

                var ngModelCtrl = controllers[0];
                var bsCollapseCtrl = controllers[1];

                // Add base class
                element.addClass('collapse');

                // Add animation class
                if (bsCollapseCtrl.$options.animation) {
                    element.addClass(bsCollapseCtrl.$options.animation);
                }

                // Push pane to parent bsCollapse controller
                bsCollapseCtrl.$registerTarget(element);

                function render() {
                    var index = bsCollapseCtrl.$targets.indexOf(element);
                    var active = bsCollapseCtrl.$targets.$active;
                    $animate[index === active ? 'addClass' : 'removeClass'](element, bsCollapseCtrl.$options.activeClass);
                }

                bsCollapseCtrl.$viewChangeListeners.push(function() {
                    render();
                });
                render();

            }
        };

    }]);

    // Source: datepicker.js
    angular.module('mgcrea.ngStrap.datepicker', ['mgcrea.ngStrap.helpers.dateParser', 'mgcrea.ngStrap.tooltip'])

    .provider('$datepicker', function() {

        var defaults = this.defaults = {
            animation: 'am-fade',
            prefixClass: 'datepicker',
            placement: 'bottom-left',
            template: 'datepicker/datepicker.tpl.html',
            trigger: 'focus',
            container: false,
            keyboard: true,
            html: false,
            delay: 0,
            // lang: $locale.id,
            useNative: false,
            dateType: 'date',
            dateFormat: 'shortDate',
            modelDateFormat: null,
            dayFormat: 'dd',
            strictFormat: false,
            autoclose: false,
            minDate: -Infinity,
            maxDate: +Infinity,
            startView: 0,
            minView: 0,
            startWeek: 0,
            daysOfWeekDisabled: '',
            iconLeft: 'glyphicon glyphicon-chevron-left',
            iconRight: 'glyphicon glyphicon-chevron-right'
        };

        this.$get = ["$window", "$document", "$rootScope", "$sce", "$locale", "dateFilter", "datepickerViews", "$tooltip", function($window, $document, $rootScope, $sce, $locale, dateFilter, datepickerViews, $tooltip) {

            var bodyEl = angular.element($window.document.body);
            var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);
            var isTouch = ('createTouch' in $window.document) && isNative;
            if (!defaults.lang) defaults.lang = $locale.id;

            function DatepickerFactory(element, controller, config) {

                var $datepicker = $tooltip(element, angular.extend({}, defaults, config));
                var parentScope = config.scope;
                var options = $datepicker.$options;
                var scope = $datepicker.$scope;
                if (options.startView) options.startView -= options.minView;

                // View vars

                var pickerViews = datepickerViews($datepicker);
                $datepicker.$views = pickerViews.views;
                var viewDate = pickerViews.viewDate;
                scope.$mode = options.startView;
                scope.$iconLeft = options.iconLeft;
                scope.$iconRight = options.iconRight;
                var $picker = $datepicker.$views[scope.$mode];

                // Scope methods

                scope.$select = function(date) {
                    $datepicker.select(date);
                };
                scope.$selectPane = function(value) {
                    $datepicker.$selectPane(value);
                };
                scope.$toggleMode = function() {
                    $datepicker.setMode((scope.$mode + 1) % $datepicker.$views.length);
                };

                // Public methods

                $datepicker.update = function(date) {
                    // console.warn('$datepicker.update() newValue=%o', date);
                    if (angular.isDate(date) && !isNaN(date.getTime())) {
                        $datepicker.$date = date;
                        $picker.update.call($picker, date);
                    }
                    // Build only if pristine
                    $datepicker.$build(true);
                };

                $datepicker.updateDisabledDates = function(dateRanges) {
                    options.disabledDateRanges = dateRanges;
                    for (var i = 0, l = scope.rows.length; i < l; i++) {
                        angular.forEach(scope.rows[i], $datepicker.$setDisabledEl);
                    }
                };

                $datepicker.select = function(date, keep) {
                    // console.warn('$datepicker.select', date, scope.$mode);
                    if (!angular.isDate(controller.$dateValue)) controller.$dateValue = new Date(date);
                    if (!scope.$mode || keep) {
                        controller.$setViewValue(angular.copy(date));
                        controller.$render();
                        if (options.autoclose && !keep) {
                            $datepicker.hide(true);
                        }
                    } else {
                        angular.extend(viewDate, {
                            year: date.getFullYear(),
                            month: date.getMonth(),
                            date: date.getDate()
                        });
                        $datepicker.setMode(scope.$mode - 1);
                        $datepicker.$build();
                    }
                };

                $datepicker.setMode = function(mode) {
                    // console.warn('$datepicker.setMode', mode);
                    scope.$mode = mode;
                    $picker = $datepicker.$views[scope.$mode];
                    $datepicker.$build();
                };

                // Protected methods

                $datepicker.$build = function(pristine) {
                    // console.warn('$datepicker.$build() viewDate=%o', viewDate);
                    if (pristine === true && $picker.built) return;
                    if (pristine === false && !$picker.built) return;
                    $picker.build.call($picker);
                };

                $datepicker.$updateSelected = function() {
                    for (var i = 0, l = scope.rows.length; i < l; i++) {
                        angular.forEach(scope.rows[i], updateSelected);
                    }
                };

                $datepicker.$isSelected = function(date) {
                    return $picker.isSelected(date);
                };

                $datepicker.$setDisabledEl = function(el) {
                    el.disabled = $picker.isDisabled(el.date);
                };

                $datepicker.$selectPane = function(value) {
                    var steps = $picker.steps;
                    var targetDate = new Date(Date.UTC(viewDate.year + ((steps.year || 0) * value), viewDate.month + ((steps.month || 0) * value), viewDate.date + ((steps.day || 0) * value)));
                    angular.extend(viewDate, {
                        year: targetDate.getUTCFullYear(),
                        month: targetDate.getUTCMonth(),
                        date: targetDate.getUTCDate()
                    });
                    $datepicker.$build();
                };

                $datepicker.$onMouseDown = function(evt) {
                    // Prevent blur on mousedown on .dropdown-menu
                    evt.preventDefault();
                    evt.stopPropagation();
                    // Emulate click for mobile devices
                    if (isTouch) {
                        var targetEl = angular.element(evt.target);
                        if (targetEl[0].nodeName.toLowerCase() !== 'button') {
                            targetEl = targetEl.parent();
                        }
                        targetEl.triggerHandler('click');
                    }
                };

                $datepicker.$onKeyDown = function(evt) {
                    if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;
                    evt.preventDefault();
                    evt.stopPropagation();

                    if (evt.keyCode === 13) {
                        if (!scope.$mode) {
                            return $datepicker.hide(true);
                        } else {
                            return scope.$apply(function() {
                                $datepicker.setMode(scope.$mode - 1);
                            });
                        }
                    }

                    // Navigate with keyboard
                    $picker.onKeyDown(evt);
                    parentScope.$digest();
                };

                // Private

                function updateSelected(el) {
                    el.selected = $datepicker.$isSelected(el.date);
                }

                function focusElement() {
                    element[0].focus();
                }

                // Overrides

                var _init = $datepicker.init;
                $datepicker.init = function() {
                    if (isNative && options.useNative) {
                        element.prop('type', 'date');
                        element.css('-webkit-appearance', 'textfield');
                        return;
                    } else if (isTouch) {
                        element.prop('type', 'text');
                        element.attr('readonly', 'true');
                        element.on('click', focusElement);
                    }
                    _init();
                };

                var _destroy = $datepicker.destroy;
                $datepicker.destroy = function() {
                    if (isNative && options.useNative) {
                        element.off('click', focusElement);
                    }
                    _destroy();
                };

                var _show = $datepicker.show;
                $datepicker.show = function() {
                    _show();
                    setTimeout(function() {
                        $datepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);
                        if (options.keyboard) {
                            element.on('keydown', $datepicker.$onKeyDown);
                        }
                    });
                };

                var _hide = $datepicker.hide;
                $datepicker.hide = function(blur) {
                    $datepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);
                    if (options.keyboard) {
                        element.off('keydown', $datepicker.$onKeyDown);
                    }
                    _hide(blur);
                };

                return $datepicker;

            }

            DatepickerFactory.defaults = defaults;
            return DatepickerFactory;

        }];

    })

    .directive('bsDatepicker', ["$window", "$parse", "$q", "$locale", "dateFilter", "$datepicker", "$dateParser", "$timeout", function($window, $parse, $q, $locale, dateFilter, $datepicker, $dateParser, $timeout) {

        var defaults = $datepicker.defaults;
        var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);
        var isNumeric = function(n) {
            return !isNaN(parseFloat(n)) && isFinite(n);
        };

        return {
            restrict: 'EAC',
            require: 'ngModel',
            link: function postLink(scope, element, attr, controller) {

                // Directive options
                var options = {
                    scope: scope,
                    controller: controller
                };
                angular.forEach(['placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'template', 'autoclose', 'dateType', 'dateFormat', 'modelDateFormat', 'dayFormat', 'strictFormat', 'startWeek', 'startDate', 'useNative', 'lang', 'startView', 'minView', 'iconLeft', 'iconRight', 'daysOfWeekDisabled'], function(key) {
                    if (angular.isDefined(attr[key])) options[key] = attr[key];
                });

                // Visibility binding support
                attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {
                    if (!datepicker || !angular.isDefined(newValue)) return;
                    if (angular.isString(newValue)) newValue = !!newValue.match(',?(datepicker),?');
                    newValue === true ? datepicker.show() : datepicker.hide();
                });

                // Initialize datepicker
                var datepicker = $datepicker(element, controller, options);
                options = datepicker.$options;
                // Set expected iOS format
                if (isNative && options.useNative) options.dateFormat = 'yyyy-MM-dd';

                // Observe attributes for changes
                angular.forEach(['minDate', 'maxDate'], function(key) {
                    // console.warn('attr.$observe(%s)', key, attr[key]);
                    angular.isDefined(attr[key]) && attr.$observe(key, function(newValue) {
                        // console.warn('attr.$observe(%s)=%o', key, newValue);
                        if (newValue === 'today') {
                            var today = new Date();
                            datepicker.$options[key] = +new Date(today.getFullYear(), today.getMonth(), today.getDate() + (key === 'maxDate' ? 1 : 0), 0, 0, 0, (key === 'minDate' ? 0 : -1));
                        } else if (angular.isString(newValue) && newValue.match(/^".+"$/)) { // Support {{ dateObj }}
                            datepicker.$options[key] = +new Date(newValue.substr(1, newValue.length - 2));
                        } else if (isNumeric(newValue)) {
                            datepicker.$options[key] = +new Date(parseInt(newValue, 10));
                        } else if (angular.isString(newValue) && 0 === newValue.length) { // Reset date
                            datepicker.$options[key] = key === 'maxDate' ? +Infinity : -Infinity;
                        } else {
                            datepicker.$options[key] = +new Date(newValue);
                        }
                        // Build only if dirty
                        !isNaN(datepicker.$options[key]) && datepicker.$build(false);
                    });
                });

                // Watch model for changes
                scope.$watch(attr.ngModel, function(newValue, oldValue) {
                    datepicker.update(controller.$dateValue);
                }, true);

                // Normalize undefined/null/empty array,
                // so that we don't treat changing from undefined->null as a change.
                function normalizeDateRanges(ranges) {
                    if (!ranges || !ranges.length) return null;
                    return ranges;
                }

                if (angular.isDefined(attr.disabledDates)) {
                    scope.$watch(attr.disabledDates, function(disabledRanges, previousValue) {
                        disabledRanges = normalizeDateRanges(disabledRanges);
                        previousValue = normalizeDateRanges(previousValue);

                        if (disabledRanges !== previousValue) {
                            datepicker.updateDisabledDates(disabledRanges);
                        }
                    });
                }

                var dateParser = $dateParser({
                    format: options.dateFormat,
                    lang: options.lang,
                    strict: options.strictFormat
                });

                // viewValue -> $parsers -> modelValue
                controller.$parsers.unshift(function(viewValue) {
                    // console.warn('$parser("%s"): viewValue=%o', element.attr('ng-model'), viewValue);
                    // Null values should correctly reset the model value & validity
                    if (!viewValue) {
                        controller.$setValidity('date', true);
                        return;
                    }
                    var parsedDate = dateParser.parse(viewValue, controller.$dateValue);
                    if (!parsedDate || isNaN(parsedDate.getTime())) {
                        controller.$setValidity('date', false);
                        return;
                    } else {
                        var isMinValid = isNaN(datepicker.$options.minDate) || parsedDate.getTime() >= datepicker.$options.minDate;
                        var isMaxValid = isNaN(datepicker.$options.maxDate) || parsedDate.getTime() <= datepicker.$options.maxDate;
                        var isValid = isMinValid && isMaxValid;
                        controller.$setValidity('date', isValid);
                        controller.$setValidity('min', isMinValid);
                        controller.$setValidity('max', isMaxValid);
                        // Only update the model when we have a valid date
                        if (isValid) controller.$dateValue = parsedDate;
                    }
                    if (options.dateType === 'string') {
                        return dateFilter(parsedDate, options.modelDateFormat || options.dateFormat);
                    } else if (options.dateType === 'number') {
                        return controller.$dateValue.getTime();
                    } else if (options.dateType === 'iso') {
                        return controller.$dateValue.toISOString();
                    } else {
                        return new Date(controller.$dateValue);
                    }
                });

                // modelValue -> $formatters -> viewValue
                controller.$formatters.push(function(modelValue) {
                    // console.warn('$formatter("%s"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);
                    var date;
                    if (angular.isUndefined(modelValue) || modelValue === null) {
                        date = NaN;
                    } else if (angular.isDate(modelValue)) {
                        date = modelValue;
                    } else if (options.dateType === 'string') {
                        date = dateParser.parse(modelValue, null, options.modelDateFormat);
                    } else {
                        date = new Date(modelValue);
                    }
                    // Setup default value?
                    // if(isNaN(date.getTime())) {
                    //   var today = new Date();
                    //   date = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0);
                    // }
                    controller.$dateValue = date;
                    return controller.$dateValue;
                });

                // viewValue -> element
                controller.$render = function() {
                    // console.warn('$render("%s"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);
                    element.val(!controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : dateFilter(controller.$dateValue, options.dateFormat));
                };

                // Garbage collection
                scope.$on('$destroy', function() {
                    if (datepicker) datepicker.destroy();
                    options = null;
                    datepicker = null;
                });

            }
        };

    }])

    .provider('datepickerViews', function() {

        var defaults = this.defaults = {
            dayFormat: 'dd',
            daySplit: 7
        };

        // Split array into smaller arrays
        function split(arr, size) {
            var arrays = [];
            while (arr.length > 0) {
                arrays.push(arr.splice(0, size));
            }
            return arrays;
        }

        // Modulus operator
        function mod(n, m) {
            return ((n % m) + m) % m;
        }

        this.$get = ["$locale", "$sce", "dateFilter", function($locale, $sce, dateFilter) {

            return function(picker) {

                var scope = picker.$scope;
                var options = picker.$options;

                var weekDaysMin = $locale.DATETIME_FORMATS.SHORTDAY;
                var weekDaysLabels = weekDaysMin.slice(options.startWeek).concat(weekDaysMin.slice(0, options.startWeek));
                var weekDaysLabelsHtml = $sce.trustAsHtml('<th class="dow text-center">' + weekDaysLabels.join('</th><th class="dow text-center">') + '</th>');

                var startDate = picker.$date || (options.startDate ? new Date(options.startDate) : new Date());
                var viewDate = {
                    year: startDate.getFullYear(),
                    month: startDate.getMonth(),
                    date: startDate.getDate()
                };
                var timezoneOffset = startDate.getTimezoneOffset() * 6e4;

                var views = [{
                    format: options.dayFormat,
                    split: 7,
                    steps: {
                        month: 1
                    },
                    update: function(date, force) {
                        if (!this.built || force || date.getFullYear() !== viewDate.year || date.getMonth() !== viewDate.month) {
                            angular.extend(viewDate, {
                                year: picker.$date.getFullYear(),
                                month: picker.$date.getMonth(),
                                date: picker.$date.getDate()
                            });
                            picker.$build();
                        } else if (date.getDate() !== viewDate.date) {
                            viewDate.date = picker.$date.getDate();
                            picker.$updateSelected();
                        }
                    },
                    build: function() {
                        var firstDayOfMonth = new Date(viewDate.year, viewDate.month, 1),
                            firstDayOfMonthOffset = firstDayOfMonth.getTimezoneOffset();
                        var firstDate = new Date(+firstDayOfMonth - mod(firstDayOfMonth.getDay() - options.startWeek, 7) * 864e5),
                            firstDateOffset = firstDate.getTimezoneOffset();
                        var today = new Date().toDateString();
                        // Handle daylight time switch
                        if (firstDateOffset !== firstDayOfMonthOffset) firstDate = new Date(+firstDate + (firstDateOffset - firstDayOfMonthOffset) * 60e3);
                        var days = [],
                            day;
                        for (var i = 0; i < 42; i++) { // < 7 * 6
                            day = new Date(firstDate.getFullYear(), firstDate.getMonth(), firstDate.getDate() + i);
                            days.push({
                                date: day,
                                isToday: day.toDateString() === today,
                                label: dateFilter(day, this.format),
                                selected: picker.$date && this.isSelected(day),
                                muted: day.getMonth() !== viewDate.month,
                                disabled: this.isDisabled(day)
                            });
                        }
                        scope.title = dateFilter(firstDayOfMonth, 'MMMM yyyy');
                        scope.showLabels = true;
                        scope.labels = weekDaysLabelsHtml;
                        scope.rows = split(days, this.split);
                        this.built = true;
                    },
                    isSelected: function(date) {
                        return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth() && date.getDate() === picker.$date.getDate();
                    },
                    isDisabled: function(date) {
                        var time = date.getTime();

                        // Disabled because of min/max date.
                        if (time < options.minDate || time > options.maxDate) return true;

                        // Disabled due to being a disabled day of the week
                        if (options.daysOfWeekDisabled.indexOf(date.getDay()) !== -1) return true;

                        // Disabled because of disabled date range.
                        if (options.disabledDateRanges) {
                            for (var i = 0; i < options.disabledDateRanges.length; i++) {
                                if (time >= options.disabledDateRanges[i].start) {
                                    if (time <= options.disabledDateRanges[i].end) return true;

                                    // The disabledDateRanges is expected to be sorted, so if time >= start,
                                    // we know it's not disabled.
                                    return false;
                                }
                            }
                        }

                        return false;
                    },
                    onKeyDown: function(evt) {
                        var actualTime = picker.$date.getTime();
                        var newDate;

                        if (evt.keyCode === 37) newDate = new Date(actualTime - 1 * 864e5);
                        else if (evt.keyCode === 38) newDate = new Date(actualTime - 7 * 864e5);
                        else if (evt.keyCode === 39) newDate = new Date(actualTime + 1 * 864e5);
                        else if (evt.keyCode === 40) newDate = new Date(actualTime + 7 * 864e5);

                        if (!this.isDisabled(newDate)) picker.select(newDate, true);
                    }
                }, {
                    name: 'month',
                    format: 'MMM',
                    split: 4,
                    steps: {
                        year: 1
                    },
                    update: function(date, force) {
                        if (!this.built || date.getFullYear() !== viewDate.year) {
                            angular.extend(viewDate, {
                                year: picker.$date.getFullYear(),
                                month: picker.$date.getMonth(),
                                date: picker.$date.getDate()
                            });
                            picker.$build();
                        } else if (date.getMonth() !== viewDate.month) {
                            angular.extend(viewDate, {
                                month: picker.$date.getMonth(),
                                date: picker.$date.getDate()
                            });
                            picker.$updateSelected();
                        }
                    },
                    build: function() {
                        var firstMonth = new Date(viewDate.year, 0, 1);
                        var months = [],
                            month;
                        for (var i = 0; i < 12; i++) {
                            month = new Date(viewDate.year, i, 1);
                            months.push({
                                date: month,
                                label: dateFilter(month, this.format),
                                selected: picker.$isSelected(month),
                                disabled: this.isDisabled(month)
                            });
                        }
                        scope.title = dateFilter(month, 'yyyy');
                        scope.showLabels = false;
                        scope.rows = split(months, this.split);
                        this.built = true;
                    },
                    isSelected: function(date) {
                        return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth();
                    },
                    isDisabled: function(date) {
                        var lastDate = +new Date(date.getFullYear(), date.getMonth() + 1, 0);
                        return lastDate < options.minDate || date.getTime() > options.maxDate;
                    },
                    onKeyDown: function(evt) {
                        var actualMonth = picker.$date.getMonth();
                        var newDate = new Date(picker.$date);

                        if (evt.keyCode === 37) newDate.setMonth(actualMonth - 1);
                        else if (evt.keyCode === 38) newDate.setMonth(actualMonth - 4);
                        else if (evt.keyCode === 39) newDate.setMonth(actualMonth + 1);
                        else if (evt.keyCode === 40) newDate.setMonth(actualMonth + 4);

                        if (!this.isDisabled(newDate)) picker.select(newDate, true);
                    }
                }, {
                    name: 'year',
                    format: 'yyyy',
                    split: 4,
                    steps: {
                        year: 12
                    },
                    update: function(date, force) {
                        if (!this.built || force || parseInt(date.getFullYear() / 20, 10) !== parseInt(viewDate.year / 20, 10)) {
                            angular.extend(viewDate, {
                                year: picker.$date.getFullYear(),
                                month: picker.$date.getMonth(),
                                date: picker.$date.getDate()
                            });
                            picker.$build();
                        } else if (date.getFullYear() !== viewDate.year) {
                            angular.extend(viewDate, {
                                year: picker.$date.getFullYear(),
                                month: picker.$date.getMonth(),
                                date: picker.$date.getDate()
                            });
                            picker.$updateSelected();
                        }
                    },
                    build: function() {
                        var firstYear = viewDate.year - viewDate.year % (this.split * 3);
                        var years = [],
                            year;
                        for (var i = 0; i < 12; i++) {
                            year = new Date(firstYear + i, 0, 1);
                            years.push({
                                date: year,
                                label: dateFilter(year, this.format),
                                selected: picker.$isSelected(year),
                                disabled: this.isDisabled(year)
                            });
                        }
                        scope.title = years[0].label + '-' + years[years.length - 1].label;
                        scope.showLabels = false;
                        scope.rows = split(years, this.split);
                        this.built = true;
                    },
                    isSelected: function(date) {
                        return picker.$date && date.getFullYear() === picker.$date.getFullYear();
                    },
                    isDisabled: function(date) {
                        var lastDate = +new Date(date.getFullYear() + 1, 0, 0);
                        return lastDate < options.minDate || date.getTime() > options.maxDate;
                    },
                    onKeyDown: function(evt) {
                        var actualYear = picker.$date.getFullYear(),
                            newDate = new Date(picker.$date);

                        if (evt.keyCode === 37) newDate.setYear(actualYear - 1);
                        else if (evt.keyCode === 38) newDate.setYear(actualYear - 4);
                        else if (evt.keyCode === 39) newDate.setYear(actualYear + 1);
                        else if (evt.keyCode === 40) newDate.setYear(actualYear + 4);

                        if (!this.isDisabled(newDate)) picker.select(newDate, true);
                    }
                }];

                return {
                    views: options.minView ? Array.prototype.slice.call(views, options.minView) : views,
                    viewDate: viewDate
                };

            };

        }];

    });

    // Source: dropdown.js
    angular.module('mgcrea.ngStrap.dropdown', ['mgcrea.ngStrap.tooltip'])

    .provider('$dropdown', function() {

        var defaults = this.defaults = {
            animation: 'am-fade',
            prefixClass: 'dropdown',
            placement: 'bottom-left',
            template: 'dropdown/dropdown.tpl.html',
            trigger: 'click',
            container: false,
            keyboard: true,
            html: false,
            delay: 0
        };

        this.$get = ["$window", "$rootScope", "$tooltip", function($window, $rootScope, $tooltip) {

            var bodyEl = angular.element($window.document.body);
            var matchesSelector = Element.prototype.matchesSelector || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector;

            function DropdownFactory(element, config) {

                var $dropdown = {};

                // Common vars
                var options = angular.extend({}, defaults, config);
                var scope = $dropdown.$scope = options.scope && options.scope.$new() || $rootScope.$new();

                $dropdown = $tooltip(element, options);
                var parentEl = element.parent();

                // Protected methods

                $dropdown.$onKeyDown = function(evt) {
                    if (!/(38|40)/.test(evt.keyCode)) return;
                    evt.preventDefault();
                    evt.stopPropagation();

                    // Retrieve focused index
                    var items = angular.element($dropdown.$element[0].querySelectorAll('li:not(.divider) a'));
                    if (!items.length) return;
                    var index;
                    angular.forEach(items, function(el, i) {
                        if (matchesSelector && matchesSelector.call(el, ':focus')) index = i;
                    });

                    // Navigate with keyboard
                    if (evt.keyCode === 38 && index > 0) index--;
                    else if (evt.keyCode === 40 && index < items.length - 1) index++;
                    else if (angular.isUndefined(index)) index = 0;
                    items.eq(index)[0].focus();

                };

                // Overrides

                var show = $dropdown.show;
                $dropdown.show = function() {
                    show();
                    setTimeout(function() {
                        options.keyboard && $dropdown.$element.on('keydown', $dropdown.$onKeyDown);
                        bodyEl.on('click', onBodyClick);
                    });
                    parentEl.hasClass('dropdown') && parentEl.addClass('open');
                };

                var hide = $dropdown.hide;
                $dropdown.hide = function() {
                    options.keyboard && $dropdown.$element.off('keydown', $dropdown.$onKeyDown);
                    bodyEl.off('click', onBodyClick);
                    parentEl.hasClass('dropdown') && parentEl.removeClass('open');
                    hide();
                };

                // Private functions

                function onBodyClick(evt) {
                    if (evt.target === element[0]) return;
                    return evt.target !== element[0] && $dropdown.hide();
                }

                return $dropdown;

            }

            return DropdownFactory;

        }];

    })

    .directive('bsDropdown', ["$window", "$sce", "$dropdown", function($window, $sce, $dropdown) {

        return {
            restrict: 'EAC',
            scope: true,
            link: function postLink(scope, element, attr, transclusion) {

                // Directive options
                var options = {
                    scope: scope
                };
                angular.forEach(['placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'template'], function(key) {
                    if (angular.isDefined(attr[key])) options[key] = attr[key];
                });

                // Support scope as an object
                attr.bsDropdown && scope.$watch(attr.bsDropdown, function(newValue, oldValue) {
                    scope.content = newValue;
                }, true);

                // Visibility binding support
                attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {
                    if (!dropdown || !angular.isDefined(newValue)) return;
                    if (angular.isString(newValue)) newValue = !!newValue.match(',?(dropdown),?');
                    newValue === true ? dropdown.show() : dropdown.hide();
                });

                // Initialize dropdown
                var dropdown = $dropdown(element, options);

                // Garbage collection
                scope.$on('$destroy', function() {
                    if (dropdown) dropdown.destroy();
                    options = null;
                    dropdown = null;
                });

            }
        };

    }]);

    // Source: date-parser.js
    angular.module('mgcrea.ngStrap.helpers.dateParser', [])

    .provider('$dateParser', ["$localeProvider", function($localeProvider) {

        var proto = Date.prototype;

        function noop() {}

        function isNumeric(n) {
            return !isNaN(parseFloat(n)) && isFinite(n);
        }

        var defaults = this.defaults = {
            format: 'shortDate',
            strict: false
        };

        this.$get = ["$locale", "dateFilter", function($locale, dateFilter) {

            var DateParserFactory = function(config) {

                var options = angular.extend({}, defaults, config);

                var $dateParser = {};

                var regExpMap = {
                    'sss': '[0-9]{3}',
                    'ss': '[0-5][0-9]',
                    's': options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',
                    'mm': '[0-5][0-9]',
                    'm': options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',
                    'HH': '[01][0-9]|2[0-3]',
                    'H': options.strict ? '1?[0-9]|2[0-3]' : '[01]?[0-9]|2[0-3]',
                    'hh': '[0][1-9]|[1][012]',
                    'h': options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',
                    'a': 'AM|PM',
                    'EEEE': $locale.DATETIME_FORMATS.DAY.join('|'),
                    'EEE': $locale.DATETIME_FORMATS.SHORTDAY.join('|'),
                    'dd': '0[1-9]|[12][0-9]|3[01]',
                    'd': options.strict ? '[1-9]|[1-2][0-9]|3[01]' : '0?[1-9]|[1-2][0-9]|3[01]',
                    'MMMM': $locale.DATETIME_FORMATS.MONTH.join('|'),
                    'MMM': $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),
                    'MM': '0[1-9]|1[012]',
                    'M': options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',
                    'yyyy': '[1]{1}[0-9]{3}|[2]{1}[0-9]{3}',
                    'yy': '[0-9]{2}',
                    'y': options.strict ? '-?(0|[1-9][0-9]{0,3})' : '-?0*[0-9]{1,4}'
                };

                var setFnMap = {
                    'sss': proto.setMilliseconds,
                    'ss': proto.setSeconds,
                    's': proto.setSeconds,
                    'mm': proto.setMinutes,
                    'm': proto.setMinutes,
                    'HH': proto.setHours,
                    'H': proto.setHours,
                    'hh': proto.setHours,
                    'h': proto.setHours,
                    'EEEE': noop,
                    'EEE': noop,
                    'dd': proto.setDate,
                    'd': proto.setDate,
                    'a': function(value) {
                        var hours = this.getHours() % 12;
                        return this.setHours(value.match(/pm/i) ? hours + 12 : hours);
                    },
                    'MMMM': function(value) {
                        return this.setMonth($locale.DATETIME_FORMATS.MONTH.indexOf(value));
                    },
                    'MMM': function(value) {
                        return this.setMonth($locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value));
                    },
                    'MM': function(value) {
                        return this.setMonth(1 * value - 1);
                    },
                    'M': function(value) {
                        return this.setMonth(1 * value - 1);
                    },
                    'yyyy': proto.setFullYear,
                    'yy': function(value) {
                        return this.setFullYear(2000 + 1 * value);
                    },
                    'y': proto.setFullYear
                };

                var regex, setMap;

                $dateParser.init = function() {
                    $dateParser.$format = $locale.DATETIME_FORMATS[options.format] || options.format;
                    regex = regExpForFormat($dateParser.$format);
                    setMap = setMapForFormat($dateParser.$format);
                };

                $dateParser.isValid = function(date) {
                    if (angular.isDate(date)) return !isNaN(date.getTime());
                    return regex.test(date);
                };

                $dateParser.parse = function(value, baseDate, format) {
                    if (angular.isDate(value)) value = dateFilter(value, format || $dateParser.$format);
                    var formatRegex = format ? regExpForFormat(format) : regex;
                    var formatSetMap = format ? setMapForFormat(format) : setMap;
                    var matches = formatRegex.exec(value);
                    if (!matches) return false;
                    var date = baseDate && !isNaN(baseDate.getTime()) ? baseDate : new Date(1970, 0, 1, 0);
                    for (var i = 0; i < matches.length - 1; i++) {
                        formatSetMap[i] && formatSetMap[i].call(date, matches[i + 1]);
                    }
                    return date;
                };

                // Private functions

                function setMapForFormat(format) {
                    var keys = Object.keys(setFnMap),
                        i;
                    var map = [],
                        sortedMap = [];
                    // Map to setFn
                    var clonedFormat = format;
                    for (i = 0; i < keys.length; i++) {
                        if (format.split(keys[i]).length > 1) {
                            var index = clonedFormat.search(keys[i]);
                            format = format.split(keys[i]).join('');
                            if (setFnMap[keys[i]]) {
                                map[index] = setFnMap[keys[i]];
                            }
                        }
                    }
                    // Sort result map
                    angular.forEach(map, function(v) {
                        // conditional required since angular.forEach broke around v1.2.21
                        // related pr: https://github.com/angular/angular.js/pull/8525
                        if (v) sortedMap.push(v);
                    });
                    return sortedMap;
                }

                function escapeReservedSymbols(text) {
                    return text.replace(/\//g, '[\\/]').replace('/-/g', '[-]').replace(/\./g, '[.]').replace(/\\s/g, '[\\s]');
                }

                function regExpForFormat(format) {
                    var keys = Object.keys(regExpMap),
                        i;

                    var re = format;
                    // Abstract replaces to avoid collisions
                    for (i = 0; i < keys.length; i++) {
                        re = re.split(keys[i]).join('${' + i + '}');
                    }
                    // Replace abstracted values
                    for (i = 0; i < keys.length; i++) {
                        re = re.split('${' + i + '}').join('(' + regExpMap[keys[i]] + ')');
                    }
                    format = escapeReservedSymbols(format);

                    return new RegExp('^' + re + '$', ['i']);
                }

                $dateParser.init();
                return $dateParser;

            };

            return DateParserFactory;

        }];

    }]);

    // Source: debounce.js
    angular.module('mgcrea.ngStrap.helpers.debounce', [])

    // @source jashkenas/underscore
    // @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L693
    .factory('debounce', ["$timeout", function($timeout) {
        return function(func, wait, immediate) {
            var timeout = null;
            return function() {
                var context = this,
                    args = arguments,
                    callNow = immediate && !timeout;
                if (timeout) {
                    $timeout.cancel(timeout);
                }
                timeout = $timeout(function later() {
                    timeout = null;
                    if (!immediate) {
                        func.apply(context, args);
                    }
                }, wait, false);
                if (callNow) {
                    func.apply(context, args);
                }
                return timeout;
            };
        };
    }])


    // @source jashkenas/underscore
    // @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L661
    .factory('throttle', ["$timeout", function($timeout) {
        return function(func, wait, options) {
            var timeout = null;
            options || (options = {});
            return function() {
                var context = this,
                    args = arguments;
                if (!timeout) {
                    if (options.leading !== false) {
                        func.apply(context, args);
                    }
                    timeout = $timeout(function later() {
                        timeout = null;
                        if (options.trailing !== false) {
                            func.apply(context, args);
                        }
                    }, wait, false);
                }
            };
        };
    }]);

    // Source: dimensions.js
    angular.module('mgcrea.ngStrap.helpers.dimensions', [])

    .factory('dimensions', ["$document", "$window", function($document, $window) {

        var jqLite = angular.element;
        var fn = {};

        /**
         * Test the element nodeName
         * @param element
         * @param name
         */
        var nodeName = fn.nodeName = function(element, name) {
            return element.nodeName && element.nodeName.toLowerCase() === name.toLowerCase();
        };

        /**
         * Returns the element computed style
         * @param element
         * @param prop
         * @param extra
         */
        fn.css = function(element, prop, extra) {
            var value;
            if (element.currentStyle) { //IE
                value = element.currentStyle[prop];
            } else if (window.getComputedStyle) {
                value = window.getComputedStyle(element)[prop];
            } else {
                value = element.style[prop];
            }
            return extra === true ? parseFloat(value) || 0 : value;
        };

        /**
         * Provides read-only equivalent of jQuery's offset function:
         * @required-by bootstrap-tooltip, bootstrap-affix
         * @url http://api.jquery.com/offset/
         * @param element
         */
        fn.offset = function(element) {
            var boxRect = element.getBoundingClientRect();
            var docElement = element.ownerDocument;
            return {
                width: boxRect.width || element.offsetWidth,
                height: boxRect.height || element.offsetHeight,
                top: boxRect.top + (window.pageYOffset || docElement.documentElement.scrollTop) - (docElement.documentElement.clientTop || 0),
                left: boxRect.left + (window.pageXOffset || docElement.documentElement.scrollLeft) - (docElement.documentElement.clientLeft || 0)
            };
        };

        /**
         * Provides read-only equivalent of jQuery's position function
         * @required-by bootstrap-tooltip, bootstrap-affix
         * @url http://api.jquery.com/offset/
         * @param element
         */
        fn.position = function(element) {

            var offsetParentRect = {
                    top: 0,
                    left: 0
                },
                offsetParentElement,
                offset;

            // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent
            if (fn.css(element, 'position') === 'fixed') {

                // We assume that getBoundingClientRect is available when computed position is fixed
                offset = element.getBoundingClientRect();

            } else {

                // Get *real* offsetParentElement
                offsetParentElement = offsetParent(element);
                offset = fn.offset(element);

                // Get correct offsets
                offset = fn.offset(element);
                if (!nodeName(offsetParentElement, 'html')) {
                    offsetParentRect = fn.offset(offsetParentElement);
                }

                // Add offsetParent borders
                offsetParentRect.top += fn.css(offsetParentElement, 'borderTopWidth', true);
                offsetParentRect.left += fn.css(offsetParentElement, 'borderLeftWidth', true);
            }

            // Subtract parent offsets and element margins
            return {
                width: element.offsetWidth,
                height: element.offsetHeight,
                top: offset.top - offsetParentRect.top - fn.css(element, 'marginTop', true),
                left: offset.left - offsetParentRect.left - fn.css(element, 'marginLeft', true)
            };

        };

        /**
         * Returns the closest, non-statically positioned offsetParent of a given element
         * @required-by fn.position
         * @param element
         */
        var offsetParent = function offsetParentElement(element) {
            var docElement = element.ownerDocument;
            var offsetParent = element.offsetParent || docElement;
            if (nodeName(offsetParent, '#document')) return docElement.documentElement;
            while (offsetParent && !nodeName(offsetParent, 'html') && fn.css(offsetParent, 'position') === 'static') {
                offsetParent = offsetParent.offsetParent;
            }
            return offsetParent || docElement.documentElement;
        };

        /**
         * Provides equivalent of jQuery's height function
         * @required-by bootstrap-affix
         * @url http://api.jquery.com/height/
         * @param element
         * @param outer
         */
        fn.height = function(element, outer) {
            var value = element.offsetHeight;
            if (outer) {
                value += fn.css(element, 'marginTop', true) + fn.css(element, 'marginBottom', true);
            } else {
                value -= fn.css(element, 'paddingTop', true) + fn.css(element, 'paddingBottom', true) + fn.css(element, 'borderTopWidth', true) + fn.css(element, 'borderBottomWidth', true);
            }
            return value;
        };

        /**
         * Provides equivalent of jQuery's width function
         * @required-by bootstrap-affix
         * @url http://api.jquery.com/width/
         * @param element
         * @param outer
         */
        fn.width = function(element, outer) {
            var value = element.offsetWidth;
            if (outer) {
                value += fn.css(element, 'marginLeft', true) + fn.css(element, 'marginRight', true);
            } else {
                value -= fn.css(element, 'paddingLeft', true) + fn.css(element, 'paddingRight', true) + fn.css(element, 'borderLeftWidth', true) + fn.css(element, 'borderRightWidth', true);
            }
            return value;
        };

        return fn;

    }]);

    // Source: parse-options.js
    angular.module('mgcrea.ngStrap.helpers.parseOptions', [])

    .provider('$parseOptions', function() {

        var defaults = this.defaults = {
            regexp: /^\s*(.*?)(?:\s+as\s+(.*?))?(?:\s+group\s+by\s+(.*))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+(.*?)(?:\s+track\s+by\s+(.*?))?$/
        };

        this.$get = ["$parse", "$q", function($parse, $q) {

            function ParseOptionsFactory(attr, config) {

                var $parseOptions = {};

                // Common vars
                var options = angular.extend({}, defaults, config);
                $parseOptions.$values = [];

                // Private vars
                var match, displayFn, valueName, keyName, groupByFn, valueFn, valuesFn;

                $parseOptions.init = function() {
                    $parseOptions.$match = match = attr.match(options.regexp);
                    displayFn = $parse(match[2] || match[1]),
                        valueName = match[4] || match[6],
                        keyName = match[5],
                        groupByFn = $parse(match[3] || ''),
                        valueFn = $parse(match[2] ? match[1] : valueName),
                        valuesFn = $parse(match[7]);
                };

                $parseOptions.valuesFn = function(scope, controller) {
                    return $q.when(valuesFn(scope, controller))
                        .then(function(values) {
                            $parseOptions.$values = values ? parseValues(values, scope) : {};
                            return $parseOptions.$values;
                        });
                };

                // Private functions

                function parseValues(values, scope) {
                    return values.map(function(match, index) {
                        var locals = {},
                            label, value;
                        locals[valueName] = match;
                        label = displayFn(scope, locals);
                        value = valueFn(scope, locals) || index;
                        return {
                            label: label,
                            value: value,
                            index: index
                        };
                    });
                }

                $parseOptions.init();
                return $parseOptions;

            }

            return ParseOptionsFactory;

        }];

    });

    // Source: raf.js
    (angular.version.minor < 3 && angular.version.dot < 14) && angular.module('ng')

    .factory('$$rAF', ["$window", "$timeout", function($window, $timeout) {

        var requestAnimationFrame = $window.requestAnimationFrame ||
            $window.webkitRequestAnimationFrame ||
            $window.mozRequestAnimationFrame;

        var cancelAnimationFrame = $window.cancelAnimationFrame ||
            $window.webkitCancelAnimationFrame ||
            $window.mozCancelAnimationFrame ||
            $window.webkitCancelRequestAnimationFrame;

        var rafSupported = !!requestAnimationFrame;
        var raf = rafSupported ?
            function(fn) {
                var id = requestAnimationFrame(fn);
                return function() {
                    cancelAnimationFrame(id);
                };
            } :
            function(fn) {
                var timer = $timeout(fn, 16.66, false); // 1000 / 60 = 16.666
                return function() {
                    $timeout.cancel(timer);
                };
            };

        raf.supported = rafSupported;

        return raf;

    }]);

    // .factory('$$animateReflow', function($$rAF, $document) {

    //   var bodyEl = $document[0].body;

    //   return function(fn) {
    //     //the returned function acts as the cancellation function
    //     return $$rAF(function() {
    //       //the line below will force the browser to perform a repaint
    //       //so that all the animated elements within the animation frame
    //       //will be properly updated and drawn on screen. This is
    //       //required to perform multi-class CSS based animations with
    //       //Firefox. DO NOT REMOVE THIS LINE.
    //       var a = bodyEl.offsetWidth + 1;
    //       fn();
    //     });
    //   };

    // });

    // Source: navbar.js
    angular.module('mgcrea.ngStrap.navbar', [])

    .provider('$navbar', function() {

        var defaults = this.defaults = {
            activeClass: 'active',
            routeAttr: 'data-match-route',
            strict: false
        };

        this.$get = function() {
            return {
                defaults: defaults
            };
        };

    })

    .directive('bsNavbar', ["$window", "$location", "$navbar", function($window, $location, $navbar) {

        var defaults = $navbar.defaults;

        return {
            restrict: 'A',
            link: function postLink(scope, element, attr, controller) {

                // Directive options
                var options = angular.copy(defaults);
                angular.forEach(Object.keys(defaults), function(key) {
                    if (angular.isDefined(attr[key])) options[key] = attr[key];
                });

                // Watch for the $location
                scope.$watch(function() {

                    return $location.path();

                }, function(newValue, oldValue) {

                    var liElements = element[0].querySelectorAll('li[' + options.routeAttr + ']');

                    angular.forEach(liElements, function(li) {

                        var liElement = angular.element(li);
                        var pattern = liElement.attr(options.routeAttr).replace('/', '\\/');
                        if (options.strict) {
                            pattern = '^' + pattern + '$';
                        }
                        var regexp = new RegExp(pattern, ['i']);

                        if (regexp.test(newValue)) {
                            liElement.addClass(options.activeClass);
                        } else {
                            liElement.removeClass(options.activeClass);
                        }

                    });

                });

            }

        };

    }]);

    // Source: popover.js
    angular.module('mgcrea.ngStrap.popover', ['mgcrea.ngStrap.tooltip'])

    .provider('$popover', function() {

        var defaults = this.defaults = {
            animation: 'am-fade',
            customClass: '',
            container: false,
            target: false,
            placement: 'right',
            template: 'popover/popover.tpl.html',
            contentTemplate: false,
            trigger: 'click',
            keyboard: true,
            html: false,
            title: '',
            content: '',
            delay: 0
        };

        this.$get = ["$tooltip", function($tooltip) {

            function PopoverFactory(element, config) {

                // Common vars
                var options = angular.extend({}, defaults, config);

                var $popover = $tooltip(element, options);

                // Support scope as string options [/*title, */content]
                if (options.content) {
                    $popover.$scope.content = options.content;
                }

                return $popover;

            }

            return PopoverFactory;

        }];

    })

    .directive('bsPopover', ["$window", "$sce", "$popover", function($window, $sce, $popover) {

        var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;

        return {
            restrict: 'EAC',
            scope: true,
            link: function postLink(scope, element, attr) {

                // Directive options
                var options = {
                    scope: scope
                };
                angular.forEach(['template', 'contentTemplate', 'placement', 'container', 'target', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'customClass'], function(key) {
                    if (angular.isDefined(attr[key])) options[key] = attr[key];
                });

                // Support scope as data-attrs
                angular.forEach(['title', 'content'], function(key) {
                    attr[key] && attr.$observe(key, function(newValue, oldValue) {
                        scope[key] = $sce.trustAsHtml(newValue);
                        angular.isDefined(oldValue) && requestAnimationFrame(function() {
                            popover && popover.$applyPlacement();
                        });
                    });
                });

                // Support scope as an object
                attr.bsPopover && scope.$watch(attr.bsPopover, function(newValue, oldValue) {
                    if (angular.isObject(newValue)) {
                        angular.extend(scope, newValue);
                    } else {
                        scope.content = newValue;
                    }
                    angular.isDefined(oldValue) && requestAnimationFrame(function() {
                        popover && popover.$applyPlacement();
                    });
                }, true);

                // Visibility binding support
                attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {
                    if (!popover || !angular.isDefined(newValue)) return;
                    if (angular.isString(newValue)) newValue = !!newValue.match(',?(popover),?');
                    newValue === true ? popover.show() : popover.hide();
                });

                // Initialize popover
                var popover = $popover(element, options);

                // Garbage collection
                scope.$on('$destroy', function() {
                    if (popover) popover.destroy();
                    options = null;
                    popover = null;
                });

            }
        };

    }]);

    // Source: scrollspy.js
    angular.module('mgcrea.ngStrap.scrollspy', ['mgcrea.ngStrap.helpers.debounce', 'mgcrea.ngStrap.helpers.dimensions'])

    .provider('$scrollspy', function() {

        // Pool of registered spies
        var spies = this.$$spies = {};

        var defaults = this.defaults = {
            debounce: 150,
            throttle: 100,
            offset: 100
        };

        this.$get = ["$window", "$document", "$rootScope", "dimensions", "debounce", "throttle", function($window, $document, $rootScope, dimensions, debounce, throttle) {

            var windowEl = angular.element($window);
            var docEl = angular.element($document.prop('documentElement'));
            var bodyEl = angular.element($window.document.body);

            // Helper functions

            function nodeName(element, name) {
                return element[0].nodeName && element[0].nodeName.toLowerCase() === name.toLowerCase();
            }

            function ScrollSpyFactory(config) {

                // Common vars
                var options = angular.extend({}, defaults, config);
                if (!options.element) options.element = bodyEl;
                var isWindowSpy = nodeName(options.element, 'body');
                var scrollEl = isWindowSpy ? windowEl : options.element;
                var scrollId = isWindowSpy ? 'window' : options.id;

                // Use existing spy
                if (spies[scrollId]) {
                    spies[scrollId].$$count++;
                    return spies[scrollId];
                }

                var $scrollspy = {};

                // Private vars
                var unbindViewContentLoaded, unbindIncludeContentLoaded;
                var trackedElements = $scrollspy.$trackedElements = [];
                var sortedElements = [];
                var activeTarget;
                var debouncedCheckPosition;
                var throttledCheckPosition;
                var debouncedCheckOffsets;
                var viewportHeight;
                var scrollTop;

                $scrollspy.init = function() {

                    // Setup internal ref counter
                    this.$$count = 1;

                    // Bind events
                    debouncedCheckPosition = debounce(this.checkPosition, options.debounce);
                    throttledCheckPosition = throttle(this.checkPosition, options.throttle);
                    scrollEl.on('click', this.checkPositionWithEventLoop);
                    windowEl.on('resize', debouncedCheckPosition);
                    scrollEl.on('scroll', throttledCheckPosition);

                    debouncedCheckOffsets = debounce(this.checkOffsets, options.debounce);
                    unbindViewContentLoaded = $rootScope.$on('$viewContentLoaded', debouncedCheckOffsets);
                    unbindIncludeContentLoaded = $rootScope.$on('$includeContentLoaded', debouncedCheckOffsets);
                    debouncedCheckOffsets();

                    // Register spy for reuse
                    if (scrollId) {
                        spies[scrollId] = $scrollspy;
                    }

                };

                $scrollspy.destroy = function() {

                    // Check internal ref counter
                    this.$$count--;
                    if (this.$$count > 0) {
                        return;
                    }

                    // Unbind events
                    scrollEl.off('click', this.checkPositionWithEventLoop);
                    windowEl.off('resize', debouncedCheckPosition);
                    scrollEl.off('scroll', debouncedCheckPosition);
                    unbindViewContentLoaded();
                    unbindIncludeContentLoaded();
                    if (scrollId) {
                        delete spies[scrollId];
                    }
                };

                $scrollspy.checkPosition = function() {

                    // Not ready yet
                    if (!sortedElements.length) return;

                    // Calculate the scroll position
                    scrollTop = (isWindowSpy ? $window.pageYOffset : scrollEl.prop('scrollTop')) || 0;

                    // Calculate the viewport height for use by the components
                    viewportHeight = Math.max($window.innerHeight, docEl.prop('clientHeight'));

                    // Activate first element if scroll is smaller
                    if (scrollTop < sortedElements[0].offsetTop && activeTarget !== sortedElements[0].target) {
                        return $scrollspy.$activateElement(sortedElements[0]);
                    }

                    // Activate proper element
                    for (var i = sortedElements.length; i--;) {
                        if (angular.isUndefined(sortedElements[i].offsetTop) || sortedElements[i].offsetTop === null) continue;
                        if (activeTarget === sortedElements[i].target) continue;
                        if (scrollTop < sortedElements[i].offsetTop) continue;
                        if (sortedElements[i + 1] && scrollTop > sortedElements[i + 1].offsetTop) continue;
                        return $scrollspy.$activateElement(sortedElements[i]);
                    }

                };

                $scrollspy.checkPositionWithEventLoop = function() {
                    setTimeout(this.checkPosition, 1);
                };

                // Protected methods

                $scrollspy.$activateElement = function(element) {
                    if (activeTarget) {
                        var activeElement = $scrollspy.$getTrackedElement(activeTarget);
                        if (activeElement) {
                            activeElement.source.removeClass('active');
                            if (nodeName(activeElement.source, 'li') && nodeName(activeElement.source.parent().parent(), 'li')) {
                                activeElement.source.parent().parent().removeClass('active');
                            }
                        }
                    }
                    activeTarget = element.target;
                    element.source.addClass('active');
                    if (nodeName(element.source, 'li') && nodeName(element.source.parent().parent(), 'li')) {
                        element.source.parent().parent().addClass('active');
                    }
                };

                $scrollspy.$getTrackedElement = function(target) {
                    return trackedElements.filter(function(obj) {
                        return obj.target === target;
                    })[0];
                };

                // Track offsets behavior

                $scrollspy.checkOffsets = function() {

                    angular.forEach(trackedElements, function(trackedElement) {
                        var targetElement = document.querySelector(trackedElement.target);
                        trackedElement.offsetTop = targetElement ? dimensions.offset(targetElement).top : null;
                        if (options.offset && trackedElement.offsetTop !== null) trackedElement.offsetTop -= options.offset * 1;
                    });

                    sortedElements = trackedElements
                        .filter(function(el) {
                            return el.offsetTop !== null;
                        })
                        .sort(function(a, b) {
                            return a.offsetTop - b.offsetTop;
                        });

                    debouncedCheckPosition();

                };

                $scrollspy.trackElement = function(target, source) {
                    trackedElements.push({
                        target: target,
                        source: source
                    });
                };

                $scrollspy.untrackElement = function(target, source) {
                    var toDelete;
                    for (var i = trackedElements.length; i--;) {
                        if (trackedElements[i].target === target && trackedElements[i].source === source) {
                            toDelete = i;
                            break;
                        }
                    }
                    trackedElements = trackedElements.splice(toDelete, 1);
                };

                $scrollspy.activate = function(i) {
                    trackedElements[i].addClass('active');
                };

                // Initialize plugin

                $scrollspy.init();
                return $scrollspy;

            }

            return ScrollSpyFactory;

        }];

    })

    .directive('bsScrollspy', ["$rootScope", "debounce", "dimensions", "$scrollspy", function($rootScope, debounce, dimensions, $scrollspy) {

        return {
            restrict: 'EAC',
            link: function postLink(scope, element, attr) {

                var options = {
                    scope: scope
                };
                angular.forEach(['offset', 'target'], function(key) {
                    if (angular.isDefined(attr[key])) options[key] = attr[key];
                });

                var scrollspy = $scrollspy(options);
                scrollspy.trackElement(options.target, element);

                scope.$on('$destroy', function() {
                    if (scrollspy) {
                        scrollspy.untrackElement(options.target, element);
                        scrollspy.destroy();
                    }
                    options = null;
                    scrollspy = null;
                });

            }
        };

    }])


    .directive('bsScrollspyList', ["$rootScope", "debounce", "dimensions", "$scrollspy", function($rootScope, debounce, dimensions, $scrollspy) {

        return {
            restrict: 'A',
            compile: function postLink(element, attr) {
                var children = element[0].querySelectorAll('li > a[href]');
                angular.forEach(children, function(child) {
                    var childEl = angular.element(child);
                    childEl.parent().attr('bs-scrollspy', '').attr('data-target', childEl.attr('href'));
                });
            }

        };

    }]);

    // Source: select.js
    angular.module('mgcrea.ngStrap.select', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])

    .provider('$select', function() {

        var defaults = this.defaults = {
            animation: 'am-fade',
            prefixClass: 'select',
            prefixEvent: '$select',
            placement: 'bottom-left',
            template: 'select/select.tpl.html',
            trigger: 'focus',
            container: false,
            keyboard: true,
            html: false,
            delay: 0,
            multiple: false,
            allNoneButtons: false,
            sort: true,
            caretHtml: '&nbsp;<span class="caret"></span>',
            placeholder: 'Choose among the following...',
            maxLength: 3,
            maxLengthHtml: 'selected',
            iconCheckmark: 'glyphicon glyphicon-ok'
        };

        this.$get = ["$window", "$document", "$rootScope", "$tooltip", function($window, $document, $rootScope, $tooltip) {

            var bodyEl = angular.element($window.document.body);
            var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);
            var isTouch = ('createTouch' in $window.document) && isNative;

            function SelectFactory(element, controller, config) {

                var $select = {};

                // Common vars
                var options = angular.extend({}, defaults, config);

                $select = $tooltip(element, options);
                var scope = $select.$scope;

                scope.$matches = [];
                scope.$activeIndex = 0;
                scope.$isMultiple = options.multiple;
                scope.$showAllNoneButtons = options.allNoneButtons && options.multiple;
                scope.$iconCheckmark = options.iconCheckmark;

                scope.$activate = function(index) {
                    scope.$$postDigest(function() {
                        $select.activate(index);
                    });
                };

                scope.$select = function(index, evt) {
                    scope.$$postDigest(function() {
                        $select.select(index);
                    });
                };

                scope.$isVisible = function() {
                    return $select.$isVisible();
                };

                scope.$isActive = function(index) {
                    return $select.$isActive(index);
                };

                scope.$selectAll = function() {
                    for (var i = 0; i < scope.$matches.length; i++) {
                        if (!scope.$isActive(i)) {
                            scope.$select(i);
                        }
                    }
                };

                scope.$selectNone = function() {
                    for (var i = 0; i < scope.$matches.length; i++) {
                        if (scope.$isActive(i)) {
                            scope.$select(i);
                        }
                    }
                };

                // Public methods

                $select.update = function(matches) {
                    scope.$matches = matches;
                    $select.$updateActiveIndex();
                };

                $select.activate = function(index) {
                    if (options.multiple) {
                        scope.$activeIndex.sort();
                        $select.$isActive(index) ? scope.$activeIndex.splice(scope.$activeIndex.indexOf(index), 1) : scope.$activeIndex.push(index);
                        if (options.sort) scope.$activeIndex.sort();
                    } else {
                        scope.$activeIndex = index;
                    }
                    return scope.$activeIndex;
                };

                $select.select = function(index) {
                    var value = scope.$matches[index].value;
                    scope.$apply(function() {
                        $select.activate(index);
                        if (options.multiple) {
                            controller.$setViewValue(scope.$activeIndex.map(function(index) {
                                return scope.$matches[index].value;
                            }));
                        } else {
                            controller.$setViewValue(value);
                            // Hide if single select
                            $select.hide();
                        }
                    });
                    // Emit event
                    scope.$emit(options.prefixEvent + '.select', value, index);
                };

                // Protected methods

                $select.$updateActiveIndex = function() {
                    if (controller.$modelValue && scope.$matches.length) {
                        if (options.multiple && angular.isArray(controller.$modelValue)) {
                            scope.$activeIndex = controller.$modelValue.map(function(value) {
                                return $select.$getIndex(value);
                            });
                        } else {
                            scope.$activeIndex = $select.$getIndex(controller.$modelValue);
                        }
                    } else if (scope.$activeIndex >= scope.$matches.length) {
                        scope.$activeIndex = options.multiple ? [] : 0;
                    }
                };

                $select.$isVisible = function() {
                    if (!options.minLength || !controller) {
                        return scope.$matches.length;
                    }
                    // minLength support
                    return scope.$matches.length && controller.$viewValue.length >= options.minLength;
                };

                $select.$isActive = function(index) {
                    if (options.multiple) {
                        return scope.$activeIndex.indexOf(index) !== -1;
                    } else {
                        return scope.$activeIndex === index;
                    }
                };

                $select.$getIndex = function(value) {
                    var l = scope.$matches.length,
                        i = l;
                    if (!l) return;
                    for (i = l; i--;) {
                        if (scope.$matches[i].value === value) break;
                    }
                    if (i < 0) return;
                    return i;
                };

                $select.$onMouseDown = function(evt) {
                    // Prevent blur on mousedown on .dropdown-menu
                    evt.preventDefault();
                    evt.stopPropagation();
                    // Emulate click for mobile devices
                    if (isTouch) {
                        var targetEl = angular.element(evt.target);
                        targetEl.triggerHandler('click');
                    }
                };

                $select.$onKeyDown = function(evt) {
                    if (!/(9|13|38|40)/.test(evt.keyCode)) return;
                    evt.preventDefault();
                    evt.stopPropagation();

                    // Select with enter
                    if (!options.multiple && (evt.keyCode === 13 || evt.keyCode === 9)) {
                        return $select.select(scope.$activeIndex);
                    }

                    // Navigate with keyboard
                    if (evt.keyCode === 38 && scope.$activeIndex > 0) scope.$activeIndex--;
                    else if (evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) scope.$activeIndex++;
                    else if (angular.isUndefined(scope.$activeIndex)) scope.$activeIndex = 0;
                    scope.$digest();
                };

                // Overrides

                var _show = $select.show;
                $select.show = function() {
                    _show();
                    if (options.multiple) {
                        $select.$element.addClass('select-multiple');
                    }
                    setTimeout(function() {
                        $select.$element.on(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);
                        if (options.keyboard) {
                            element.on('keydown', $select.$onKeyDown);
                        }
                    });
                };

                var _hide = $select.hide;
                $select.hide = function() {
                    $select.$element.off(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);
                    if (options.keyboard) {
                        element.off('keydown', $select.$onKeyDown);
                    }
                    _hide(true);
                };

                return $select;

            }

            SelectFactory.defaults = defaults;
            return SelectFactory;

        }];

    })

    .directive('bsSelect', ["$window", "$parse", "$q", "$select", "$parseOptions", function($window, $parse, $q, $select, $parseOptions) {

        var defaults = $select.defaults;

        return {
            restrict: 'EAC',
            require: 'ngModel',
            link: function postLink(scope, element, attr, controller) {

                // Directive options
                var options = {
                    scope: scope,
                    placeholder: defaults.placeholder
                };
                angular.forEach(['placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'template', 'placeholder', 'multiple', 'allNoneButtons', 'maxLength', 'maxLengthHtml'], function(key) {
                    if (angular.isDefined(attr[key])) options[key] = attr[key];
                });

                // Add support for select markup
                if (element[0].nodeName.toLowerCase() === 'select') {
                    var inputEl = element;
                    inputEl.css('display', 'none');
                    element = angular.element('<button type="button" class="btn btn-default"></button>');
                    inputEl.after(element);
                }

                // Build proper ngOptions
                var parsedOptions = $parseOptions(attr.ngOptions);

                // Initialize select
                var select = $select(element, controller, options);

                // Watch ngOptions values before filtering for changes
                var watchedOptions = parsedOptions.$match[7].replace(/\|.+/, '').trim();
                scope.$watch(watchedOptions, function(newValue, oldValue) {
                    // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);
                    parsedOptions.valuesFn(scope, controller)
                        .then(function(values) {
                            select.update(values);
                            controller.$render();
                        });
                }, true);

                // Watch model for changes
                scope.$watch(attr.ngModel, function(newValue, oldValue) {
                    // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue);
                    select.$updateActiveIndex();
                    controller.$render();
                }, true);

                // Model rendering in view
                controller.$render = function() {
                    // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);
                    var selected, index;
                    if (options.multiple && angular.isArray(controller.$modelValue)) {
                        selected = controller.$modelValue.map(function(value) {
                            index = select.$getIndex(value);
                            return angular.isDefined(index) ? select.$scope.$matches[index].label : false;
                        }).filter(angular.isDefined);
                        if (selected.length > (options.maxLength || defaults.maxLength)) {
                            selected = selected.length + ' ' + (options.maxLengthHtml || defaults.maxLengthHtml);
                        } else {
                            selected = selected.join(', ');
                        }
                    } else {
                        index = select.$getIndex(controller.$modelValue);
                        selected = angular.isDefined(index) ? select.$scope.$matches[index].label : false;
                    }
                    element.html((selected ? selected : options.placeholder) + defaults.caretHtml);
                };

                // Garbage collection
                scope.$on('$destroy', function() {
                    if (select) select.destroy();
                    options = null;
                    select = null;
                });

            }
        };

    }]);

    // Source: tab.js
    angular.module('mgcrea.ngStrap.tab', [])

    .provider('$tab', function() {

        var defaults = this.defaults = {
            animation: 'am-fade',
            template: 'tab/tab.tpl.html',
            navClass: 'nav-tabs',
            activeClass: 'active'
        };

        var controller = this.controller = function($scope, $element, $attrs) {
            var self = this;

            // Attributes options
            self.$options = angular.copy(defaults);
            angular.forEach(['animation', 'navClass', 'activeClass'], function(key) {
                if (angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];
            });

            // Publish options on scope
            $scope.$navClass = self.$options.navClass;
            $scope.$activeClass = self.$options.activeClass;

            self.$panes = $scope.$panes = [];

            self.$viewChangeListeners = [];

            self.$push = function(pane) {
                self.$panes.push(pane);
            };

            self.$panes.$active = 0;
            self.$setActive = $scope.$setActive = function(value) {
                self.$panes.$active = value;
                self.$viewChangeListeners.forEach(function(fn) {
                    fn();
                });
            };

        };

        this.$get = function() {
            var $tab = {};
            $tab.defaults = defaults;
            $tab.controller = controller;
            return $tab;
        };

    })

    .directive('bsTabs', ["$window", "$animate", "$tab", function($window, $animate, $tab) {

        var defaults = $tab.defaults;

        return {
            require: ['?ngModel', 'bsTabs'],
            transclude: true,
            scope: true,
            controller: ['$scope', '$element', '$attrs', $tab.controller],
            templateUrl: function(element, attr) {
                return attr.template || defaults.template;
            },
            link: function postLink(scope, element, attrs, controllers) {

                var ngModelCtrl = controllers[0];
                var bsTabsCtrl = controllers[1];

                if (ngModelCtrl) {

                    // Update the modelValue following
                    bsTabsCtrl.$viewChangeListeners.push(function() {
                        ngModelCtrl.$setViewValue(bsTabsCtrl.$panes.$active);
                    });

                    // modelValue -> $formatters -> viewValue
                    ngModelCtrl.$formatters.push(function(modelValue) {
                        // console.warn('$formatter("%s"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);
                        bsTabsCtrl.$setActive(modelValue * 1);
                        return modelValue;
                    });

                }

            }
        };

    }])

    .directive('bsPane', ["$window", "$animate", "$sce", function($window, $animate, $sce) {

        return {
            require: ['^?ngModel', '^bsTabs'],
            scope: true,
            link: function postLink(scope, element, attrs, controllers) {

                var ngModelCtrl = controllers[0];
                var bsTabsCtrl = controllers[1];

                // Add base class
                element.addClass('tab-pane');

                // Observe title attribute for change
                attrs.$observe('title', function(newValue, oldValue) {
                    scope.title = $sce.trustAsHtml(newValue);
                });

                // Add animation class
                if (bsTabsCtrl.$options.animation) {
                    element.addClass(bsTabsCtrl.$options.animation);
                }

                // Push pane to parent bsTabs controller
                bsTabsCtrl.$push(scope);

                function render() {
                    var index = bsTabsCtrl.$panes.indexOf(scope);
                    var active = bsTabsCtrl.$panes.$active;
                    $animate[index === active ? 'addClass' : 'removeClass'](element, bsTabsCtrl.$options.activeClass);
                }

                bsTabsCtrl.$viewChangeListeners.push(function() {
                    render();
                });
                render();

            }
        };

    }]);

    // Source: timepicker.js
    angular.module('mgcrea.ngStrap.timepicker', ['mgcrea.ngStrap.helpers.dateParser', 'mgcrea.ngStrap.tooltip'])

    .provider('$timepicker', function() {

        var defaults = this.defaults = {
            animation: 'am-fade',
            prefixClass: 'timepicker',
            placement: 'bottom-left',
            template: 'timepicker/timepicker.tpl.html',
            trigger: 'focus',
            container: false,
            keyboard: true,
            html: false,
            delay: 0,
            // lang: $locale.id,
            useNative: true,
            timeType: 'date',
            timeFormat: 'shortTime',
            modelTimeFormat: null,
            autoclose: false,
            minTime: -Infinity,
            maxTime: +Infinity,
            length: 5,
            hourStep: 1,
            minuteStep: 5,
            iconUp: 'glyphicon glyphicon-chevron-up',
            iconDown: 'glyphicon glyphicon-chevron-down',
            arrowBehavior: 'pager'
        };

        this.$get = ["$window", "$document", "$rootScope", "$sce", "$locale", "dateFilter", "$tooltip", function($window, $document, $rootScope, $sce, $locale, dateFilter, $tooltip) {

            var bodyEl = angular.element($window.document.body);
            var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);
            var isTouch = ('createTouch' in $window.document) && isNative;
            if (!defaults.lang) defaults.lang = $locale.id;

            function timepickerFactory(element, controller, config) {

                var $timepicker = $tooltip(element, angular.extend({}, defaults, config));
                var parentScope = config.scope;
                var options = $timepicker.$options;
                var scope = $timepicker.$scope;

                // View vars

                var selectedIndex = 0;
                var startDate = controller.$dateValue || new Date();
                var viewDate = {
                    hour: startDate.getHours(),
                    meridian: startDate.getHours() < 12,
                    minute: startDate.getMinutes(),
                    second: startDate.getSeconds(),
                    millisecond: startDate.getMilliseconds()
                };

                var format = $locale.DATETIME_FORMATS[options.timeFormat] || options.timeFormat;
                var formats = /(h+)([:\.])?(m+)[ ]?(a?)/i.exec(format).slice(1);
                scope.$iconUp = options.iconUp;
                scope.$iconDown = options.iconDown;

                // Scope methods

                scope.$select = function(date, index) {
                    $timepicker.select(date, index);
                };
                scope.$moveIndex = function(value, index) {
                    $timepicker.$moveIndex(value, index);
                };
                scope.$switchMeridian = function(date) {
                    $timepicker.switchMeridian(date);
                };

                // Public methods

                $timepicker.update = function(date) {
                    // console.warn('$timepicker.update() newValue=%o', date);
                    if (angular.isDate(date) && !isNaN(date.getTime())) {
                        $timepicker.$date = date;
                        angular.extend(viewDate, {
                            hour: date.getHours(),
                            minute: date.getMinutes(),
                            second: date.getSeconds(),
                            millisecond: date.getMilliseconds()
                        });
                        $timepicker.$build();
                    } else if (!$timepicker.$isBuilt) {
                        $timepicker.$build();
                    }
                };

                $timepicker.select = function(date, index, keep) {
                    // console.warn('$timepicker.select', date, scope.$mode);
                    if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) controller.$dateValue = new Date(1970, 0, 1);
                    if (!angular.isDate(date)) date = new Date(date);
                    if (index === 0) controller.$dateValue.setHours(date.getHours());
                    else if (index === 1) controller.$dateValue.setMinutes(date.getMinutes());
                    controller.$setViewValue(controller.$dateValue);
                    controller.$render();
                    if (options.autoclose && !keep) {
                        $timepicker.hide(true);
                    }
                };

                $timepicker.switchMeridian = function(date) {
                    if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {
                        return;
                    }
                    var hours = (date || controller.$dateValue).getHours();
                    controller.$dateValue.setHours(hours < 12 ? hours + 12 : hours - 12);
                    controller.$setViewValue(controller.$dateValue);
                    controller.$render();
                };

                // Protected methods

                $timepicker.$build = function() {
                    // console.warn('$timepicker.$build() viewDate=%o', viewDate);
                    var i, midIndex = scope.midIndex = parseInt(options.length / 2, 10);
                    var hours = [],
                        hour;
                    for (i = 0; i < options.length; i++) {
                        hour = new Date(1970, 0, 1, viewDate.hour - (midIndex - i) * options.hourStep);
                        hours.push({
                            date: hour,
                            label: dateFilter(hour, formats[0]),
                            selected: $timepicker.$date && $timepicker.$isSelected(hour, 0),
                            disabled: $timepicker.$isDisabled(hour, 0)
                        });
                    }
                    var minutes = [],
                        minute;
                    for (i = 0; i < options.length; i++) {
                        minute = new Date(1970, 0, 1, 0, viewDate.minute - (midIndex - i) * options.minuteStep);
                        minutes.push({
                            date: minute,
                            label: dateFilter(minute, formats[2]),
                            selected: $timepicker.$date && $timepicker.$isSelected(minute, 1),
                            disabled: $timepicker.$isDisabled(minute, 1)
                        });
                    }

                    var rows = [];
                    for (i = 0; i < options.length; i++) {
                        rows.push([hours[i], minutes[i]]);
                    }
                    scope.rows = rows;
                    scope.showAM = !!formats[3];
                    scope.isAM = ($timepicker.$date || hours[midIndex].date).getHours() < 12;
                    scope.timeSeparator = formats[1];
                    $timepicker.$isBuilt = true;
                };

                $timepicker.$isSelected = function(date, index) {
                    if (!$timepicker.$date) return false;
                    else if (index === 0) {
                        return date.getHours() === $timepicker.$date.getHours();
                    } else if (index === 1) {
                        return date.getMinutes() === $timepicker.$date.getMinutes();
                    }
                };

                $timepicker.$isDisabled = function(date, index) {
                    var selectedTime;
                    if (index === 0) {
                        selectedTime = date.getTime() + viewDate.minute * 6e4;
                    } else if (index === 1) {
                        selectedTime = date.getTime() + viewDate.hour * 36e5;
                    }
                    return selectedTime < options.minTime * 1 || selectedTime > options.maxTime * 1;
                };

                scope.$arrowAction = function(value, index) {
                    if (options.arrowBehavior === 'picker') {
                        $timepicker.$setTimeByStep(value, index);
                    } else {
                        $timepicker.$moveIndex(value, index);
                    }
                };

                $timepicker.$setTimeByStep = function(value, index) {
                    var newDate = new Date($timepicker.$date);
                    var hours = newDate.getHours(),
                        hoursLength = dateFilter(newDate, 'h').length;
                    var minutes = newDate.getMinutes(),
                        minutesLength = dateFilter(newDate, 'mm').length;
                    if (index === 0) {
                        newDate.setHours(hours - (parseInt(options.hourStep, 10) * value));
                    } else {
                        newDate.setMinutes(minutes - (parseInt(options.minuteStep, 10) * value));
                    }
                    $timepicker.select(newDate, index, true);
                    parentScope.$digest();
                };

                $timepicker.$moveIndex = function(value, index) {
                    var targetDate;
                    if (index === 0) {
                        targetDate = new Date(1970, 0, 1, viewDate.hour + (value * options.length), viewDate.minute);
                        angular.extend(viewDate, {
                            hour: targetDate.getHours()
                        });
                    } else if (index === 1) {
                        targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute + (value * options.length * options.minuteStep));
                        angular.extend(viewDate, {
                            minute: targetDate.getMinutes()
                        });
                    }
                    $timepicker.$build();
                };

                $timepicker.$onMouseDown = function(evt) {
                    // Prevent blur on mousedown on .dropdown-menu
                    if (evt.target.nodeName.toLowerCase() !== 'input') evt.preventDefault();
                    evt.stopPropagation();
                    // Emulate click for mobile devices
                    if (isTouch) {
                        var targetEl = angular.element(evt.target);
                        if (targetEl[0].nodeName.toLowerCase() !== 'button') {
                            targetEl = targetEl.parent();
                        }
                        targetEl.triggerHandler('click');
                    }
                };

                $timepicker.$onKeyDown = function(evt) {
                    if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;
                    evt.preventDefault();
                    evt.stopPropagation();

                    // Close on enter
                    if (evt.keyCode === 13) return $timepicker.hide(true);

                    // Navigate with keyboard
                    var newDate = new Date($timepicker.$date);
                    var hours = newDate.getHours(),
                        hoursLength = dateFilter(newDate, 'h').length;
                    var minutes = newDate.getMinutes(),
                        minutesLength = dateFilter(newDate, 'mm').length;
                    var lateralMove = /(37|39)/.test(evt.keyCode);
                    var count = 2 + !!formats[3] * 1;

                    // Navigate indexes (left, right)
                    if (lateralMove) {
                        if (evt.keyCode === 37) selectedIndex = selectedIndex < 1 ? count - 1 : selectedIndex - 1;
                        else if (evt.keyCode === 39) selectedIndex = selectedIndex < count - 1 ? selectedIndex + 1 : 0;
                    }

                    // Update values (up, down)
                    var selectRange = [0, hoursLength];
                    if (selectedIndex === 0) {
                        if (evt.keyCode === 38) newDate.setHours(hours - parseInt(options.hourStep, 10));
                        else if (evt.keyCode === 40) newDate.setHours(hours + parseInt(options.hourStep, 10));
                        selectRange = [0, hoursLength];
                    } else if (selectedIndex === 1) {
                        if (evt.keyCode === 38) newDate.setMinutes(minutes - parseInt(options.minuteStep, 10));
                        else if (evt.keyCode === 40) newDate.setMinutes(minutes + parseInt(options.minuteStep, 10));
                        selectRange = [hoursLength + 1, hoursLength + 1 + minutesLength];
                    } else if (selectedIndex === 2) {
                        if (!lateralMove) $timepicker.switchMeridian();
                        selectRange = [hoursLength + 1 + minutesLength + 1, hoursLength + 1 + minutesLength + 3];
                    }
                    $timepicker.select(newDate, selectedIndex, true);
                    createSelection(selectRange[0], selectRange[1]);
                    parentScope.$digest();
                };

                // Private

                function createSelection(start, end) {
                    if (element[0].createTextRange) {
                        var selRange = element[0].createTextRange();
                        selRange.collapse(true);
                        selRange.moveStart('character', start);
                        selRange.moveEnd('character', end);
                        selRange.select();
                    } else if (element[0].setSelectionRange) {
                        element[0].setSelectionRange(start, end);
                    } else if (angular.isUndefined(element[0].selectionStart)) {
                        element[0].selectionStart = start;
                        element[0].selectionEnd = end;
                    }
                }

                function focusElement() {
                    element[0].focus();
                }

                // Overrides

                var _init = $timepicker.init;
                $timepicker.init = function() {
                    if (isNative && options.useNative) {
                        element.prop('type', 'time');
                        element.css('-webkit-appearance', 'textfield');
                        return;
                    } else if (isTouch) {
                        element.prop('type', 'text');
                        element.attr('readonly', 'true');
                        element.on('click', focusElement);
                    }
                    _init();
                };

                var _destroy = $timepicker.destroy;
                $timepicker.destroy = function() {
                    if (isNative && options.useNative) {
                        element.off('click', focusElement);
                    }
                    _destroy();
                };

                var _show = $timepicker.show;
                $timepicker.show = function() {
                    _show();
                    setTimeout(function() {
                        $timepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);
                        if (options.keyboard) {
                            element.on('keydown', $timepicker.$onKeyDown);
                        }
                    });
                };

                var _hide = $timepicker.hide;
                $timepicker.hide = function(blur) {
                    $timepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);
                    if (options.keyboard) {
                        element.off('keydown', $timepicker.$onKeyDown);
                    }
                    _hide(blur);
                };

                return $timepicker;

            }

            timepickerFactory.defaults = defaults;
            return timepickerFactory;

        }];

    })


    .directive('bsTimepicker', ["$window", "$parse", "$q", "$locale", "dateFilter", "$timepicker", "$dateParser", "$timeout", function($window, $parse, $q, $locale, dateFilter, $timepicker, $dateParser, $timeout) {

        var defaults = $timepicker.defaults;
        var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);
        var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;

        return {
            restrict: 'EAC',
            require: 'ngModel',
            link: function postLink(scope, element, attr, controller) {

                // Directive options
                var options = {
                    scope: scope,
                    controller: controller
                };
                angular.forEach(['placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'template', 'autoclose', 'timeType', 'timeFormat', 'modelTimeFormat', 'useNative', 'hourStep', 'minuteStep', 'length', 'arrowBehavior', 'iconUp', 'iconDown'], function(key) {
                    if (angular.isDefined(attr[key])) options[key] = attr[key];
                });

                // Visibility binding support
                attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {
                    if (!timepicker || !angular.isDefined(newValue)) return;
                    if (angular.isString(newValue)) newValue = !!newValue.match(',?(timepicker),?');
                    newValue === true ? timepicker.show() : timepicker.hide();
                });

                // Initialize timepicker
                if (isNative && (options.useNative || defaults.useNative)) options.timeFormat = 'HH:mm';
                var timepicker = $timepicker(element, controller, options);
                options = timepicker.$options;

                // Initialize parser
                var dateParser = $dateParser({
                    format: options.timeFormat,
                    lang: options.lang
                });

                // Observe attributes for changes
                angular.forEach(['minTime', 'maxTime'], function(key) {
                    // console.warn('attr.$observe(%s)', key, attr[key]);
                    angular.isDefined(attr[key]) && attr.$observe(key, function(newValue) {
                        if (newValue === 'now') {
                            timepicker.$options[key] = new Date().setFullYear(1970, 0, 1);
                        } else if (angular.isString(newValue) && newValue.match(/^".+"$/)) {
                            timepicker.$options[key] = +new Date(newValue.substr(1, newValue.length - 2));
                        } else {
                            timepicker.$options[key] = +dateParser.parse(newValue, new Date(1970, 0, 1, 0));
                        }!isNaN(timepicker.$options[key]) && timepicker.$build();
                    });
                });

                // Watch model for changes
                scope.$watch(attr.ngModel, function(newValue, oldValue) {
                    // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue, controller.$dateValue);
                    timepicker.update(controller.$dateValue);
                }, true);

                // viewValue -> $parsers -> modelValue
                controller.$parsers.unshift(function(viewValue) {
                    // console.warn('$parser("%s"): viewValue=%o', element.attr('ng-model'), viewValue);
                    // Null values should correctly reset the model value & validity
                    if (!viewValue) {
                        controller.$setValidity('date', true);
                        return;
                    }
                    var parsedTime = angular.isDate(viewValue) ? viewValue : dateParser.parse(viewValue, controller.$dateValue);
                    if (!parsedTime || isNaN(parsedTime.getTime())) {
                        controller.$setValidity('date', false);
                        return;
                    } else {
                        var isMinValid = isNaN(options.minTime) || parsedTime.getTime() >= options.minTime;
                        var isMaxValid = isNaN(options.maxTime) || parsedTime.getTime() <= options.maxTime;
                        var isValid = isMinValid && isMaxValid;
                        controller.$setValidity('date', isValid);
                        controller.$setValidity('min', isMinValid);
                        controller.$setValidity('max', isMaxValid);
                        // Only update the model when we have a valid date
                        if (!isValid) {
                            return;
                        }
                        controller.$dateValue = parsedTime;
                    }
                    if (options.timeType === 'string') {
                        return dateFilter(parsedTime, options.modelTimeFormat || options.timeFormat);
                    } else if (options.timeType === 'number') {
                        return controller.$dateValue.getTime();
                    } else if (options.timeType === 'iso') {
                        return controller.$dateValue.toISOString();
                    } else {
                        return new Date(controller.$dateValue);
                    }
                });

                // modelValue -> $formatters -> viewValue
                controller.$formatters.push(function(modelValue) {
                    // console.warn('$formatter("%s"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);
                    var date;
                    if (angular.isUndefined(modelValue) || modelValue === null) {
                        date = NaN;
                    } else if (angular.isDate(modelValue)) {
                        date = modelValue;
                    } else if (options.timeType === 'string') {
                        date = dateParser.parse(modelValue, null, options.modelTimeFormat);
                    } else {
                        date = new Date(modelValue);
                    }
                    // Setup default value?
                    // if(isNaN(date.getTime())) date = new Date(new Date().setMinutes(0) + 36e5);
                    controller.$dateValue = date;
                    return controller.$dateValue;
                });

                // viewValue -> element
                controller.$render = function() {
                    // console.warn('$render("%s"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);
                    element.val(!controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : dateFilter(controller.$dateValue, options.timeFormat));
                };

                // Garbage collection
                scope.$on('$destroy', function() {
                    if (timepicker) timepicker.destroy();
                    options = null;
                    timepicker = null;
                });

            }
        };

    }]);

    // Source: tooltip.js
    angular.module('mgcrea.ngStrap.tooltip', ['mgcrea.ngStrap.helpers.dimensions'])

    .provider('$tooltip', function() {

        var defaults = this.defaults = {
            animation: 'am-fade',
            customClass: '',
            prefixClass: 'tooltip',
            prefixEvent: 'tooltip',
            container: false,
            target: false,
            placement: 'top',
            template: 'tooltip/tooltip.tpl.html',
            contentTemplate: false,
            trigger: 'hover focus',
            keyboard: false,
            html: false,
            show: false,
            title: '',
            type: '',
            delay: 0
        };

        this.$get = ["$window", "$rootScope", "$compile", "$q", "$templateCache", "$http", "$animate", "dimensions", "$$rAF", function($window, $rootScope, $compile, $q, $templateCache, $http, $animate, dimensions, $$rAF) {

            var trim = String.prototype.trim;
            var isTouch = 'createTouch' in $window.document;
            var htmlReplaceRegExp = /ng-bind="/ig;

            function TooltipFactory(element, config) {

                var $tooltip = {};

                // Common vars
                var nodeName = element[0].nodeName.toLowerCase();
                var options = $tooltip.$options = angular.extend({}, defaults, config);
                $tooltip.$promise = fetchTemplate(options.template);
                var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();
                if (options.delay && angular.isString(options.delay)) {
                    var split = options.delay.split(',').map(parseFloat);
                    options.delay = split.length > 1 ? {
                        show: split[0],
                        hide: split[1]
                    } : split[0];
                }

                // Support scope as string options
                if (options.title) {
                    $tooltip.$scope.title = options.title;
                }

                // Provide scope helpers
                scope.$hide = function() {
                    scope.$$postDigest(function() {
                        $tooltip.hide();
                    });
                };
                scope.$show = function() {
                    scope.$$postDigest(function() {
                        $tooltip.show();
                    });
                };
                scope.$toggle = function() {
                    scope.$$postDigest(function() {
                        $tooltip.toggle();
                    });
                };
                $tooltip.$isShown = scope.$isShown = false;

                // Private vars
                var timeout, hoverState;

                // Support contentTemplate option
                if (options.contentTemplate) {
                    $tooltip.$promise = $tooltip.$promise.then(function(template) {
                        var templateEl = angular.element(template);
                        return fetchTemplate(options.contentTemplate)
                            .then(function(contentTemplate) {
                                var contentEl = findElement('[ng-bind="content"]', templateEl[0]);
                                if (!contentEl.length) contentEl = findElement('[ng-bind="title"]', templateEl[0]);
                                contentEl.removeAttr('ng-bind').html(contentTemplate);
                                return templateEl[0].outerHTML;
                            });
                    });
                }

                // Fetch, compile then initialize tooltip
                var tipLinker, tipElement, tipTemplate, tipContainer;
                $tooltip.$promise.then(function(template) {
                    if (angular.isObject(template)) template = template.data;
                    if (options.html) template = template.replace(htmlReplaceRegExp, 'ng-bind-html="');
                    template = trim.apply(template);
                    tipTemplate = template;
                    tipLinker = $compile(template);
                    $tooltip.init();
                });

                $tooltip.init = function() {

                    // Options: delay
                    if (options.delay && angular.isNumber(options.delay)) {
                        options.delay = {
                            show: options.delay,
                            hide: options.delay
                        };
                    }

                    // Replace trigger on touch devices ?
                    // if(isTouch && options.trigger === defaults.trigger) {
                    //   options.trigger.replace(/hover/g, 'click');
                    // }

                    // Options : container
                    if (options.container === 'self') {
                        tipContainer = element;
                    } else if (angular.isElement(options.container)) {
                        tipContainer = options.container;
                    } else if (options.container) {
                        tipContainer = findElement(options.container);
                    }

                    // Options: trigger
                    var triggers = options.trigger.split(' ');
                    angular.forEach(triggers, function(trigger) {
                        if (trigger === 'click') {
                            element.on('click', $tooltip.toggle);
                        } else if (trigger !== 'manual') {
                            element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);
                            element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);
                            nodeName === 'button' && trigger !== 'hover' && element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);
                        }
                    });

                    // Options: target
                    if (options.target) {
                        options.target = angular.isElement(options.target) ? options.target : findElement(options.target);
                    }

                    // Options: show
                    if (options.show) {
                        scope.$$postDigest(function() {
                            options.trigger === 'focus' ? element[0].focus() : $tooltip.show();
                        });
                    }

                };

                $tooltip.destroy = function() {

                    // Unbind events
                    var triggers = options.trigger.split(' ');
                    for (var i = triggers.length; i--;) {
                        var trigger = triggers[i];
                        if (trigger === 'click') {
                            element.off('click', $tooltip.toggle);
                        } else if (trigger !== 'manual') {
                            element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);
                            element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);
                            nodeName === 'button' && trigger !== 'hover' && element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);
                        }
                    }

                    // Remove element
                    if (tipElement) {
                        tipElement.remove();
                        tipElement = null;
                    }

                    // Cancel pending callbacks
                    clearTimeout(timeout);

                    // Destroy scope
                    scope.$destroy();

                };

                $tooltip.enter = function() {

                    clearTimeout(timeout);
                    hoverState = 'in';
                    if (!options.delay || !options.delay.show) {
                        return $tooltip.show();
                    }

                    timeout = setTimeout(function() {
                        if (hoverState === 'in') $tooltip.show();
                    }, options.delay.show);

                };

                $tooltip.show = function() {

                    scope.$emit(options.prefixEvent + '.show.before', $tooltip);
                    var parent = options.container ? tipContainer : null;
                    var after = options.container ? null : element;

                    // Hide any existing tipElement
                    if (tipElement) tipElement.remove();
                    // Fetch a cloned element linked from template
                    tipElement = $tooltip.$element = tipLinker(scope, function(clonedElement, scope) {});

                    // Set the initial positioning.  Make the tooltip invisible
                    // so IE doesn't try to focus on it off screen.
                    tipElement.css({
                        top: '-9999px',
                        left: '-9999px',
                        display: 'block',
                        visibility: 'hidden'
                    }).addClass(options.placement);

                    // Options: animation
                    if (options.animation) tipElement.addClass(options.animation);
                    // Options: type
                    if (options.type) tipElement.addClass(options.prefixClass + '-' + options.type);
                    // Options: custom classes
                    if (options.customClass) tipElement.addClass(options.customClass);

                    // Support v1.3+ $animate
                    // https://github.com/angular/angular.js/commit/bf0f5502b1bbfddc5cdd2f138efd9188b8c652a9
                    var promise = $animate.enter(tipElement, parent, after, enterAnimateCallback);
                    if (promise && promise.then) promise.then(enterAnimateCallback);

                    $tooltip.$isShown = scope.$isShown = true;
                    scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();
                    $$rAF(function() {
                        $tooltip.$applyPlacement();

                        // Once placed, make the tooltip visible
                        tipElement.css({
                            visibility: 'visible'
                        });
                    }); // var a = bodyEl.offsetWidth + 1; ?

                    // Bind events
                    if (options.keyboard) {
                        if (options.trigger !== 'focus') {
                            $tooltip.focus();
                            tipElement.on('keyup', $tooltip.$onKeyUp);
                        } else {
                            element.on('keyup', $tooltip.$onFocusKeyUp);
                        }
                    }

                };

                function enterAnimateCallback() {
                    scope.$emit(options.prefixEvent + '.show', $tooltip);
                }

                $tooltip.leave = function() {

                    clearTimeout(timeout);
                    hoverState = 'out';
                    if (!options.delay || !options.delay.hide) {
                        return $tooltip.hide();
                    }
                    timeout = setTimeout(function() {
                        if (hoverState === 'out') {
                            $tooltip.hide();
                        }
                    }, options.delay.hide);

                };

                $tooltip.hide = function(blur) {

                    if (!$tooltip.$isShown) return;
                    scope.$emit(options.prefixEvent + '.hide.before', $tooltip);

                    // Support v1.3+ $animate
                    // https://github.com/angular/angular.js/commit/bf0f5502b1bbfddc5cdd2f138efd9188b8c652a9
                    var promise = $animate.leave(tipElement, leaveAnimateCallback);
                    if (promise && promise.then) promise.then(leaveAnimateCallback);

                    $tooltip.$isShown = scope.$isShown = false;
                    scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();

                    // Unbind events
                    if (options.keyboard && tipElement !== null) {
                        tipElement.off('keyup', $tooltip.$onKeyUp);
                    }

                };

                function leaveAnimateCallback() {
                    scope.$emit(options.prefixEvent + '.hide', $tooltip);
                    // Allow to blur the input when hidden, like when pressing enter key
                    if (blur && options.trigger === 'focus') {
                        return element[0].blur();
                    }
                }

                $tooltip.toggle = function() {
                    $tooltip.$isShown ? $tooltip.leave() : $tooltip.enter();
                };

                $tooltip.focus = function() {
                    tipElement[0].focus();
                };

                // Protected methods

                $tooltip.$applyPlacement = function() {
                    if (!tipElement) return;

                    // Get the position of the tooltip element.
                    var elementPosition = getPosition();

                    // Get the height and width of the tooltip so we can center it.
                    var tipWidth = tipElement.prop('offsetWidth'),
                        tipHeight = tipElement.prop('offsetHeight');

                    // Get the tooltip's top and left coordinates to center it with this directive.
                    var tipPosition = getCalculatedOffset(options.placement, elementPosition, tipWidth, tipHeight);

                    // Now set the calculated positioning.
                    tipPosition.top += 'px';
                    tipPosition.left += 'px';
                    tipElement.css(tipPosition);

                };

                $tooltip.$onKeyUp = function(evt) {
                    if (evt.which === 27 && $tooltip.$isShown) {
                        $tooltip.hide();
                        evt.stopPropagation();
                    }
                };

                $tooltip.$onFocusKeyUp = function(evt) {
                    if (evt.which === 27) {
                        element[0].blur();
                        evt.stopPropagation();
                    }
                };

                $tooltip.$onFocusElementMouseDown = function(evt) {
                    evt.preventDefault();
                    evt.stopPropagation();
                    // Some browsers do not auto-focus buttons (eg. Safari)
                    $tooltip.$isShown ? element[0].blur() : element[0].focus();
                };

                // Private methods

                function getPosition() {
                    if (options.container === 'body') {
                        return dimensions.offset(options.target[0] || element[0]);
                    } else {
                        return dimensions.position(options.target[0] || element[0]);
                    }
                }

                function getCalculatedOffset(placement, position, actualWidth, actualHeight) {
                    var offset;
                    var split = placement.split('-');

                    switch (split[0]) {
                        case 'right':
                            offset = {
                                top: position.top + position.height / 2 - actualHeight / 2,
                                left: position.left + position.width
                            };
                            break;
                        case 'bottom':
                            offset = {
                                top: position.top + position.height,
                                left: position.left + position.width / 2 - actualWidth / 2
                            };
                            break;
                        case 'left':
                            offset = {
                                top: position.top + position.height / 2 - actualHeight / 2,
                                left: position.left - actualWidth
                            };
                            break;
                        default:
                            offset = {
                                top: position.top - actualHeight,
                                left: position.left + position.width / 2 - actualWidth / 2
                            };
                            break;
                    }

                    if (!split[1]) {
                        return offset;
                    }

                    // Add support for corners @todo css
                    if (split[0] === 'top' || split[0] === 'bottom') {
                        switch (split[1]) {
                            case 'left':
                                offset.left = position.left;
                                break;
                            case 'right':
                                offset.left = position.left + position.width - actualWidth;
                        }
                    } else if (split[0] === 'left' || split[0] === 'right') {
                        switch (split[1]) {
                            case 'top':
                                offset.top = position.top - actualHeight;
                                break;
                            case 'bottom':
                                offset.top = position.top + position.height;
                        }
                    }

                    return offset;
                }

                return $tooltip;

            }

            // Helper functions

            function findElement(query, element) {
                return angular.element((element || document).querySelectorAll(query));
            }

            function fetchTemplate(template) {
                return $q.when($templateCache.get(template) || $http.get(template))
                    .then(function(res) {
                        if (angular.isObject(res)) {
                            $templateCache.put(template, res.data);
                            return res.data;
                        }
                        return res;
                    });
            }

            return TooltipFactory;

        }];

    })

    .directive('bsTooltip', ["$window", "$location", "$sce", "$tooltip", "$$rAF", function($window, $location, $sce, $tooltip, $$rAF) {

        return {
            restrict: 'EAC',
            scope: true,
            link: function postLink(scope, element, attr, transclusion) {

                // Directive options
                var options = {
                    scope: scope
                };
                angular.forEach(['template', 'contentTemplate', 'placement', 'container', 'target', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'type', 'customClass'], function(key) {
                    if (angular.isDefined(attr[key])) options[key] = attr[key];
                });

                // Observe scope attributes for change
                attr.$observe('title', function(newValue, oldValue) {
                    scope.title = $sce.trustAsHtml(newValue);
                    angular.isDefined(oldValue) && $$rAF(function() {
                        tooltip && tooltip.$applyPlacement();
                    });
                });

                // Support scope as an object
                attr.bsTooltip && scope.$watch(attr.bsTooltip, function(newValue, oldValue) {
                    if (angular.isObject(newValue)) {
                        angular.extend(scope, newValue);
                    } else {
                        scope.title = newValue;
                    }
                    angular.isDefined(oldValue) && $$rAF(function() {
                        tooltip && tooltip.$applyPlacement();
                    });
                }, true);

                // Visibility binding support
                attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {
                    if (!tooltip || !angular.isDefined(newValue)) return;
                    if (angular.isString(newValue)) newValue = !!newValue.match(',?(tooltip),?');
                    newValue === true ? tooltip.show() : tooltip.hide();
                });

                // Initialize popover
                var tooltip = $tooltip(element, options);

                // Garbage collection
                scope.$on('$destroy', function() {
                    if (tooltip) tooltip.destroy();
                    options = null;
                    tooltip = null;
                });

            }
        };

    }]);

    // Source: typeahead.js
    angular.module('mgcrea.ngStrap.typeahead', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])

    .provider('$typeahead', function() {

        var defaults = this.defaults = {
            animation: 'am-fade',
            prefixClass: 'typeahead',
            prefixEvent: '$typeahead',
            placement: 'bottom-left',
            template: 'typeahead/typeahead.tpl.html',
            trigger: 'focus',
            container: false,
            keyboard: true,
            html: false,
            delay: 0,
            minLength: 1,
            filter: 'filter',
            limit: 6
        };

        this.$get = ["$window", "$rootScope", "$tooltip", function($window, $rootScope, $tooltip) {

            var bodyEl = angular.element($window.document.body);

            function TypeaheadFactory(element, controller, config) {

                var $typeahead = {};

                // Common vars
                var options = angular.extend({}, defaults, config);

                $typeahead = $tooltip(element, options);
                var parentScope = config.scope;
                var scope = $typeahead.$scope;

                scope.$resetMatches = function() {
                    scope.$matches = [];
                    scope.$activeIndex = 0;
                };
                scope.$resetMatches();

                scope.$activate = function(index) {
                    scope.$$postDigest(function() {
                        $typeahead.activate(index);
                    });
                };

                scope.$select = function(index, evt) {
                    scope.$$postDigest(function() {
                        $typeahead.select(index);
                    });
                };

                scope.$isVisible = function() {
                    return $typeahead.$isVisible();
                };

                // Public methods

                $typeahead.update = function(matches) {
                    scope.$matches = matches;
                    if (scope.$activeIndex >= matches.length) {
                        scope.$activeIndex = 0;
                    }
                };

                $typeahead.activate = function(index) {
                    scope.$activeIndex = index;
                };

                $typeahead.select = function(index) {
                    var value = scope.$matches[index].value;
                    controller.$setViewValue(value);
                    controller.$render();
                    scope.$resetMatches();
                    if (parentScope) parentScope.$digest();
                    // Emit event
                    scope.$emit(options.prefixEvent + '.select', value, index);
                };

                // Protected methods

                $typeahead.$isVisible = function() {
                    if (!options.minLength || !controller) {
                        return !!scope.$matches.length;
                    }
                    // minLength support
                    return scope.$matches.length && angular.isString(controller.$viewValue) && controller.$viewValue.length >= options.minLength;
                };

                $typeahead.$getIndex = function(value) {
                    var l = scope.$matches.length,
                        i = l;
                    if (!l) return;
                    for (i = l; i--;) {
                        if (scope.$matches[i].value === value) break;
                    }
                    if (i < 0) return;
                    return i;
                };

                $typeahead.$onMouseDown = function(evt) {
                    // Prevent blur on mousedown
                    evt.preventDefault();
                    evt.stopPropagation();
                };

                $typeahead.$onKeyDown = function(evt) {
                    if (!/(38|40|13)/.test(evt.keyCode)) return;

                    // Let ngSubmit pass if the typeahead tip is hidden
                    if ($typeahead.$isVisible()) {
                        evt.preventDefault();
                        evt.stopPropagation();
                    }

                    // Select with enter
                    if (evt.keyCode === 13 && scope.$matches.length) {
                        $typeahead.select(scope.$activeIndex);
                    }

                    // Navigate with keyboard
                    else if (evt.keyCode === 38 && scope.$activeIndex > 0) scope.$activeIndex--;
                    else if (evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) scope.$activeIndex++;
                    else if (angular.isUndefined(scope.$activeIndex)) scope.$activeIndex = 0;
                    scope.$digest();
                };

                // Overrides

                var show = $typeahead.show;
                $typeahead.show = function() {
                    show();
                    setTimeout(function() {
                        $typeahead.$element.on('mousedown', $typeahead.$onMouseDown);
                        if (options.keyboard) {
                            element.on('keydown', $typeahead.$onKeyDown);
                        }
                    });
                };

                var hide = $typeahead.hide;
                $typeahead.hide = function() {
                    $typeahead.$element.off('mousedown', $typeahead.$onMouseDown);
                    if (options.keyboard) {
                        element.off('keydown', $typeahead.$onKeyDown);
                    }
                    hide();
                };

                return $typeahead;

            }

            TypeaheadFactory.defaults = defaults;
            return TypeaheadFactory;

        }];

    })

    .directive('bsTypeahead', ["$window", "$parse", "$q", "$typeahead", "$parseOptions", function($window, $parse, $q, $typeahead, $parseOptions) {

        var defaults = $typeahead.defaults;

        return {
            restrict: 'EAC',
            require: 'ngModel',
            link: function postLink(scope, element, attr, controller) {

                // Directive options
                var options = {
                    scope: scope
                };
                angular.forEach(['placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'template', 'filter', 'limit', 'minLength', 'watchOptions', 'selectMode'], function(key) {
                    if (angular.isDefined(attr[key])) options[key] = attr[key];
                });

                // Build proper ngOptions
                var filter = options.filter || defaults.filter;
                var limit = options.limit || defaults.limit;
                var ngOptions = attr.ngOptions;
                if (filter) ngOptions += ' | ' + filter + ':$viewValue';
                if (limit) ngOptions += ' | limitTo:' + limit;
                var parsedOptions = $parseOptions(ngOptions);

                // Initialize typeahead
                var typeahead = $typeahead(element, controller, options);

                // Watch options on demand
                if (options.watchOptions) {
                    // Watch ngOptions values before filtering for changes, drop function calls
                    var watchedOptions = parsedOptions.$match[7].replace(/\|.+/, '').replace(/\(.*\)/g, '').trim();
                    scope.$watch(watchedOptions, function(newValue, oldValue) {
                        // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);
                        parsedOptions.valuesFn(scope, controller).then(function(values) {
                            typeahead.update(values);
                            controller.$render();
                        });
                    }, true);
                }

                // Watch model for changes
                scope.$watch(attr.ngModel, function(newValue, oldValue) {
                    // console.warn('$watch', element.attr('ng-model'), newValue);
                    scope.$modelValue = newValue; // Publish modelValue on scope for custom templates
                    parsedOptions.valuesFn(scope, controller)
                        .then(function(values) {
                            // Prevent input with no future prospect if selectMode is truthy
                            // @TODO test selectMode
                            if (options.selectMode && !values.length && newValue.length > 0) {
                                controller.$setViewValue(controller.$viewValue.substring(0, controller.$viewValue.length - 1));
                                return;
                            }
                            if (values.length > limit) values = values.slice(0, limit);
                            var isVisible = typeahead.$isVisible();
                            isVisible && typeahead.update(values);
                            // Do not re-queue an update if a correct value has been selected
                            if (values.length === 1 && values[0].value === newValue) return;
                            !isVisible && typeahead.update(values);
                            // Queue a new rendering that will leverage collection loading
                            controller.$render();
                        });
                });

                // Model rendering in view
                controller.$render = function() {
                    // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);
                    if (controller.$isEmpty(controller.$viewValue)) return element.val('');
                    var index = typeahead.$getIndex(controller.$modelValue);
                    var selected = angular.isDefined(index) ? typeahead.$scope.$matches[index].label : controller.$viewValue;
                    selected = angular.isObject(selected) ? selected.label : selected;
                    element.val(selected ? selected.replace(/<(?:.|\n)*?>/gm, '').trim() : '');
                };

                // Garbage collection
                scope.$on('$destroy', function() {
                    if (typeahead) typeahead.destroy();
                    options = null;
                    typeahead = null;
                });

            }
        };

    }]);

})(window, document);


/**
 * angular-strap
 * @version v2.1.1 - 2014-09-26
 * @link http://mgcrea.github.io/angular-strap
 * @author Olivier Louvignes (olivier@mg-crea.com)
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */
(function(window, document, undefined) {
    'use strict';

    // Source: datepicker.tpl.js
    angular.module('mgcrea.ngStrap.datepicker').run(['$templateCache', function($templateCache) {

        $templateCache.put('datepicker/datepicker.tpl.html', '<div class="dropdown-menu datepicker" ng-class="\'datepicker-mode-\' + $mode" style="max-width: 320px"><table style="table-layout: fixed; height: 100%; width: 100%"><thead><tr class="text-center"><th><button tabindex="-1" type="button" class="btn btn-default pull-left" ng-click="$selectPane(-1)"><i class="{{$iconLeft}}"></i></button></th><th colspan="{{ rows[0].length - 2 }}"><button tabindex="-1" type="button" class="btn btn-default btn-block text-strong" ng-click="$toggleMode()"><strong style="text-transform: capitalize" ng-bind="title"></strong></button></th><th><button tabindex="-1" type="button" class="btn btn-default pull-right" ng-click="$selectPane(+1)"><i class="{{$iconRight}}"></i></button></th></tr><tr ng-show="showLabels" ng-bind-html="labels"></tr></thead><tbody><tr ng-repeat="(i, row) in rows" height="{{ 100 / rows.length }}%"><td class="text-center" ng-repeat="(j, el) in row"><button tabindex="-1" type="button" class="btn btn-default" style="width: 100%" ng-class="{\'btn-primary\': el.selected, \'btn-info btn-today\': el.isToday && !el.selected}" ng-click="$select(el.date)" ng-disabled="el.disabled"><span ng-class="{\'text-muted\': el.muted}" ng-bind="el.label"></span></button></td></tr></tbody></table></div>');

    }]);

    // Source: dropdown.tpl.js
    angular.module('mgcrea.ngStrap.dropdown').run(['$templateCache', function($templateCache) {

        $templateCache.put('dropdown/dropdown.tpl.html', '<ul tabindex="-1" class="dropdown-menu" role="menu"><li role="presentation" ng-class="{divider: item.divider}" ng-repeat="item in content"><a role="menuitem" tabindex="-1" ng-href="{{item.href}}" ng-if="!item.divider && item.href" target="{{item.target || \'\'}}" ng-bind="item.text"></a> <a role="menuitem" tabindex="-1" href="javascript:void(0)" ng-if="!item.divider && item.click" ng-click="$eval(item.click);$hide()" ng-bind="item.text"></a></li></ul>');

    }]);

    // Source: popover.tpl.js
    angular.module('mgcrea.ngStrap.popover').run(['$templateCache', function($templateCache) {

        $templateCache.put('popover/popover.tpl.html', '<div class="popover"><div class="arrow"></div><h3 class="popover-title" ng-bind="title" ng-show="title"></h3><div class="popover-content" ng-bind="content"></div></div>');

    }]);

    // Source: select.tpl.js
    angular.module('mgcrea.ngStrap.select').run(['$templateCache', function($templateCache) {

        $templateCache.put('select/select.tpl.html', '<ul tabindex="-1" class="select dropdown-menu" ng-show="$isVisible()" role="select"><li ng-if="$showAllNoneButtons"><div class="btn-group" style="margin-bottom: 5px; margin-left: 5px"><button class="btn btn-default btn-xs" ng-click="$selectAll()">All</button> <button class="btn btn-default btn-xs" ng-click="$selectNone()">None</button></div></li><li role="presentation" ng-repeat="match in $matches" ng-class="{active: $isActive($index)}"><a style="cursor: default" role="menuitem" tabindex="-1" ng-click="$select($index, $event)"><span ng-bind="match.label"></span> <i class="{{$iconCheckmark}} pull-right" ng-if="$isMultiple && $isActive($index)"></i></a></li></ul>');

    }]);

    // Source: tab.tpl.js
    angular.module('mgcrea.ngStrap.tab').run(['$templateCache', function($templateCache) {

        $templateCache.put('tab/tab.tpl.html', '<ul class="nav" ng-class="$navClass" role="tablist"><li ng-repeat="$pane in $panes" ng-class="$index == $panes.$active ? $activeClass : \'\'"><a role="tab" data-toggle="tab" ng-click="$setActive($index)" data-index="{{ $index }}" ng-bind-html="$pane.title"></a></li></ul><div ng-transclude class="tab-content"></div>');

    }]);

    // Source: timepicker.tpl.js
    angular.module('mgcrea.ngStrap.timepicker').run(['$templateCache', function($templateCache) {

        $templateCache.put('timepicker/timepicker.tpl.html', '<div class="dropdown-menu timepicker" style="min-width: 0px;width: auto"><table height="100%"><thead><tr class="text-center"><th><button tabindex="-1" type="button" class="btn btn-default pull-left" ng-click="$arrowAction(-1, 0)"><i class="{{ $iconUp }}"></i></button></th><th>&nbsp;</th><th><button tabindex="-1" type="button" class="btn btn-default pull-left" ng-click="$arrowAction(-1, 1)"><i class="{{ $iconUp }}"></i></button></th></tr></thead><tbody><tr ng-repeat="(i, row) in rows"><td class="text-center"><button tabindex="-1" style="width: 100%" type="button" class="btn btn-default" ng-class="{\'btn-primary\': row[0].selected}" ng-click="$select(row[0].date, 0)" ng-disabled="row[0].disabled"><span ng-class="{\'text-muted\': row[0].muted}" ng-bind="row[0].label"></span></button></td><td><span ng-bind="i == midIndex ? timeSeparator : \' \'"></span></td><td class="text-center"><button tabindex="-1" ng-if="row[1].date" style="width: 100%" type="button" class="btn btn-default" ng-class="{\'btn-primary\': row[1].selected}" ng-click="$select(row[1].date, 1)" ng-disabled="row[1].disabled"><span ng-class="{\'text-muted\': row[1].muted}" ng-bind="row[1].label"></span></button></td><td ng-if="showAM">&nbsp;</td><td ng-if="showAM"><button tabindex="-1" ng-show="i == midIndex - !isAM * 1" style="width: 100%" type="button" ng-class="{\'btn-primary\': !!isAM}" class="btn btn-default" ng-click="$switchMeridian()" ng-disabled="el.disabled">AM</button> <button tabindex="-1" ng-show="i == midIndex + 1 - !isAM * 1" style="width: 100%" type="button" ng-class="{\'btn-primary\': !isAM}" class="btn btn-default" ng-click="$switchMeridian()" ng-disabled="el.disabled">PM</button></td></tr></tbody><tfoot><tr class="text-center"><th><button tabindex="-1" type="button" class="btn btn-default pull-left" ng-click="$arrowAction(1, 0)"><i class="{{ $iconDown }}"></i></button></th><th>&nbsp;</th><th><button tabindex="-1" type="button" class="btn btn-default pull-left" ng-click="$arrowAction(1, 1)"><i class="{{ $iconDown }}"></i></button></th></tr></tfoot></table></div>');

    }]);

    // Source: tooltip.tpl.js
    angular.module('mgcrea.ngStrap.tooltip').run(['$templateCache', function($templateCache) {

        $templateCache.put('tooltip/tooltip.tpl.html', '<div class="tooltip in" ng-show="title"><div class="tooltip-arrow"></div><div class="tooltip-inner" ng-bind="title"></div></div>');

    }]);

    // Source: typeahead.tpl.js
    angular.module('mgcrea.ngStrap.typeahead').run(['$templateCache', function($templateCache) {

        $templateCache.put('typeahead/typeahead.tpl.html', '<ul tabindex="-1" class="typeahead dropdown-menu" ng-show="$isVisible()" role="select"><li role="presentation" ng-repeat="match in $matches" ng-class="{active: $index == $activeIndex}"><a role="menuitem" tabindex="-1" ng-click="$select($index, $event)" ng-bind="match.label"></a></li></ul>');

    }]);


})(window, document);

/**
 * @license AngularJS v1.2.16
 * (c) 2010-2014 Google, Inc. http://angularjs.org
 * License: MIT
 */
(function(window, angular, undefined) {'use strict';

/* jshint maxlen: false */

/**
 * @ngdoc module
 * @name ngAnimate
 * @description
 *
 * # ngAnimate
 *
 * The `ngAnimate` module provides support for JavaScript, CSS3 transition and CSS3 keyframe animation hooks within existing core and custom directives.
 *
 *
 * <div doc-module-components="ngAnimate"></div>
 *
 * # Usage
 *
 * To see animations in action, all that is required is to define the appropriate CSS classes
 * or to register a JavaScript animation via the myModule.animation() function. The directives that support animation automatically are:
 * `ngRepeat`, `ngInclude`, `ngIf`, `ngSwitch`, `ngShow`, `ngHide`, `ngView` and `ngClass`. Custom directives can take advantage of animation
 * by using the `$animate` service.
 *
 * Below is a more detailed breakdown of the supported animation events provided by pre-existing ng directives:
 *
 * | Directive                                                 | Supported Animations                               |
 * |---------------------------------------------------------- |----------------------------------------------------|
 * | {@link ng.directive:ngRepeat#usage_animations ngRepeat}         | enter, leave and move                              |
 * | {@link ngRoute.directive:ngView#usage_animations ngView}        | enter and leave                                    |
 * | {@link ng.directive:ngInclude#usage_animations ngInclude}       | enter and leave                                    |
 * | {@link ng.directive:ngSwitch#usage_animations ngSwitch}         | enter and leave                                    |
 * | {@link ng.directive:ngIf#usage_animations ngIf}                 | enter and leave                                    |
 * | {@link ng.directive:ngClass#usage_animations ngClass}           | add and remove                                     |
 * | {@link ng.directive:ngShow#usage_animations ngShow & ngHide}    | add and remove (the ng-hide class value)           |
 * | {@link ng.directive:form#usage_animations form}                 | add and remove (dirty, pristine, valid, invalid & all other validations)                |
 * | {@link ng.directive:ngModel#usage_animations ngModel}           | add and remove (dirty, pristine, valid, invalid & all other validations)                |
 *
 * You can find out more information about animations upon visiting each directive page.
 *
 * Below is an example of how to apply animations to a directive that supports animation hooks:
 *
 * ```html
 * <style type="text/css">
 * .slide.ng-enter, .slide.ng-leave {
 *   -webkit-transition:0.5s linear all;
 *   transition:0.5s linear all;
 * }
 *
 * .slide.ng-enter { }        /&#42; starting animations for enter &#42;/
 * .slide.ng-enter-active { } /&#42; terminal animations for enter &#42;/
 * .slide.ng-leave { }        /&#42; starting animations for leave &#42;/
 * .slide.ng-leave-active { } /&#42; terminal animations for leave &#42;/
 * </style>
 *
 * <!--
 * the animate service will automatically add .ng-enter and .ng-leave to the element
 * to trigger the CSS transition/animations
 * -->
 * <ANY class="slide" ng-include="..."></ANY>
 * ```
 *
 * Keep in mind that if an animation is running, any child elements cannot be animated until the parent element's
 * animation has completed.
 *
 * <h2>CSS-defined Animations</h2>
 * The animate service will automatically apply two CSS classes to the animated element and these two CSS classes
 * are designed to contain the start and end CSS styling. Both CSS transitions and keyframe animations are supported
 * and can be used to play along with this naming structure.
 *
 * The following code below demonstrates how to perform animations using **CSS transitions** with Angular:
 *
 * ```html
 * <style type="text/css">
 * /&#42;
 *  The animate class is apart of the element and the ng-enter class
 *  is attached to the element once the enter animation event is triggered
 * &#42;/
 * .reveal-animation.ng-enter {
 *  -webkit-transition: 1s linear all; /&#42; Safari/Chrome &#42;/
 *  transition: 1s linear all; /&#42; All other modern browsers and IE10+ &#42;/
 *
 *  /&#42; The animation preparation code &#42;/
 *  opacity: 0;
 * }
 *
 * /&#42;
 *  Keep in mind that you want to combine both CSS
 *  classes together to avoid any CSS-specificity
 *  conflicts
 * &#42;/
 * .reveal-animation.ng-enter.ng-enter-active {
 *  /&#42; The animation code itself &#42;/
 *  opacity: 1;
 * }
 * </style>
 *
 * <div class="view-container">
 *   <div ng-view class="reveal-animation"></div>
 * </div>
 * ```
 *
 * The following code below demonstrates how to perform animations using **CSS animations** with Angular:
 *
 * ```html
 * <style type="text/css">
 * .reveal-animation.ng-enter {
 *   -webkit-animation: enter_sequence 1s linear; /&#42; Safari/Chrome &#42;/
 *   animation: enter_sequence 1s linear; /&#42; IE10+ and Future Browsers &#42;/
 * }
 * @-webkit-keyframes enter_sequence {
 *   from { opacity:0; }
 *   to { opacity:1; }
 * }
 * @keyframes enter_sequence {
 *   from { opacity:0; }
 *   to { opacity:1; }
 * }
 * </style>
 *
 * <div class="view-container">
 *   <div ng-view class="reveal-animation"></div>
 * </div>
 * ```
 *
 * Both CSS3 animations and transitions can be used together and the animate service will figure out the correct duration and delay timing.
 *
 * Upon DOM mutation, the event class is added first (something like `ng-enter`), then the browser prepares itself to add
 * the active class (in this case `ng-enter-active`) which then triggers the animation. The animation module will automatically
 * detect the CSS code to determine when the animation ends. Once the animation is over then both CSS classes will be
 * removed from the DOM. If a browser does not support CSS transitions or CSS animations then the animation will start and end
 * immediately resulting in a DOM element that is at its final state. This final state is when the DOM element
 * has no CSS transition/animation classes applied to it.
 *
 * <h3>CSS Staggering Animations</h3>
 * A Staggering animation is a collection of animations that are issued with a slight delay in between each successive operation resulting in a
 * curtain-like effect. The ngAnimate module, as of 1.2.0, supports staggering animations and the stagger effect can be
 * performed by creating a **ng-EVENT-stagger** CSS class and attaching that class to the base CSS class used for
 * the animation. The style property expected within the stagger class can either be a **transition-delay** or an
 * **animation-delay** property (or both if your animation contains both transitions and keyframe animations).
 *
 * ```css
 * .my-animation.ng-enter {
 *   /&#42; standard transition code &#42;/
 *   -webkit-transition: 1s linear all;
 *   transition: 1s linear all;
 *   opacity:0;
 * }
 * .my-animation.ng-enter-stagger {
 *   /&#42; this will have a 100ms delay between each successive leave animation &#42;/
 *   -webkit-transition-delay: 0.1s;
 *   transition-delay: 0.1s;
 *
 *   /&#42; in case the stagger doesn't work then these two values
 *    must be set to 0 to avoid an accidental CSS inheritance &#42;/
 *   -webkit-transition-duration: 0s;
 *   transition-duration: 0s;
 * }
 * .my-animation.ng-enter.ng-enter-active {
 *   /&#42; standard transition styles &#42;/
 *   opacity:1;
 * }
 * ```
 *
 * Staggering animations work by default in ngRepeat (so long as the CSS class is defined). Outside of ngRepeat, to use staggering animations
 * on your own, they can be triggered by firing multiple calls to the same event on $animate. However, the restrictions surrounding this
 * are that each of the elements must have the same CSS className value as well as the same parent element. A stagger operation
 * will also be reset if more than 10ms has passed after the last animation has been fired.
 *
 * The following code will issue the **ng-leave-stagger** event on the element provided:
 *
 * ```js
 * var kids = parent.children();
 *
 * $animate.leave(kids[0]); //stagger index=0
 * $animate.leave(kids[1]); //stagger index=1
 * $animate.leave(kids[2]); //stagger index=2
 * $animate.leave(kids[3]); //stagger index=3
 * $animate.leave(kids[4]); //stagger index=4
 *
 * $timeout(function() {
 *   //stagger has reset itself
 *   $animate.leave(kids[5]); //stagger index=0
 *   $animate.leave(kids[6]); //stagger index=1
 * }, 100, false);
 * ```
 *
 * Stagger animations are currently only supported within CSS-defined animations.
 *
 * <h2>JavaScript-defined Animations</h2>
 * In the event that you do not want to use CSS3 transitions or CSS3 animations or if you wish to offer animations on browsers that do not
 * yet support CSS transitions/animations, then you can make use of JavaScript animations defined inside of your AngularJS module.
 *
 * ```js
 * //!annotate="YourApp" Your AngularJS Module|Replace this or ngModule with the module that you used to define your application.
 * var ngModule = angular.module('YourApp', ['ngAnimate']);
 * ngModule.animation('.my-crazy-animation', function() {
 *   return {
 *     enter: function(element, done) {
 *       //run the animation here and call done when the animation is complete
 *       return function(cancelled) {
 *         //this (optional) function will be called when the animation
 *         //completes or when the animation is cancelled (the cancelled
 *         //flag will be set to true if cancelled).
 *       };
 *     },
 *     leave: function(element, done) { },
 *     move: function(element, done) { },
 *
 *     //animation that can be triggered before the class is added
 *     beforeAddClass: function(element, className, done) { },
 *
 *     //animation that can be triggered after the class is added
 *     addClass: function(element, className, done) { },
 *
 *     //animation that can be triggered before the class is removed
 *     beforeRemoveClass: function(element, className, done) { },
 *
 *     //animation that can be triggered after the class is removed
 *     removeClass: function(element, className, done) { }
 *   };
 * });
 * ```
 *
 * JavaScript-defined animations are created with a CSS-like class selector and a collection of events which are set to run
 * a javascript callback function. When an animation is triggered, $animate will look for a matching animation which fits
 * the element's CSS class attribute value and then run the matching animation event function (if found).
 * In other words, if the CSS classes present on the animated element match any of the JavaScript animations then the callback function will
 * be executed. It should be also noted that only simple, single class selectors are allowed (compound class selectors are not supported).
 *
 * Within a JavaScript animation, an object containing various event callback animation functions is expected to be returned.
 * As explained above, these callbacks are triggered based on the animation event. Therefore if an enter animation is run,
 * and the JavaScript animation is found, then the enter callback will handle that animation (in addition to the CSS keyframe animation
 * or transition code that is defined via a stylesheet).
 *
 */

angular.module('ngAnimate', ['ng'])

  /**
   * @ngdoc provider
   * @name $animateProvider
   * @description
   *
   * The `$animateProvider` allows developers to register JavaScript animation event handlers directly inside of a module.
   * When an animation is triggered, the $animate service will query the $animate service to find any animations that match
   * the provided name value.
   *
   * Requires the {@link ngAnimate `ngAnimate`} module to be installed.
   *
   * Please visit the {@link ngAnimate `ngAnimate`} module overview page learn more about how to use animations in your application.
   *
   */

  //this private service is only used within CSS-enabled animations
  //IE8 + IE9 do not support rAF natively, but that is fine since they
  //also don't support transitions and keyframes which means that the code
  //below will never be used by the two browsers.
  .factory('$$animateReflow', ['$$rAF', '$document', function($$rAF, $document) {
    var bod = $document[0].body;
    return function(fn) {
      //the returned function acts as the cancellation function
      return $$rAF(function() {
        //the line below will force the browser to perform a repaint
        //so that all the animated elements within the animation frame
        //will be properly updated and drawn on screen. This is
        //required to perform multi-class CSS based animations with
        //Firefox. DO NOT REMOVE THIS LINE.
        var a = bod.offsetWidth + 1;
        fn();
      });
    };
  }])

  .config(['$provide', '$animateProvider', function($provide, $animateProvider) {
    var noop = angular.noop;
    var forEach = angular.forEach;
    var selectors = $animateProvider.$$selectors;

    var ELEMENT_NODE = 1;
    var NG_ANIMATE_STATE = '$$ngAnimateState';
    var NG_ANIMATE_CLASS_NAME = 'ng-animate';
    var rootAnimateState = {running: true};

    function extractElementNode(element) {
      for(var i = 0; i < element.length; i++) {
        var elm = element[i];
        if(elm.nodeType == ELEMENT_NODE) {
          return elm;
        }
      }
    }

    function stripCommentsFromElement(element) {
      return angular.element(extractElementNode(element));
    }

    function isMatchingElement(elm1, elm2) {
      return extractElementNode(elm1) == extractElementNode(elm2);
    }
    //$provide.de = function (){}
    $provide.decorator('$animate', ['$delegate', '$injector', '$sniffer', '$rootElement', /*'$$asyncCallback',*/ '$rootScope', '$document',
                            function($delegate,   $injector,   $sniffer,   $rootElement,  /* $$asyncCallback,  */  $rootScope,   $document) {

      var globalAnimationCounter = 0;
      $rootElement.data(NG_ANIMATE_STATE, rootAnimateState);

      // disable animations during bootstrap, but once we bootstrapped, wait again
      // for another digest until enabling animations. The reason why we digest twice
      // is because all structural animations (enter, leave and move) all perform a
      // post digest operation before animating. If we only wait for a single digest
      // to pass then the structural animation would render its animation on page load.
      // (which is what we're trying to avoid when the application first boots up.)
      $rootScope.$$postDigest(function() {
        $rootScope.$$postDigest(function() {
          rootAnimateState.running = false;
        });
      });

      var classNameFilter = $animateProvider.classNameFilter();
      var isAnimatableClassName = !classNameFilter
              ? function() { return true; }
              : function(className) {
                return classNameFilter.test(className);
              };

      function lookup(name) {
        if (name) {
          var matches = [],
              flagMap = {},
              classes = name.substr(1).split('.');

          //the empty string value is the default animation
          //operation which performs CSS transition and keyframe
          //animations sniffing. This is always included for each
          //element animation procedure if the browser supports
          //transitions and/or keyframe animations. The default
          //animation is added to the top of the list to prevent
          //any previous animations from affecting the element styling
          //prior to the element being animated.
          if ($sniffer.transitions || $sniffer.animations) {
            //matches.push($injector.get(selectors['']));
          }

          for(var i=0; i < classes.length; i++) {
            var klass = classes[i], selectorFactoryName=null;
               // selectorFactoryName = selectors[klass];
            if(selectorFactoryName && !flagMap[klass]) {
              matches.push($injector.get(selectorFactoryName));
              flagMap[klass] = true;
            }
          }
          return matches;
        }
      }

      function animationRunner(element, animationEvent, className) {
        //transcluded directives may sometimes fire an animation using only comment nodes
        //best to catch this early on to prevent any animation operations from occurring
        var node = element[0];
        if(!node) {
          return;
        }

        var isSetClassOperation = animationEvent == 'setClass';
        var isClassBased = isSetClassOperation ||
                           animationEvent == 'addClass' ||
                           animationEvent == 'removeClass';

        var classNameAdd, classNameRemove;
        if(angular.isArray(className)) {
          classNameAdd = className[0];
          classNameRemove = className[1];
          className = classNameAdd + ' ' + classNameRemove;
        }

        var currentClassName = element.attr('class');
        var classes = currentClassName + ' ' + className;
        if(!isAnimatableClassName(classes)) {
          return;
        }

        var beforeComplete = noop,
            beforeCancel = [],
            before = [],
            afterComplete = noop,
            afterCancel = [],
            after = [];

        var animationLookup = (' ' + classes).replace(/\s+/g,'.');
        forEach(lookup(animationLookup), function(animationFactory) {
          var created = registerAnimation(animationFactory, animationEvent);
          if(!created && isSetClassOperation) {
            registerAnimation(animationFactory, 'addClass');
            registerAnimation(animationFactory, 'removeClass');
          }
        });

        function registerAnimation(animationFactory, event) {
          var afterFn = animationFactory[event];
          var beforeFn = animationFactory['before' + event.charAt(0).toUpperCase() + event.substr(1)];
          if(afterFn || beforeFn) {
            if(event == 'leave') {
              beforeFn = afterFn;
              //when set as null then animation knows to skip this phase
              afterFn = null;
            }
            after.push({
              event : event, fn : afterFn
            });
            before.push({
              event : event, fn : beforeFn
            });
            return true;
          }
        }

        function run(fns, cancellations, allCompleteFn) {
          var animations = [];
          forEach(fns, function(animation) {
            animation.fn && animations.push(animation);
          });

          var count = 0;
          function afterAnimationComplete(index) {
            if(cancellations) {
              (cancellations[index] || noop)();
              if(++count < animations.length) return;
              cancellations = null;
            }
            allCompleteFn();
          }

          //The code below adds directly to the array in order to work with
          //both sync and async animations. Sync animations are when the done()
          //operation is called right away. DO NOT REFACTOR!
          forEach(animations, function(animation, index) {
            var progress = function() {
              afterAnimationComplete(index);
            };
            switch(animation.event) {
              case 'setClass':
                cancellations.push(animation.fn(element, classNameAdd, classNameRemove, progress));
                break;
              case 'addClass':
                cancellations.push(animation.fn(element, classNameAdd || className,     progress));
                break;
              case 'removeClass':
                cancellations.push(animation.fn(element, classNameRemove || className,  progress));
                break;
              default:
                cancellations.push(animation.fn(element, progress));
                break;
            }
          });

          if(cancellations && cancellations.length === 0) {
            allCompleteFn();
          }
        }

        return {
          node : node,
          event : animationEvent,
          className : className,
          isClassBased : isClassBased,
          isSetClassOperation : isSetClassOperation,
          before : function(allCompleteFn) {
            beforeComplete = allCompleteFn;
            run(before, beforeCancel, function() {
              beforeComplete = noop;
              allCompleteFn();
            });
          },
          after : function(allCompleteFn) {
            afterComplete = allCompleteFn;
            run(after, afterCancel, function() {
              afterComplete = noop;
              allCompleteFn();
            });
          },
          cancel : function() {
            if(beforeCancel) {
              forEach(beforeCancel, function(cancelFn) {
                (cancelFn || noop)(true);
              });
              beforeComplete(true);
            }
            if(afterCancel) {
              forEach(afterCancel, function(cancelFn) {
                (cancelFn || noop)(true);
              });
              afterComplete(true);
            }
          }
        };
      }

      /**
       * @ngdoc service
       * @name $animate
       * @function
       *
       * @description
       * The `$animate` service provides animation detection support while performing DOM operations (enter, leave and move) as well as during addClass and removeClass operations.
       * When any of these operations are run, the $animate service
       * will examine any JavaScript-defined animations (which are defined by using the $animateProvider provider object)
       * as well as any CSS-defined animations against the CSS classes present on the element once the DOM operation is run.
       *
       * The `$animate` service is used behind the scenes with pre-existing directives and animation with these directives
       * will work out of the box without any extra configuration.
       *
       * Requires the {@link ngAnimate `ngAnimate`} module to be installed.
       *
       * Please visit the {@link ngAnimate `ngAnimate`} module overview page learn more about how to use animations in your application.
       *
       */
      return {
        /**
         * @ngdoc method
         * @name $animate#enter
         * @function
         *
         * @description
         * Appends the element to the parentElement element that resides in the document and then runs the enter animation. Once
         * the animation is started, the following CSS classes will be present on the element for the duration of the animation:
         *
         * Below is a breakdown of each step that occurs during enter animation:
         *
         * | Animation Step                                                                               | What the element class attribute looks like |
         * |----------------------------------------------------------------------------------------------|---------------------------------------------|
         * | 1. $animate.enter(...) is called                                                             | class="my-animation"                        |
         * | 2. element is inserted into the parentElement element or beside the afterElement element     | class="my-animation"                        |
         * | 3. $animate runs any JavaScript-defined animations on the element                            | class="my-animation ng-animate"             |
         * | 4. the .ng-enter class is added to the element                                               | class="my-animation ng-animate ng-enter"    |
         * | 5. $animate scans the element styles to get the CSS transition/animation duration and delay  | class="my-animation ng-animate ng-enter"    |
         * | 6. $animate waits for 10ms (this performs a reflow)                                          | class="my-animation ng-animate ng-enter"    |
         * | 7. the .ng-enter-active and .ng-animate-active classes are added (this triggers the CSS transition/animation) | class="my-animation ng-animate ng-animate-active ng-enter ng-enter-active" |
         * | 8. $animate waits for X milliseconds for the animation to complete                           | class="my-animation ng-animate ng-animate-active ng-enter ng-enter-active" |
         * | 9. The animation ends and all generated CSS classes are removed from the element             | class="my-animation"                        |
         * | 10. The doneCallback() callback is fired (if provided)                                       | class="my-animation"                        |
         *
         * @param {DOMElement} element the element that will be the focus of the enter animation
         * @param {DOMElement} parentElement the parent element of the element that will be the focus of the enter animation
         * @param {DOMElement} afterElement the sibling element (which is the previous element) of the element that will be the focus of the enter animation
         * @param {function()=} doneCallback the callback function that will be called once the animation is complete
        */
        enter : function(element, parentElement, afterElement, doneCallback) {
          this.enabled(false, element);
          $delegate.enter(element, parentElement, afterElement);
          $rootScope.$$postDigest(function() {
            element = stripCommentsFromElement(element);
            performAnimation('enter', 'ng-enter', element, parentElement, afterElement, noop, doneCallback);
          });
        },

        /**
         * @ngdoc method
         * @name $animate#leave
         * @function
         *
         * @description
         * Runs the leave animation operation and, upon completion, removes the element from the DOM. Once
         * the animation is started, the following CSS classes will be added for the duration of the animation:
         *
         * Below is a breakdown of each step that occurs during leave animation:
         *
         * | Animation Step                                                                               | What the element class attribute looks like |
         * |----------------------------------------------------------------------------------------------|---------------------------------------------|
         * | 1. $animate.leave(...) is called                                                             | class="my-animation"                        |
         * | 2. $animate runs any JavaScript-defined animations on the element                            | class="my-animation ng-animate"             |
         * | 3. the .ng-leave class is added to the element                                               | class="my-animation ng-animate ng-leave"    |
         * | 4. $animate scans the element styles to get the CSS transition/animation duration and delay  | class="my-animation ng-animate ng-leave"    |
         * | 5. $animate waits for 10ms (this performs a reflow)                                          | class="my-animation ng-animate ng-leave"    |
         * | 6. the .ng-leave-active and .ng-animate-active classes is added (this triggers the CSS transition/animation) | class="my-animation ng-animate ng-animate-active ng-leave ng-leave-active" |
         * | 7. $animate waits for X milliseconds for the animation to complete                           | class="my-animation ng-animate ng-animate-active ng-leave ng-leave-active" |
         * | 8. The animation ends and all generated CSS classes are removed from the element             | class="my-animation"                        |
         * | 9. The element is removed from the DOM                                                       | ...                                         |
         * | 10. The doneCallback() callback is fired (if provided)                                       | ...                                         |
         *
         * @param {DOMElement} element the element that will be the focus of the leave animation
         * @param {function()=} doneCallback the callback function that will be called once the animation is complete
        */
        leave : function(element, doneCallback) {
          cancelChildAnimations(element);
          this.enabled(false, element);
          $rootScope.$$postDigest(function() {
            performAnimation('leave', 'ng-leave', stripCommentsFromElement(element), null, null, function() {
              $delegate.leave(element);
            }, doneCallback);
          });
        },

        /**
         * @ngdoc method
         * @name $animate#move
         * @function
         *
         * @description
         * Fires the move DOM operation. Just before the animation starts, the animate service will either append it into the parentElement container or
         * add the element directly after the afterElement element if present. Then the move animation will be run. Once
         * the animation is started, the following CSS classes will be added for the duration of the animation:
         *
         * Below is a breakdown of each step that occurs during move animation:
         *
         * | Animation Step                                                                               | What the element class attribute looks like |
         * |----------------------------------------------------------------------------------------------|---------------------------------------------|
         * | 1. $animate.move(...) is called                                                              | class="my-animation"                        |
         * | 2. element is moved into the parentElement element or beside the afterElement element        | class="my-animation"                        |
         * | 3. $animate runs any JavaScript-defined animations on the element                            | class="my-animation ng-animate"             |
         * | 4. the .ng-move class is added to the element                                                | class="my-animation ng-animate ng-move"     |
         * | 5. $animate scans the element styles to get the CSS transition/animation duration and delay  | class="my-animation ng-animate ng-move"     |
         * | 6. $animate waits for 10ms (this performs a reflow)                                          | class="my-animation ng-animate ng-move"     |
         * | 7. the .ng-move-active and .ng-animate-active classes is added (this triggers the CSS transition/animation) | class="my-animation ng-animate ng-animate-active ng-move ng-move-active" |
         * | 8. $animate waits for X milliseconds for the animation to complete                           | class="my-animation ng-animate ng-animate-active ng-move ng-move-active" |
         * | 9. The animation ends and all generated CSS classes are removed from the element             | class="my-animation"                        |
         * | 10. The doneCallback() callback is fired (if provided)                                       | class="my-animation"                        |
         *
         * @param {DOMElement} element the element that will be the focus of the move animation
         * @param {DOMElement} parentElement the parentElement element of the element that will be the focus of the move animation
         * @param {DOMElement} afterElement the sibling element (which is the previous element) of the element that will be the focus of the move animation
         * @param {function()=} doneCallback the callback function that will be called once the animation is complete
        */
        move : function(element, parentElement, afterElement, doneCallback) {
          cancelChildAnimations(element);
          this.enabled(false, element);
          $delegate.move(element, parentElement, afterElement);
          $rootScope.$$postDigest(function() {
            element = stripCommentsFromElement(element);
            performAnimation('move', 'ng-move', element, parentElement, afterElement, noop, doneCallback);
          });
        },

        /**
         * @ngdoc method
         * @name $animate#addClass
         *
         * @description
         * Triggers a custom animation event based off the className variable and then attaches the className value to the element as a CSS class.
         * Unlike the other animation methods, the animate service will suffix the className value with {@type -add} in order to provide
         * the animate service the setup and active CSS classes in order to trigger the animation (this will be skipped if no CSS transitions
         * or keyframes are defined on the -add or base CSS class).
         *
         * Below is a breakdown of each step that occurs during addClass animation:
         *
         * | Animation Step                                                                                 | What the element class attribute looks like |
         * |------------------------------------------------------------------------------------------------|---------------------------------------------|
         * | 1. $animate.addClass(element, 'super') is called                                               | class="my-animation"                        |
         * | 2. $animate runs any JavaScript-defined animations on the element                              | class="my-animation ng-animate"             |
         * | 3. the .super-add class are added to the element                                               | class="my-animation ng-animate super-add"   |
         * | 4. $animate scans the element styles to get the CSS transition/animation duration and delay    | class="my-animation ng-animate super-add"   |
         * | 5. $animate waits for 10ms (this performs a reflow)                                            | class="my-animation ng-animate super-add"   |
         * | 6. the .super, .super-add-active and .ng-animate-active classes are added (this triggers the CSS transition/animation) | class="my-animation ng-animate ng-animate-active super super-add super-add-active"          |
         * | 7. $animate waits for X milliseconds for the animation to complete                             | class="my-animation super super-add super-add-active"  |
         * | 8. The animation ends and all generated CSS classes are removed from the element               | class="my-animation super"                  |
         * | 9. The super class is kept on the element                                                      | class="my-animation super"                  |
         * | 10. The doneCallback() callback is fired (if provided)                                         | class="my-animation super"                  |
         *
         * @param {DOMElement} element the element that will be animated
         * @param {string} className the CSS class that will be added to the element and then animated
         * @param {function()=} doneCallback the callback function that will be called once the animation is complete
        */
        addClass : function(element, className, doneCallback) {
          element = stripCommentsFromElement(element);
          performAnimation('addClass', className, element, null, null, function() {
            $delegate.addClass(element, className);
          }, doneCallback);
        },

        /**
         * @ngdoc method
         * @name $animate#removeClass
         *
         * @description
         * Triggers a custom animation event based off the className variable and then removes the CSS class provided by the className value
         * from the element. Unlike the other animation methods, the animate service will suffix the className value with {@type -remove} in
         * order to provide the animate service the setup and active CSS classes in order to trigger the animation (this will be skipped if
         * no CSS transitions or keyframes are defined on the -remove or base CSS classes).
         *
         * Below is a breakdown of each step that occurs during removeClass animation:
         *
         * | Animation Step                                                                                | What the element class attribute looks like     |
         * |-----------------------------------------------------------------------------------------------|---------------------------------------------|
         * | 1. $animate.removeClass(element, 'super') is called                                           | class="my-animation super"                  |
         * | 2. $animate runs any JavaScript-defined animations on the element                             | class="my-animation super ng-animate"       |
         * | 3. the .super-remove class are added to the element                                           | class="my-animation super ng-animate super-remove"|
         * | 4. $animate scans the element styles to get the CSS transition/animation duration and delay   | class="my-animation super ng-animate super-remove"   |
         * | 5. $animate waits for 10ms (this performs a reflow)                                           | class="my-animation super ng-animate super-remove"   |
         * | 6. the .super-remove-active and .ng-animate-active classes are added and .super is removed (this triggers the CSS transition/animation) | class="my-animation ng-animate ng-animate-active super-remove super-remove-active"          |
         * | 7. $animate waits for X milliseconds for the animation to complete                            | class="my-animation ng-animate ng-animate-active super-remove super-remove-active"   |
         * | 8. The animation ends and all generated CSS classes are removed from the element              | class="my-animation"                        |
         * | 9. The doneCallback() callback is fired (if provided)                                         | class="my-animation"                        |
         *
         *
         * @param {DOMElement} element the element that will be animated
         * @param {string} className the CSS class that will be animated and then removed from the element
         * @param {function()=} doneCallback the callback function that will be called once the animation is complete
        */
        removeClass : function(element, className, doneCallback) {
          element = stripCommentsFromElement(element);
          performAnimation('removeClass', className, element, null, null, function() {
            $delegate.removeClass(element, className);
          }, doneCallback);
        },

          /**
           *
           * @ngdoc function
           * @name $animate#setClass
           * @function
           * @description Adds and/or removes the given CSS classes to and from the element.
           * Once complete, the done() callback will be fired (if provided).
           * @param {DOMElement} element the element which will it's CSS classes changed
           *   removed from it
           * @param {string} add the CSS classes which will be added to the element
           * @param {string} remove the CSS class which will be removed from the element
           * @param {Function=} done the callback function (if provided) that will be fired after the
           *   CSS classes have been set on the element
           */
        setClass : function(element, add, remove, doneCallback) {
          element = stripCommentsFromElement(element);
          performAnimation('setClass', [add, remove], element, null, null, function() {
            $delegate.setClass(element, add, remove);
          }, doneCallback);
        },

        /**
         * @ngdoc method
         * @name $animate#enabled
         * @function
         *
         * @param {boolean=} value If provided then set the animation on or off.
         * @param {DOMElement=} element If provided then the element will be used to represent the enable/disable operation
         * @return {boolean} Current animation state.
         *
         * @description
         * Globally enables/disables animations.
         *
        */
        enabled : function(value, element) {
          switch(arguments.length) {
            case 2:
              if(value) {
                cleanup(element);
              } else {
                var data = element.data(NG_ANIMATE_STATE) || {};
                data.disabled = true;
                element.data(NG_ANIMATE_STATE, data);
              }
            break;

            case 1:
              rootAnimateState.disabled = !value;
            break;

            default:
              value = !rootAnimateState.disabled;
            break;
          }
          return !!value;
         }
      };

      /*
        all animations call this shared animation triggering function internally.
        The animationEvent variable refers to the JavaScript animation event that will be triggered
        and the className value is the name of the animation that will be applied within the
        CSS code. Element, parentElement and afterElement are provided DOM elements for the animation
        and the onComplete callback will be fired once the animation is fully complete.
      */
      function performAnimation(animationEvent, className, element, parentElement, afterElement, domOperation, doneCallback) {

        var runner = animationRunner(element, animationEvent, className);
        if(!runner) {
          fireDOMOperation();
          fireBeforeCallbackAsync();
          fireAfterCallbackAsync();
          closeAnimation();
          return;
        }

        className = runner.className;
        var elementEvents = angular.element._data(runner.node);
        elementEvents = elementEvents && elementEvents.events;

        if (!parentElement) {
          parentElement = afterElement ? afterElement.parent() : element.parent();
        }

        var ngAnimateState  = element.data(NG_ANIMATE_STATE) || {};
        var runningAnimations     = ngAnimateState.active || {};
        var totalActiveAnimations = ngAnimateState.totalActive || 0;
        var lastAnimation         = ngAnimateState.last;

        //only allow animations if the currently running animation is not structural
        //or if there is no animation running at all
        var skipAnimations = runner.isClassBased ?
          ngAnimateState.disabled || (lastAnimation && !lastAnimation.isClassBased) :
          false;

        //skip the animation if animations are disabled, a parent is already being animated,
        //the element is not currently attached to the document body or then completely close
        //the animation if any matching animations are not found at all.
        //NOTE: IE8 + IE9 should close properly (run closeAnimation()) in case an animation was found.
        if (skipAnimations || animationsDisabled(element, parentElement)) {
          fireDOMOperation();
          fireBeforeCallbackAsync();
          fireAfterCallbackAsync();
          closeAnimation();
          return;
        }

        var skipAnimation = false;
        if(totalActiveAnimations > 0) {
          var animationsToCancel = [];
          if(!runner.isClassBased) {
            if(animationEvent == 'leave' && runningAnimations['ng-leave']) {
              skipAnimation = true;
            } else {
              //cancel all animations when a structural animation takes place
              for(var klass in runningAnimations) {
                animationsToCancel.push(runningAnimations[klass]);
                cleanup(element, klass);
              }
              runningAnimations = {};
              totalActiveAnimations = 0;
            }
          } else if(lastAnimation.event == 'setClass') {
            animationsToCancel.push(lastAnimation);
            cleanup(element, className);
          }
          else if(runningAnimations[className]) {
            var current = runningAnimations[className];
            if(current.event == animationEvent) {
              skipAnimation = true;
            } else {
              animationsToCancel.push(current);
              cleanup(element, className);
            }
          }

          if(animationsToCancel.length > 0) {
            forEach(animationsToCancel, function(operation) {
              operation.cancel();
            });
          }
        }

        if(runner.isClassBased && !runner.isSetClassOperation && !skipAnimation) {
          skipAnimation = (animationEvent == 'addClass') == element.hasClass(className); //opposite of XOR
        }

        if(skipAnimation) {
          fireBeforeCallbackAsync();
          fireAfterCallbackAsync();
          fireDoneCallbackAsync();
          return;
        }

        if(animationEvent == 'leave') {
          //there's no need to ever remove the listener since the element
          //will be removed (destroyed) after the leave animation ends or
          //is cancelled midway
          element.one('$destroy', function(e) {
            var element = angular.element(this);
            var state = element.data(NG_ANIMATE_STATE);
            if(state) {
              var activeLeaveAnimation = state.active['ng-leave'];
              if(activeLeaveAnimation) {
                activeLeaveAnimation.cancel();
                cleanup(element, 'ng-leave');
              }
            }
          });
        }

        //the ng-animate class does nothing, but it's here to allow for
        //parent animations to find and cancel child animations when needed
        element.addClass(NG_ANIMATE_CLASS_NAME);

        var localAnimationCount = globalAnimationCounter++;
        totalActiveAnimations++;
        runningAnimations[className] = runner;

        element.data(NG_ANIMATE_STATE, {
          last : runner,
          active : runningAnimations,
          index : localAnimationCount,
          totalActive : totalActiveAnimations
        });

        //first we run the before animations and when all of those are complete
        //then we perform the DOM operation and run the next set of animations
        fireBeforeCallbackAsync();
        runner.before(function(cancelled) {
          var data = element.data(NG_ANIMATE_STATE);
          cancelled = cancelled ||
                        !data || !data.active[className] ||
                        (runner.isClassBased && data.active[className].event != animationEvent);

          fireDOMOperation();
          if(cancelled === true) {
            closeAnimation();
          } else {
            fireAfterCallbackAsync();
            runner.after(closeAnimation);
          }
        });

        function fireDOMCallback(animationPhase) {
          var eventName = '$animate:' + animationPhase;
          if(elementEvents && elementEvents[eventName] && elementEvents[eventName].length > 0) {
           /* $$asyncCallback(function() {
              element.triggerHandler(eventName, {
                event : animationEvent,
                className : className
              });
            });*/
          }
        }

        function fireBeforeCallbackAsync() {
          fireDOMCallback('before');
        }

        function fireAfterCallbackAsync() {
          fireDOMCallback('after');
        }

        function fireDoneCallbackAsync() {
          fireDOMCallback('close');
          if(doneCallback) {
           /* $$asyncCallback(function() {
              doneCallback();
            });*/
          }
        }

        //it is less complicated to use a flag than managing and canceling
        //timeouts containing multiple callbacks.
        function fireDOMOperation() {
          if(!fireDOMOperation.hasBeenRun) {
            fireDOMOperation.hasBeenRun = true;
            domOperation();
          }
        }

        function closeAnimation() {
          if(!closeAnimation.hasBeenRun) {
            closeAnimation.hasBeenRun = true;
            var data = element.data(NG_ANIMATE_STATE);
            if(data) {
              /* only structural animations wait for reflow before removing an
                 animation, but class-based animations don't. An example of this
                 failing would be when a parent HTML tag has a ng-class attribute
                 causing ALL directives below to skip animations during the digest */
              if(runner && runner.isClassBased) {
                cleanup(element, className);
              } else {
                /*$$asyncCallback(function() {
                  var data = element.data(NG_ANIMATE_STATE) || {};
                  if(localAnimationCount == data.index) {
                    cleanup(element, className, animationEvent);
                  }
                });*/
                element.data(NG_ANIMATE_STATE, data);
              }
            }
            fireDoneCallbackAsync();
          }
        }
      }

      function cancelChildAnimations(element) {
        var node = extractElementNode(element);
        if (node) {
          var nodes = angular.isFunction(node.getElementsByClassName) ?
            node.getElementsByClassName(NG_ANIMATE_CLASS_NAME) :
            node.querySelectorAll('.' + NG_ANIMATE_CLASS_NAME);
          forEach(nodes, function(element) {
            element = angular.element(element);
            var data = element.data(NG_ANIMATE_STATE);
            if(data && data.active) {
              forEach(data.active, function(runner) {
                runner.cancel();
              });
            }
          });
        }
      }

      function cleanup(element, className) {
        if(isMatchingElement(element, $rootElement)) {
          if(!rootAnimateState.disabled) {
            rootAnimateState.running = false;
            rootAnimateState.structural = false;
          }
        } else if(className) {
          var data = element.data(NG_ANIMATE_STATE) || {};

          var removeAnimations = className === true;
          if(!removeAnimations && data.active && data.active[className]) {
            data.totalActive--;
            delete data.active[className];
          }

          if(removeAnimations || !data.totalActive) {
            element.removeClass(NG_ANIMATE_CLASS_NAME);
            element.removeData(NG_ANIMATE_STATE);
          }
        }
      }

      function animationsDisabled(element, parentElement) {
        if (rootAnimateState.disabled) return true;

        if(isMatchingElement(element, $rootElement)) {
          return rootAnimateState.disabled || rootAnimateState.running;
        }

        do {
          //the element did not reach the root element which means that it
          //is not apart of the DOM. Therefore there is no reason to do
          //any animations on it
          if(parentElement.length === 0) break;

          var isRoot = isMatchingElement(parentElement, $rootElement);
          var state = isRoot ? rootAnimateState : parentElement.data(NG_ANIMATE_STATE);
          var result = state && (!!state.disabled || state.running || state.totalActive > 0);
          if(isRoot || result) {
            return result;
          }

          if(isRoot) return true;
        }
        while(parentElement = parentElement.parent());

        return true;
      }
    }]);

    $animateProvider.register('', ['$window', '$sniffer', '$timeout', '$$animateReflow',
                           function($window,   $sniffer,   $timeout,   $$animateReflow) {
      // Detect proper transitionend/animationend event names.
      var CSS_PREFIX = '', TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;

      // If unprefixed events are not supported but webkit-prefixed are, use the latter.
      // Otherwise, just use W3C names, browsers not supporting them at all will just ignore them.
      // Note: Chrome implements `window.onwebkitanimationend` and doesn't implement `window.onanimationend`
      // but at the same time dispatches the `animationend` event and not `webkitAnimationEnd`.
      // Register both events in case `window.onanimationend` is not supported because of that,
      // do the same for `transitionend` as Safari is likely to exhibit similar behavior.
      // Also, the only modern browser that uses vendor prefixes for transitions/keyframes is webkit
      // therefore there is no reason to test anymore for other vendor prefixes: http://caniuse.com/#search=transition
      if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
        CSS_PREFIX = '-webkit-';
        TRANSITION_PROP = 'WebkitTransition';
        TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';
      } else {
        TRANSITION_PROP = 'transition';
        TRANSITIONEND_EVENT = 'transitionend';
      }

      if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
        CSS_PREFIX = '-webkit-';
        ANIMATION_PROP = 'WebkitAnimation';
        ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';
      } else {
        ANIMATION_PROP = 'animation';
        ANIMATIONEND_EVENT = 'animationend';
      }

      var DURATION_KEY = 'Duration';
      var PROPERTY_KEY = 'Property';
      var DELAY_KEY = 'Delay';
      var ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';
      var NG_ANIMATE_PARENT_KEY = '$$ngAnimateKey';
      var NG_ANIMATE_CSS_DATA_KEY = '$$ngAnimateCSS3Data';
      var NG_ANIMATE_BLOCK_CLASS_NAME = 'ng-animate-block-transitions';
      var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;
      var CLOSING_TIME_BUFFER = 1.5;
      var ONE_SECOND = 1000;

      var lookupCache = {};
      var parentCounter = 0;
      var animationReflowQueue = [];
      var cancelAnimationReflow;
      function afterReflow(element, callback) {
        if(cancelAnimationReflow) {
          cancelAnimationReflow();
        }
        animationReflowQueue.push(callback);
        cancelAnimationReflow = $$animateReflow(function() {
          forEach(animationReflowQueue, function(fn) {
            fn();
          });

          animationReflowQueue = [];
          cancelAnimationReflow = null;
          lookupCache = {};
        });
      }

      var closingTimer = null;
      var closingTimestamp = 0;
      var animationElementQueue = [];
      function animationCloseHandler(element, totalTime) {
        var node = extractElementNode(element);
        element = angular.element(node);

        //this item will be garbage collected by the closing
        //animation timeout
        animationElementQueue.push(element);

        //but it may not need to cancel out the existing timeout
        //if the timestamp is less than the previous one
        var futureTimestamp = Date.now() + totalTime;
        if(futureTimestamp <= closingTimestamp) {
          return;
        }

        $timeout.cancel(closingTimer);

        closingTimestamp = futureTimestamp;
        closingTimer = $timeout(function() {
          closeAllAnimations(animationElementQueue);
          animationElementQueue = [];
        }, totalTime, false);
      }

      function closeAllAnimations(elements) {
        forEach(elements, function(element) {
          var elementData = element.data(NG_ANIMATE_CSS_DATA_KEY);
          if(elementData) {
            (elementData.closeAnimationFn || noop)();
          }
        });
      }

      function getElementAnimationDetails(element, cacheKey) {
        var data = cacheKey ? lookupCache[cacheKey] : null;
        if(!data) {
          var transitionDuration = 0;
          var transitionDelay = 0;
          var animationDuration = 0;
          var animationDelay = 0;
          var transitionDelayStyle;
          var animationDelayStyle;
          var transitionDurationStyle;
          var transitionPropertyStyle;

          //we want all the styles defined before and after
          forEach(element, function(element) {
            if (element.nodeType == ELEMENT_NODE) {
              var elementStyles = $window.getComputedStyle(element) || {};

              transitionDurationStyle = elementStyles[TRANSITION_PROP + DURATION_KEY];

              transitionDuration = Math.max(parseMaxTime(transitionDurationStyle), transitionDuration);

              transitionPropertyStyle = elementStyles[TRANSITION_PROP + PROPERTY_KEY];

              transitionDelayStyle = elementStyles[TRANSITION_PROP + DELAY_KEY];

              transitionDelay  = Math.max(parseMaxTime(transitionDelayStyle), transitionDelay);

              animationDelayStyle = elementStyles[ANIMATION_PROP + DELAY_KEY];

              animationDelay   = Math.max(parseMaxTime(animationDelayStyle), animationDelay);

              var aDuration  = parseMaxTime(elementStyles[ANIMATION_PROP + DURATION_KEY]);

              if(aDuration > 0) {
                aDuration *= parseInt(elementStyles[ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY], 10) || 1;
              }

              animationDuration = Math.max(aDuration, animationDuration);
            }
          });
          data = {
            total : 0,
            transitionPropertyStyle: transitionPropertyStyle,
            transitionDurationStyle: transitionDurationStyle,
            transitionDelayStyle: transitionDelayStyle,
            transitionDelay: transitionDelay,
            transitionDuration: transitionDuration,
            animationDelayStyle: animationDelayStyle,
            animationDelay: animationDelay,
            animationDuration: animationDuration
          };
          if(cacheKey) {
            lookupCache[cacheKey] = data;
          }
        }
        return data;
      }

      function parseMaxTime(str) {
        var maxValue = 0;
        var values = angular.isString(str) ?
          str.split(/\s*,\s*/) :
          [];
        forEach(values, function(value) {
          maxValue = Math.max(parseFloat(value) || 0, maxValue);
        });
        return maxValue;
      }

      function getCacheKey(element) {
        var parentElement = element.parent();
        var parentID = parentElement.data(NG_ANIMATE_PARENT_KEY);
        if(!parentID) {
          parentElement.data(NG_ANIMATE_PARENT_KEY, ++parentCounter);
          parentID = parentCounter;
        }
        return parentID + '-' + extractElementNode(element).getAttribute('class');
      }

      function animateSetup(animationEvent, element, className, calculationDecorator) {
        var cacheKey = getCacheKey(element);
        var eventCacheKey = cacheKey + ' ' + className;
        var itemIndex = lookupCache[eventCacheKey] ? ++lookupCache[eventCacheKey].total : 0;

        var stagger = {};
        if(itemIndex > 0) {
          var staggerClassName = className + '-stagger';
          var staggerCacheKey = cacheKey + ' ' + staggerClassName;
          var applyClasses = !lookupCache[staggerCacheKey];

          applyClasses && element.addClass(staggerClassName);

          stagger = getElementAnimationDetails(element, staggerCacheKey);

          applyClasses && element.removeClass(staggerClassName);
        }

        /* the animation itself may need to add/remove special CSS classes
         * before calculating the anmation styles */
        calculationDecorator = calculationDecorator ||
                               function(fn) { return fn(); };

        element.addClass(className);

        var formerData = element.data(NG_ANIMATE_CSS_DATA_KEY) || {};

        var timings = calculationDecorator(function() {
          return getElementAnimationDetails(element, eventCacheKey);
        });

        var transitionDuration = timings.transitionDuration;
        var animationDuration = timings.animationDuration;
        if(transitionDuration === 0 && animationDuration === 0) {
          element.removeClass(className);
          return false;
        }

        element.data(NG_ANIMATE_CSS_DATA_KEY, {
          running : formerData.running || 0,
          itemIndex : itemIndex,
          stagger : stagger,
          timings : timings,
          closeAnimationFn : noop
        });

        //temporarily disable the transition so that the enter styles
        //don't animate twice (this is here to avoid a bug in Chrome/FF).
        var isCurrentlyAnimating = formerData.running > 0 || animationEvent == 'setClass';
        if(transitionDuration > 0) {
          blockTransitions(element, className, isCurrentlyAnimating);
        }

        //staggering keyframe animations work by adjusting the `animation-delay` CSS property
        //on the given element, however, the delay value can only calculated after the reflow
        //since by that time $animate knows how many elements are being animated. Therefore,
        //until the reflow occurs the element needs to be blocked (where the keyframe animation
        //is set to `none 0s`). This blocking mechanism should only be set for when a stagger
        //animation is detected and when the element item index is greater than 0.
        if(animationDuration > 0 && stagger.animationDelay > 0 && stagger.animationDuration === 0) {
          blockKeyframeAnimations(element);
        }

        return true;
      }

      function isStructuralAnimation(className) {
        return className == 'ng-enter' || className == 'ng-move' || className == 'ng-leave';
      }

      function blockTransitions(element, className, isAnimating) {
        if(isStructuralAnimation(className) || !isAnimating) {
          extractElementNode(element).style[TRANSITION_PROP + PROPERTY_KEY] = 'none';
        } else {
          element.addClass(NG_ANIMATE_BLOCK_CLASS_NAME);
        }
      }

      function blockKeyframeAnimations(element) {
        extractElementNode(element).style[ANIMATION_PROP] = 'none 0s';
      }

      function unblockTransitions(element, className) {
        var prop = TRANSITION_PROP + PROPERTY_KEY;
        var node = extractElementNode(element);
        if(node.style[prop] && node.style[prop].length > 0) {
          node.style[prop] = '';
        }
        element.removeClass(NG_ANIMATE_BLOCK_CLASS_NAME);
      }

      function unblockKeyframeAnimations(element) {
        var prop = ANIMATION_PROP;
        var node = extractElementNode(element);
        if(node.style[prop] && node.style[prop].length > 0) {
          node.style[prop] = '';
        }
      }

      function animateRun(animationEvent, element, className, activeAnimationComplete) {
        var node = extractElementNode(element);
        var elementData = element.data(NG_ANIMATE_CSS_DATA_KEY);
        if(node.getAttribute('class').indexOf(className) == -1 || !elementData) {
          activeAnimationComplete();
          return;
        }

        var activeClassName = '';
        forEach(className.split(' '), function(klass, i) {
          activeClassName += (i > 0 ? ' ' : '') + klass + '-active';
        });

        var stagger = elementData.stagger;
        var timings = elementData.timings;
        var itemIndex = elementData.itemIndex;
        var maxDuration = Math.max(timings.transitionDuration, timings.animationDuration);
        var maxDelay = Math.max(timings.transitionDelay, timings.animationDelay);
        var maxDelayTime = maxDelay * ONE_SECOND;

        var startTime = Date.now();
        var css3AnimationEvents = ANIMATIONEND_EVENT + ' ' + TRANSITIONEND_EVENT;

        var style = '', appliedStyles = [];
        if(timings.transitionDuration > 0) {
          var propertyStyle = timings.transitionPropertyStyle;
          if(propertyStyle.indexOf('all') == -1) {
            style += CSS_PREFIX + 'transition-property: ' + propertyStyle + ';';
            style += CSS_PREFIX + 'transition-duration: ' + timings.transitionDurationStyle + ';';
            appliedStyles.push(CSS_PREFIX + 'transition-property');
            appliedStyles.push(CSS_PREFIX + 'transition-duration');
          }
        }

        if(itemIndex > 0) {
          if(stagger.transitionDelay > 0 && stagger.transitionDuration === 0) {
            var delayStyle = timings.transitionDelayStyle;
            style += CSS_PREFIX + 'transition-delay: ' +
                     prepareStaggerDelay(delayStyle, stagger.transitionDelay, itemIndex) + '; ';
            appliedStyles.push(CSS_PREFIX + 'transition-delay');
          }

          if(stagger.animationDelay > 0 && stagger.animationDuration === 0) {
            style += CSS_PREFIX + 'animation-delay: ' +
                     prepareStaggerDelay(timings.animationDelayStyle, stagger.animationDelay, itemIndex) + '; ';
            appliedStyles.push(CSS_PREFIX + 'animation-delay');
          }
        }

        if(appliedStyles.length > 0) {
          //the element being animated may sometimes contain comment nodes in
          //the jqLite object, so we're safe to use a single variable to house
          //the styles since there is always only one element being animated
          var oldStyle = node.getAttribute('style') || '';
          node.setAttribute('style', oldStyle + ' ' + style);
        }

        element.on(css3AnimationEvents, onAnimationProgress);
        element.addClass(activeClassName);
        elementData.closeAnimationFn = function() {
          onEnd();
          activeAnimationComplete();
        };

        var staggerTime       = itemIndex * (Math.max(stagger.animationDelay, stagger.transitionDelay) || 0);
        var animationTime     = (maxDelay + maxDuration) * CLOSING_TIME_BUFFER;
        var totalTime         = (staggerTime + animationTime) * ONE_SECOND;

        elementData.running++;
        animationCloseHandler(element, totalTime);
        return onEnd;

        // This will automatically be called by $animate so
        // there is no need to attach this internally to the
        // timeout done method.
        function onEnd(cancelled) {
          element.off(css3AnimationEvents, onAnimationProgress);
          element.removeClass(activeClassName);
          animateClose(element, className);
          var node = extractElementNode(element);
          for (var i in appliedStyles) {
            node.style.removeProperty(appliedStyles[i]);
          }
        }

        function onAnimationProgress(event) {
          event.stopPropagation();
          var ev = event.originalEvent || event;
          var timeStamp = ev.$manualTimeStamp || ev.timeStamp || Date.now();

          /* Firefox (or possibly just Gecko) likes to not round values up
           * when a ms measurement is used for the animation */
          var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));

          /* $manualTimeStamp is a mocked timeStamp value which is set
           * within browserTrigger(). This is only here so that tests can
           * mock animations properly. Real events fallback to event.timeStamp,
           * or, if they don't, then a timeStamp is automatically created for them.
           * We're checking to see if the timeStamp surpasses the expected delay,
           * but we're using elapsedTime instead of the timeStamp on the 2nd
           * pre-condition since animations sometimes close off early */
          if(Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {
            activeAnimationComplete();
          }
        }
      }

      function prepareStaggerDelay(delayStyle, staggerDelay, index) {
        var style = '';
        forEach(delayStyle.split(','), function(val, i) {
          style += (i > 0 ? ',' : '') +
                   (index * staggerDelay + parseInt(val, 10)) + 's';
        });
        return style;
      }

      function animateBefore(animationEvent, element, className, calculationDecorator) {
        if(animateSetup(animationEvent, element, className, calculationDecorator)) {
          return function(cancelled) {
            cancelled && animateClose(element, className);
          };
        }
      }

      function animateAfter(animationEvent, element, className, afterAnimationComplete) {
        if(element.data(NG_ANIMATE_CSS_DATA_KEY)) {
          return animateRun(animationEvent, element, className, afterAnimationComplete);
        } else {
          animateClose(element, className);
          afterAnimationComplete();
        }
      }

      function animate(animationEvent, element, className, animationComplete) {
        //If the animateSetup function doesn't bother returning a
        //cancellation function then it means that there is no animation
        //to perform at all
        var preReflowCancellation = animateBefore(animationEvent, element, className);
        if(!preReflowCancellation) {
          animationComplete();
          return;
        }

        //There are two cancellation functions: one is before the first
        //reflow animation and the second is during the active state
        //animation. The first function will take care of removing the
        //data from the element which will not make the 2nd animation
        //happen in the first place
        var cancel = preReflowCancellation;
        afterReflow(element, function() {
          unblockTransitions(element, className);
          unblockKeyframeAnimations(element);
          //once the reflow is complete then we point cancel to
          //the new cancellation function which will remove all of the
          //animation properties from the active animation
          cancel = animateAfter(animationEvent, element, className, animationComplete);
        });

        return function(cancelled) {
          (cancel || noop)(cancelled);
        };
      }

      function animateClose(element, className) {
        element.removeClass(className);
        var data = element.data(NG_ANIMATE_CSS_DATA_KEY);
        if(data) {
          if(data.running) {
            data.running--;
          }
          if(!data.running || data.running === 0) {
            element.removeData(NG_ANIMATE_CSS_DATA_KEY);
          }
        }
      }

      return {
        enter : function(element, animationCompleted) {
          return animate('enter', element, 'ng-enter', animationCompleted);
        },

        leave : function(element, animationCompleted) {
          return animate('leave', element, 'ng-leave', animationCompleted);
        },

        move : function(element, animationCompleted) {
          return animate('move', element, 'ng-move', animationCompleted);
        },

        beforeSetClass : function(element, add, remove, animationCompleted) {
          var className = suffixClasses(remove, '-remove') + ' ' +
                          suffixClasses(add, '-add');
          var cancellationMethod = animateBefore('setClass', element, className, function(fn) {
            /* when classes are removed from an element then the transition style
             * that is applied is the transition defined on the element without the
             * CSS class being there. This is how CSS3 functions outside of ngAnimate.
             * http://plnkr.co/edit/j8OzgTNxHTb4n3zLyjGW?p=preview */
            var klass = element.attr('class');
            element.removeClass(remove);
            element.addClass(add);
            var timings = fn();
            element.attr('class', klass);
            return timings;
          });

          if(cancellationMethod) {
            afterReflow(element, function() {
              unblockTransitions(element, className);
              unblockKeyframeAnimations(element);
              animationCompleted();
            });
            return cancellationMethod;
          }
          animationCompleted();
        },

        beforeAddClass : function(element, className, animationCompleted) {
          var cancellationMethod = animateBefore('addClass', element, suffixClasses(className, '-add'), function(fn) {

            /* when a CSS class is added to an element then the transition style that
             * is applied is the transition defined on the element when the CSS class
             * is added at the time of the animation. This is how CSS3 functions
             * outside of ngAnimate. */
            element.addClass(className);
            var timings = fn();
            element.removeClass(className);
            return timings;
          });

          if(cancellationMethod) {
            afterReflow(element, function() {
              unblockTransitions(element, className);
              unblockKeyframeAnimations(element);
              animationCompleted();
            });
            return cancellationMethod;
          }
          animationCompleted();
        },

        setClass : function(element, add, remove, animationCompleted) {
          remove = suffixClasses(remove, '-remove');
          add = suffixClasses(add, '-add');
          var className = remove + ' ' + add;
          return animateAfter('setClass', element, className, animationCompleted);
        },

        addClass : function(element, className, animationCompleted) {
          return animateAfter('addClass', element, suffixClasses(className, '-add'), animationCompleted);
        },

        beforeRemoveClass : function(element, className, animationCompleted) {
          var cancellationMethod = animateBefore('removeClass', element, suffixClasses(className, '-remove'), function(fn) {
            /* when classes are removed from an element then the transition style
             * that is applied is the transition defined on the element without the
             * CSS class being there. This is how CSS3 functions outside of ngAnimate.
             * http://plnkr.co/edit/j8OzgTNxHTb4n3zLyjGW?p=preview */
            var klass = element.attr('class');
            element.removeClass(className);
            var timings = fn();
            element.attr('class', klass);
            return timings;
          });

          if(cancellationMethod) {
            afterReflow(element, function() {
              unblockTransitions(element, className);
              unblockKeyframeAnimations(element);
              animationCompleted();
            });
            return cancellationMethod;
          }
          animationCompleted();
        },

        removeClass : function(element, className, animationCompleted) {
          return animateAfter('removeClass', element, suffixClasses(className, '-remove'), animationCompleted);
        }
      };

      function suffixClasses(classes, suffix) {
        var className = '';
        classes = angular.isArray(classes) ? classes : classes.split(/\s+/);
        forEach(classes, function(klass, i) {
          if(klass && klass.length > 0) {
            className += (i > 0 ? ' ' : '') + klass + suffix;
          }
        });
        return className;
      }
    }]);
  }]);


})(window, window.angular);
/**
 * @license AngularJS v1.1.5
 * (c) 2010-2012 Google, Inc. http://angularjs.org
 * License: MIT
 */
(function(window, angular, undefined) {
'use strict';

/**
 * @ngdoc overview
 * @name ngResource
 * @description
 */

/**
 * @ngdoc object
 * @name ngResource.$resource
 * @requires $http
 *
 * @description
 * A factory which creates a resource object that lets you interact with
 * [RESTful](http://en.wikipedia.org/wiki/Representational_State_Transfer) server-side data sources.
 *
 * The returned resource object has action methods which provide high-level behaviors without
 * the need to interact with the low level {@link ng.$http $http} service.
 *
 * # Installation
 * To use $resource make sure you have included the `angular-resource.js` that comes in Angular
 * package. You can also find this file on Google CDN, bower as well as at
 * {@link http://code.angularjs.org/ code.angularjs.org}.
 *
 * Finally load the module in your application:
 *
 *        angular.module('app', ['ngResource']);
 *
 * and you are ready to get started!
 *
 * @param {string} url A parametrized URL template with parameters prefixed by `:` as in
 *   `/user/:username`. If you are using a URL with a port number (e.g.
 *   `http://example.com:8080/api`), you'll need to escape the colon character before the port
 *   number, like this: `$resource('http://example.com\\:8080/api')`.
 *
 *   If you are using a url with a suffix, just add the suffix, like this:
 *   `$resource('http://example.com/resource.json')` or `$resource('http://example.com/:id.json')
 *   or even `$resource('http://example.com/resource/:resource_id.:format')`
 *   If the parameter before the suffix is empty, :resource_id in this case, then the `/.` will be
 *   collapsed down to a single `.`.  If you need this sequence to appear and not collapse then you
 *   can escape it with `/\.`.
 *
 * @param {Object=} paramDefaults Default values for `url` parameters. These can be overridden in
 *   `actions` methods. If any of the parameter value is a function, it will be executed every time
 *   when a param value needs to be obtained for a request (unless the param was overridden).
 *
 *   Each key value in the parameter object is first bound to url template if present and then any
 *   excess keys are appended to the url search query after the `?`.
 *
 *   Given a template `/path/:verb` and parameter `{verb:'greet', salutation:'Hello'}` results in
 *   URL `/path/greet?salutation=Hello`.
 *
 *   If the parameter value is prefixed with `@` then the value of that parameter is extracted from
 *   the data object (useful for non-GET operations).
 *
 * @param {Object.<Object>=} actions Hash with declaration of custom action that should extend the
 *   default set of resource actions. The declaration should be created in the format of {@link
 *   ng.$http#Parameters $http.config}:
 *
 *       {action1: {method:?, params:?, isArray:?, headers:?, ...},
 *        action2: {method:?, params:?, isArray:?, headers:?, ...},
 *        ...}
 *
 *   Where:
 *
 *   - **`action`** â€“ {string} â€“ The name of action. This name becomes the name of the method on your
 *     resource object.
 *   - **`method`** â€“ {string} â€“ HTTP request method. Valid methods are: `GET`, `POST`, `PUT`, `DELETE`,
 *     and `JSONP`.
 *   - **`params`** â€“ {Object=} â€“ Optional set of pre-bound parameters for this action. If any of the
 *     parameter value is a function, it will be executed every time when a param value needs to be
 *     obtained for a request (unless the param was overridden).
 *   - **`url`** â€“ {string} â€“ action specific `url` override. The url templating is supported just like
 *     for the resource-level urls.
 *   - **`isArray`** â€“ {boolean=} â€“ If true then the returned object for this action is an array, see
 *     `returns` section.
 *   - **`transformRequest`** â€“ `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` â€“
 *     transform function or an array of such functions. The transform function takes the http
 *     request body and headers and returns its transformed (typically serialized) version.
 *   - **`transformResponse`** â€“ `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` â€“
 *     transform function or an array of such functions. The transform function takes the http
 *     response body and headers and returns its transformed (typically deserialized) version.
 *   - **`cache`** â€“ `{boolean|Cache}` â€“ If true, a default $http cache will be used to cache the
 *     GET request, otherwise if a cache instance built with
 *     {@link ng.$cacheFactory $cacheFactory}, this cache will be used for
 *     caching.
 *   - **`timeout`** â€“ `{number|Promise}` â€“ timeout in milliseconds, or {@link ng.$q promise} that
 *     should abort the request when resolved.
 *   - **`withCredentials`** - `{boolean}` - whether to to set the `withCredentials` flag on the
 *     XHR object. See {@link https://developer.mozilla.org/en/http_access_control#section_5
 *     requests with credentials} for more information.
 *   - **`responseType`** - `{string}` - see {@link
 *     https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#responseType requestType}.
 *
 * @returns {Object} A resource "class" object with methods for the default set of resource actions
 *   optionally extended with custom `actions`. The default set contains these actions:
 *
 *       { 'get':    {method:'GET'},
 *         'save':   {method:'POST'},
 *         'query':  {method:'GET', isArray:true},
 *         'remove': {method:'DELETE'},
 *         'delete': {method:'DELETE'} };
 *
 *   Calling these methods invoke an {@link ng.$http} with the specified http method,
 *   destination and parameters. When the data is returned from the server then the object is an
 *   instance of the resource class. The actions `save`, `remove` and `delete` are available on it
 *   as  methods with the `$` prefix. This allows you to easily perform CRUD operations (create,
 *   read, update, delete) on server-side data like this:
 *   <pre>
        var User = $resource('/user/:userId', {userId:'@id'});
        var user = User.get({userId:123}, function() {
          user.abc = true;
          user.$save();
        });
     </pre>
 *
 *   It is important to realize that invoking a $resource object method immediately returns an
 *   empty reference (object or array depending on `isArray`). Once the data is returned from the
 *   server the existing reference is populated with the actual data. This is a useful trick since
 *   usually the resource is assigned to a model which is then rendered by the view. Having an empty
 *   object results in no rendering, once the data arrives from the server then the object is
 *   populated with the data and the view automatically re-renders itself showing the new data. This
 *   means that in most case one never has to write a callback function for the action methods.
 *
 *   The action methods on the class object or instance object can be invoked with the following
 *   parameters:
 *
 *   - HTTP GET "class" actions: `Resource.action([parameters], [success], [error])`
 *   - non-GET "class" actions: `Resource.action([parameters], postData, [success], [error])`
 *   - non-GET instance actions:  `instance.$action([parameters], [success], [error])`
 *
 *
 *   The Resource instances and collection have these additional properties:
 *
 *   - `$then`: the `then` method of a {@link ng.$q promise} derived from the underlying
 *     {@link ng.$http $http} call.
 *
 *     The success callback for the `$then` method will be resolved if the underlying `$http` requests
 *     succeeds.
 *
 *     The success callback is called with a single object which is the {@link ng.$http http response}
 *     object extended with a new property `resource`. This `resource` property is a reference to the
 *     result of the resource action â€” resource object or array of resources.
 *
 *     The error callback is called with the {@link ng.$http http response} object when an http
 *     error occurs.
 *
 *   - `$resolved`: true if the promise has been resolved (either with success or rejection);
 *     Knowing if the Resource has been resolved is useful in data-binding.
 *
 * @example
 *
 * # Credit card resource
 *
 * <pre>
     // Define CreditCard class
     var CreditCard = $resource('/user/:userId/card/:cardId',
      {userId:123, cardId:'@id'}, {
       charge: {method:'POST', params:{charge:true}}
      });

     // We can retrieve a collection from the server
     var cards = CreditCard.query(function() {
       // GET: /user/123/card
       // server returns: [ {id:456, number:'1234', name:'Smith'} ];

       var card = cards[0];
       // each item is an instance of CreditCard
       expect(card instanceof CreditCard).toEqual(true);
       card.name = "J. Smith";
       // non GET methods are mapped onto the instances
       card.$save();
       // POST: /user/123/card/456 {id:456, number:'1234', name:'J. Smith'}
       // server returns: {id:456, number:'1234', name: 'J. Smith'};

       // our custom method is mapped as well.
       card.$charge({amount:9.99});
       // POST: /user/123/card/456?amount=9.99&charge=true {id:456, number:'1234', name:'J. Smith'}
     });

     // we can create an instance as well
     var newCard = new CreditCard({number:'0123'});
     newCard.name = "Mike Smith";
     newCard.$save();
     // POST: /user/123/card {number:'0123', name:'Mike Smith'}
     // server returns: {id:789, number:'01234', name: 'Mike Smith'};
     expect(newCard.id).toEqual(789);
 * </pre>
 *
 * The object returned from this function execution is a resource "class" which has "static" method
 * for each action in the definition.
 *
 * Calling these methods invoke `$http` on the `url` template with the given `method`, `params` and `headers`.
 * When the data is returned from the server then the object is an instance of the resource type and
 * all of the non-GET methods are available with `$` prefix. This allows you to easily support CRUD
 * operations (create, read, update, delete) on server-side data.

   <pre>
     var User = $resource('/user/:userId', {userId:'@id'});
     var user = User.get({userId:123}, function() {
       user.abc = true;
       user.$save();
     });
   </pre>
 *
 * It's worth noting that the success callback for `get`, `query` and other method gets passed
 * in the response that came from the server as well as $http header getter function, so one
 * could rewrite the above example and get access to http headers as:
 *
   <pre>
     var User = $resource('/user/:userId', {userId:'@id'});
     User.get({userId:123}, function(u, getResponseHeaders){
       u.abc = true;
       u.$save(function(u, putResponseHeaders) {
         //u => saved user object
         //putResponseHeaders => $http header getter
       });
     });
   </pre>

 * # Buzz client

   Let's look at what a buzz client created with the `$resource` service looks like:
    <doc:example>
      <doc:source jsfiddle="false">
       <script>
         function BuzzController($resource) {
           this.userId = 'googlebuzz';
           this.Activity = $resource(
             'https://www.googleapis.com/buzz/v1/activities/:userId/:visibility/:activityId/:comments',
             {alt:'json', callback:'JSON_CALLBACK'},
             {get:{method:'JSONP', params:{visibility:'@self'}}, replies: {method:'JSONP', params:{visibility:'@self', comments:'@comments'}}}
           );
         }

         BuzzController.prototype = {
           fetch: function() {
             this.activities = this.Activity.get({userId:this.userId});
           },
           expandReplies: function(activity) {
             activity.replies = this.Activity.replies({userId:this.userId, activityId:activity.id});
           }
         };
         BuzzController.$inject = ['$resource'];
       </script>

       <div ng-controller="BuzzController">
         <input ng-model="userId"/>
         <button ng-click="fetch()">fetch</button>
         <hr/>
         <div ng-repeat="item in activities.data.items">
           <h1 style="font-size: 15px;">
             <img src="{{item.actor.thumbnailUrl}}" style="max-height:30px;max-width:30px;"/>
             <a href="{{item.actor.profileUrl}}">{{item.actor.name}}</a>
             <a href ng-click="expandReplies(item)" style="float: right;">Expand replies: {{item.links.replies[0].count}}</a>
           </h1>
           {{item.object.content | html}}
           <div ng-repeat="reply in item.replies.data.items" style="margin-left: 20px;">
             <img src="{{reply.actor.thumbnailUrl}}" style="max-height:30px;max-width:30px;"/>
             <a href="{{reply.actor.profileUrl}}">{{reply.actor.name}}</a>: {{reply.content | html}}
           </div>
         </div>
       </div>
      </doc:source>
      <doc:scenario>
      </doc:scenario>
    </doc:example>
 */
angular.module('ngResource', ['ng']).
  factory('$resource', ['$http', '$parse', function($http, $parse) {
    var DEFAULT_ACTIONS = {
      'get':    {method:'GET'},
      'save':   {method:'POST'},
      'query':  {method:'GET', isArray:true},
      'remove': {method:'DELETE'},
      'delete': {method:'DELETE'}
    };
    var noop = angular.noop,
        forEach = angular.forEach,
        extend = angular.extend,
        copy = angular.copy,
        isFunction = angular.isFunction,
        getter = function(obj, path) {
          return $parse(path)(obj);
        };

    /**
     * We need our custom method because encodeURIComponent is too aggressive and doesn't follow
     * http://www.ietf.org/rfc/rfc3986.txt with regards to the character set (pchar) allowed in path
     * segments:
     *    segment       = *pchar
     *    pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
     *    pct-encoded   = "%" HEXDIG HEXDIG
     *    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
     *    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
     *                     / "*" / "+" / "," / ";" / "="
     */
    function encodeUriSegment(val) {
      return encodeUriQuery(val, true).
        replace(/%26/gi, '&').
        replace(/%3D/gi, '=').
        replace(/%2B/gi, '+');
    }


    /**
     * This method is intended for encoding *key* or *value* parts of query component. We need a custom
     * method because encodeURIComponent is too aggressive and encodes stuff that doesn't have to be
     * encoded per http://tools.ietf.org/html/rfc3986:
     *    query       = *( pchar / "/" / "?" )
     *    pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
     *    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
     *    pct-encoded   = "%" HEXDIG HEXDIG
     *    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
     *                     / "*" / "+" / "," / ";" / "="
     */
    function encodeUriQuery(val, pctEncodeSpaces) {
      return encodeURIComponent(val).
        replace(/%40/gi, '@').
        replace(/%3A/gi, ':').
        replace(/%24/g, '$').
        replace(/%2C/gi, ',').
        replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));
    }

    function Route(template, defaults) {
      this.template = template;
      this.defaults = defaults || {};
      this.urlParams = {};
    }

    Route.prototype = {
      setUrlParams: function(config, params, actionUrl) {
        var self = this,
            url = actionUrl || self.template,
            val,
            encodedVal;

        var urlParams = self.urlParams = {};
        forEach(url.split(/\W/), function(param){
          if (param && (new RegExp("(^|[^\\\\]):" + param + "(\\W|$)").test(url))) {
              urlParams[param] = true;
          }
        });
        url = url.replace(/\\:/g, ':');

        params = params || {};
        forEach(self.urlParams, function(_, urlParam){
          val = params.hasOwnProperty(urlParam) ? params[urlParam] : self.defaults[urlParam];
          if (angular.isDefined(val) && val !== null) {
            encodedVal = encodeUriSegment(val);
            url = url.replace(new RegExp(":" + urlParam + "(\\W|$)", "g"), encodedVal + "$1");
          } else {
            url = url.replace(new RegExp("(\/?):" + urlParam + "(\\W|$)", "g"), function(match,
                leadingSlashes, tail) {
              if (tail.charAt(0) == '/') {
                return tail;
              } else {
                return leadingSlashes + tail;
              }
            });
          }
        });

        // strip trailing slashes and set the url
        url = url.replace(/\/+$/, '');
        // then replace collapse `/.` if found in the last URL path segment before the query
        // E.g. `http://url.com/id./format?q=x` becomes `http://url.com/id.format?q=x`
        url = url.replace(/\/\.(?=\w+($|\?))/, '.');
        // replace escaped `/\.` with `/.`
        config.url = url.replace(/\/\\\./, '/.');


        // set params - delegate param encoding to $http
        forEach(params, function(value, key){
          if (!self.urlParams[key]) {
            config.params = config.params || {};
            config.params[key] = value;
          }
        });
      }
    };


    function ResourceFactory(url, paramDefaults, actions) {
      var route = new Route(url);

      actions = extend({}, DEFAULT_ACTIONS, actions);

      function extractParams(data, actionParams){
        var ids = {};
        actionParams = extend({}, paramDefaults, actionParams);
        forEach(actionParams, function(value, key){
          if (isFunction(value)) { value = value(); }
          ids[key] = value && value.charAt && value.charAt(0) == '@' ? getter(data, value.substr(1)) : value;
        });
        return ids;
      }

      function Resource(value){
        copy(value || {}, this);
      }

      forEach(actions, function(action, name) {
        action.method = angular.uppercase(action.method);
        var hasBody = action.method == 'POST' || action.method == 'PUT' || action.method == 'PATCH';
        Resource[name] = function(a1, a2, a3, a4) {
          var params = {};
          var data;
          var success = noop;
          var error = null;
          var promise;

          switch(arguments.length) {
          case 4:
            error = a4;
            success = a3;
            //fallthrough
          case 3:
          case 2:
            if (isFunction(a2)) {
              if (isFunction(a1)) {
                success = a1;
                error = a2;
                break;
              }

              success = a2;
              error = a3;
              //fallthrough
            } else {
              params = a1;
              data = a2;
              success = a3;
              break;
            }
          case 1:
            if (isFunction(a1)) success = a1;
            else if (hasBody) data = a1;
            else params = a1;
            break;
          case 0: break;
          default:
            throw "Expected between 0-4 arguments [params, data, success, error], got " +
              arguments.length + " arguments.";
          }

          var value = this instanceof Resource ? this : (action.isArray ? [] : new Resource(data));
          var httpConfig = {},
              promise;

          forEach(action, function(value, key) {
            if (key != 'params' && key != 'isArray' ) {
              httpConfig[key] = copy(value);
            }
          });
          httpConfig.data = data;
          route.setUrlParams(httpConfig, extend({}, extractParams(data, action.params || {}), params), action.url);

          function markResolved() { value.$resolved = true; }

          promise = $http(httpConfig);
          value.$resolved = false;

          promise.then(markResolved, markResolved);
          value.$then = promise.then(function(response) {
            var data = response.data;
            var then = value.$then, resolved = value.$resolved;

            if (data) {
              if (action.isArray) {
                value.length = 0;
                forEach(data, function(item) {
                  value.push(new Resource(item));
                });
              } else {
                copy(data, value);
                value.$then = then;
                value.$resolved = resolved;
              }
            }

            (success||noop)(value, response.headers);

            response.resource = value;
            return response;
          }, error).then;

          return value;
        };


        Resource.prototype['$' + name] = function(a1, a2, a3) {
          var params = extractParams(this),
              success = noop,
              error;

          switch(arguments.length) {
          case 3: params = a1; success = a2; error = a3; break;
          case 2:
          case 1:
            if (isFunction(a1)) {
              success = a1;
              error = a2;
            } else {
              params = a1;
              success = a2 || noop;
            }
          case 0: break;
          default:
            throw "Expected between 1-3 arguments [params, success, error], got " +
              arguments.length + " arguments.";
          }
          var data = hasBody ? this : undefined;
          Resource[name].call(this, params, data, success, error);
        };
      });

      Resource.bind = function(additionalParamDefaults){
        return ResourceFactory(url, extend({}, paramDefaults, additionalParamDefaults), actions);
      };

      return Resource;
    }

    return ResourceFactory;
  }]);


})(window, window.angular);
/**
 * @license AngularJS v1.2.16
 * (c) 2010-2014 Google, Inc. http://angularjs.org
 * License: MIT
 */
(function(window, angular, undefined) {
    'use strict';

    var $sanitizeMinErr = angular.$$minErr('$sanitize');

    /**
     * @ngdoc module
     * @name ngSanitize
     * @description
     *
     * # ngSanitize
     *
     * The `ngSanitize` module provides functionality to sanitize HTML.
     *
     *
     * <div doc-module-components="ngSanitize"></div>
     *
     * See {@link ngSanitize.$sanitize `$sanitize`} for usage.
     */

    /*
     * HTML Parser By Misko Hevery (misko@hevery.com)
     * based on:  HTML Parser By John Resig (ejohn.org)
     * Original code by Erik Arvidsson, Mozilla Public License
     * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
     *
     * // Use like so:
     * htmlParser(htmlString, {
     *     start: function(tag, attrs, unary) {},
     *     end: function(tag) {},
     *     chars: function(text) {},
     *     comment: function(text) {}
     * });
     *
     */


    /**
 * @ngdoc service
 * @name $sanitize
 * @function
 *
 * @description
 *   The input is sanitized by parsing the html into tokens. All safe tokens (from a whitelist) are
 *   then serialized back to properly escaped html string. This means that no unsafe input can make
 *   it into the returned string, however, since our parser is more strict than a typical browser
 *   parser, it's possible that some obscure input, which would be recognized as valid HTML by a
 *   browser, won't make it through the sanitizer.
 *   The whitelist is configured using the functions `aHrefSanitizationWhitelist` and
 *   `imgSrcSanitizationWhitelist` of {@link ng.$compileProvider `$compileProvider`}.
 *
 * @param {string} html Html input.
 * @returns {string} Sanitized html.
 *
 * @example
   <example module="ngSanitize" deps="angular-sanitize.js">
   <file name="index.html">
     <script>
       function Ctrl($scope, $sce) {
         $scope.snippet =
           '<p style="color:blue">an html\n' +
           '<em onmouseover="this.textContent=\'PWN3D!\'">click here</em>\n' +
           'snippet</p>';
         $scope.deliberatelyTrustDangerousSnippet = function() {
           return $sce.trustAsHtml($scope.snippet);
         };
       }
     </script>
     <div ng-controller="Ctrl">
        Snippet: <textarea ng-model="snippet" cols="60" rows="3"></textarea>
       <table>
         <tr>
           <td>Directive</td>
           <td>How</td>
           <td>Source</td>
           <td>Rendered</td>
         </tr>
         <tr id="bind-html-with-sanitize">
           <td>ng-bind-html</td>
           <td>Automatically uses $sanitize</td>
           <td><pre>&lt;div ng-bind-html="snippet"&gt;<br/>&lt;/div&gt;</pre></td>
           <td><div ng-bind-html="snippet"></div></td>
         </tr>
         <tr id="bind-html-with-trust">
           <td>ng-bind-html</td>
           <td>Bypass $sanitize by explicitly trusting the dangerous value</td>
           <td>
           <pre>&lt;div ng-bind-html="deliberatelyTrustDangerousSnippet()"&gt;
&lt;/div&gt;</pre>
           </td>
           <td><div ng-bind-html="deliberatelyTrustDangerousSnippet()"></div></td>
         </tr>
         <tr id="bind-default">
           <td>ng-bind</td>
           <td>Automatically escapes</td>
           <td><pre>&lt;div ng-bind="snippet"&gt;<br/>&lt;/div&gt;</pre></td>
           <td><div ng-bind="snippet"></div></td>
         </tr>
       </table>
       </div>
   </file>
   <file name="protractor.js" type="protractor">
     it('should sanitize the html snippet by default', function() {
       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).
         toBe('<p>an html\n<em>click here</em>\nsnippet</p>');
     });

     it('should inline raw snippet if bound to a trusted value', function() {
       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).
         toBe("<p style=\"color:blue\">an html\n" +
              "<em onmouseover=\"this.textContent='PWN3D!'\">click here</em>\n" +
              "snippet</p>");
     });

     it('should escape snippet without any filter', function() {
       expect(element(by.css('#bind-default div')).getInnerHtml()).
         toBe("&lt;p style=\"color:blue\"&gt;an html\n" +
              "&lt;em onmouseover=\"this.textContent='PWN3D!'\"&gt;click here&lt;/em&gt;\n" +
              "snippet&lt;/p&gt;");
     });

     it('should update', function() {
       element(by.model('snippet')).clear();
       element(by.model('snippet')).sendKeys('new <b onclick="alert(1)">text</b>');
       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).
         toBe('new <b>text</b>');
       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).toBe(
         'new <b onclick="alert(1)">text</b>');
       expect(element(by.css('#bind-default div')).getInnerHtml()).toBe(
         "new &lt;b onclick=\"alert(1)\"&gt;text&lt;/b&gt;");
     });
   </file>
   </example>
 */
    function $SanitizeProvider() {
        this.$get = ['$$sanitizeUri',
            function($$sanitizeUri) {
                return function(html) {
                    var buf = [];
                    htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {
                        return !/^unsafe/.test($$sanitizeUri(uri, isImage));
                    }));
                    return buf.join('');
                };
            }
        ];
    }

    function sanitizeText(chars) {
        var buf = [];
        var writer = htmlSanitizeWriter(buf, angular.noop);
        writer.chars(chars);
        return buf.join('');
    }


    // Regular Expressions for parsing tags and attributes
    var START_TAG_REGEXP =
        /^<\s*([\w:-]+)((?:\s+[\w:-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)\s*>/,
        END_TAG_REGEXP = /^<\s*\/\s*([\w:-]+)[^>]*>/,
        ATTR_REGEXP = /([\w:-]+)(?:\s*=\s*(?:(?:"((?:[^"])*)")|(?:'((?:[^'])*)')|([^>\s]+)))?/g,
        BEGIN_TAG_REGEXP = /^</,
        BEGING_END_TAGE_REGEXP = /^<\s*\//,
        COMMENT_REGEXP = /<!--(.*?)-->/g,
        DOCTYPE_REGEXP = /<!DOCTYPE([^>]*?)>/i,
        CDATA_REGEXP = /<!\[CDATA\[(.*?)]]>/g,
        // Match everything outside of normal chars and " (quote character)
        NON_ALPHANUMERIC_REGEXP = /([^\#-~| |!])/g;


    // Good source of info about elements and attributes
    // http://dev.w3.org/html5/spec/Overview.html#semantics
    // http://simon.html5.org/html-elements

    // Safe Void Elements - HTML5
    // http://dev.w3.org/html5/spec/Overview.html#void-elements
    var voidElements = makeMap("area,br,col,hr,img,wbr");

    // Elements that you can, intentionally, leave open (and which close themselves)
    // http://dev.w3.org/html5/spec/Overview.html#optional-tags
    var optionalEndTagBlockElements = makeMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
        optionalEndTagInlineElements = makeMap("rp,rt"),
        optionalEndTagElements = angular.extend({},
            optionalEndTagInlineElements,
            optionalEndTagBlockElements);

    // Safe Block Elements - HTML5
    var blockElements = angular.extend({}, optionalEndTagBlockElements, makeMap("address,article," +
        "aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5," +
        "h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul"));

    // Inline Elements - HTML5
    var inlineElements = angular.extend({}, optionalEndTagInlineElements, makeMap("a,abbr,acronym,b," +
        "bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s," +
        "samp,small,span,strike,strong,sub,sup,time,tt,u,var"));


    // Special Elements (can contain anything)
    var specialElements = makeMap("script,style");

    var validElements = angular.extend({},
        voidElements,
        blockElements,
        inlineElements,
        optionalEndTagElements);

    //Attributes that have href and hence need to be sanitized
    var uriAttrs = makeMap("background,cite,href,longdesc,src,usemap");
    var validAttrs = angular.extend({}, uriAttrs, makeMap(
        'abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' +
        'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' +
        'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' +
        'scope,scrolling,shape,size,span,start,summary,target,title,type,' +
        'valign,value,vspace,width'));

    function makeMap(str) {
        var obj = {},
            items = str.split(','),
            i;
        for (i = 0; i < items.length; i++) obj[items[i]] = true;
        return obj;
    }


    /**
     * @example
     * htmlParser(htmlString, {
     *     start: function(tag, attrs, unary) {},
     *     end: function(tag) {},
     *     chars: function(text) {},
     *     comment: function(text) {}
     * });
     *
     * @param {string} html string
     * @param {object} handler
     */
    function htmlParser(html, handler) {
        var index, chars, match, stack = [],
            last = html;
        stack.last = function() {
            return stack[stack.length - 1];
        };

        while (html) {
            chars = true;

            // Make sure we're not in a script or style element
            if (!stack.last() || !specialElements[stack.last()]) {

                // Comment
                if (html.indexOf("<!--") === 0) {
                    // comments containing -- are not allowed unless they terminate the comment
                    index = html.indexOf("--", 4);

                    if (index >= 0 && html.lastIndexOf("-->", index) === index) {
                        if (handler.comment) handler.comment(html.substring(4, index));
                        html = html.substring(index + 3);
                        chars = false;
                    }
                    // DOCTYPE
                } else if (DOCTYPE_REGEXP.test(html)) {
                    match = html.match(DOCTYPE_REGEXP);

                    if (match) {
                        html = html.replace(match[0], '');
                        chars = false;
                    }
                    // end tag
                } else if (BEGING_END_TAGE_REGEXP.test(html)) {
                    match = html.match(END_TAG_REGEXP);

                    if (match) {
                        html = html.substring(match[0].length);
                        match[0].replace(END_TAG_REGEXP, parseEndTag);
                        chars = false;
                    }

                    // start tag
                } else if (BEGIN_TAG_REGEXP.test(html)) {
                    match = html.match(START_TAG_REGEXP);

                    if (match) {
                        html = html.substring(match[0].length);
                        match[0].replace(START_TAG_REGEXP, parseStartTag);
                        chars = false;
                    }
                }

                if (chars) {
                    index = html.indexOf("<");

                    var text = index < 0 ? html : html.substring(0, index);
                    html = index < 0 ? "" : html.substring(index);

                    if (handler.chars) handler.chars(decodeEntities(text));
                }

            } else {
                html = html.replace(new RegExp("(.*)<\\s*\\/\\s*" + stack.last() + "[^>]*>", 'i'),
                    function(all, text) {
                        text = text.replace(COMMENT_REGEXP, "$1").replace(CDATA_REGEXP, "$1");

                        if (handler.chars) handler.chars(decodeEntities(text));

                        return "";
                    });

                parseEndTag("", stack.last());
            }

            if (html == last) {
                throw $sanitizeMinErr('badparse', "The sanitizer was unable to parse the following block " +
                    "of html: {0}", html);
            }
            last = html;
        }

        // Clean up any remaining tags
        parseEndTag();

        function parseStartTag(tag, tagName, rest, unary) {
            tagName = angular.lowercase(tagName);
            if (blockElements[tagName]) {
                while (stack.last() && inlineElements[stack.last()]) {
                    parseEndTag("", stack.last());
                }
            }

            if (optionalEndTagElements[tagName] && stack.last() == tagName) {
                parseEndTag("", tagName);
            }

            unary = voidElements[tagName] || !!unary;

            if (!unary)
                stack.push(tagName);

            var attrs = {};

            rest.replace(ATTR_REGEXP,
                function(match, name, doubleQuotedValue, singleQuotedValue, unquotedValue) {
                    var value = doubleQuotedValue || singleQuotedValue || unquotedValue || '';

                    attrs[name] = decodeEntities(value);
                });
            if (handler.start) handler.start(tagName, attrs, unary);
        }

        function parseEndTag(tag, tagName) {
            var pos = 0,
                i;
            tagName = angular.lowercase(tagName);
            if (tagName)
            // Find the closest opened tag of the same type
                for (pos = stack.length - 1; pos >= 0; pos--)
                if (stack[pos] == tagName)
                    break;

            if (pos >= 0) {
                // Close all the open elements, up the stack
                for (i = stack.length - 1; i >= pos; i--)
                    if (handler.end) handler.end(stack[i]);

                    // Remove the open elements from the stack
                stack.length = pos;
            }
        }
    }

    var hiddenPre = document.createElement("pre");
    var spaceRe = /^(\s*)([\s\S]*?)(\s*)$/;
    /**
     * decodes all entities into regular string
     * @param value
     * @returns {string} A string with decoded entities.
     */
    function decodeEntities(value) {
        if (!value) {
            return '';
        }

        // Note: IE8 does not preserve spaces at the start/end of innerHTML
        // so we must capture them and reattach them afterward
        var parts = spaceRe.exec(value);
        var spaceBefore = parts[1];
        var spaceAfter = parts[3];
        var content = parts[2];
        if (content) {
            hiddenPre.innerHTML = content.replace(/</g, "&lt;");
            // innerText depends on styling as it doesn't display hidden elements.
            // Therefore, it's better to use textContent not to cause unnecessary
            // reflows. However, IE<9 don't support textContent so the innerText
            // fallback is necessary.
            content = 'textContent' in hiddenPre ?
                hiddenPre.textContent : hiddenPre.innerText;
        }
        return spaceBefore + content + spaceAfter;
    }

    /**
     * Escapes all potentially dangerous characters, so that the
     * resulting string can be safely inserted into attribute or
     * element text.
     * @param value
     * @returns {string} escaped text
     */
    function encodeEntities(value) {
        return value.
        replace(/&/g, '&amp;').
        replace(NON_ALPHANUMERIC_REGEXP, function(value) {
            return '&#' + value.charCodeAt(0) + ';';
        }).
        replace(/</g, '&lt;').
        replace(/>/g, '&gt;');
    }

    /**
     * create an HTML/XML writer which writes to buffer
     * @param {Array} buf use buf.jain('') to get out sanitized html string
     * @returns {object} in the form of {
     *     start: function(tag, attrs, unary) {},
     *     end: function(tag) {},
     *     chars: function(text) {},
     *     comment: function(text) {}
     * }
     */
    function htmlSanitizeWriter(buf, uriValidator) {
        var ignore = false;
        var out = angular.bind(buf, buf.push);
        return {
            start: function(tag, attrs, unary) {
                tag = angular.lowercase(tag);
                if (!ignore && specialElements[tag]) {
                    ignore = tag;
                }
                if (!ignore && validElements[tag] === true) {
                    out('<');
                    out(tag);
                    angular.forEach(attrs, function(value, key) {
                        var lkey = angular.lowercase(key);
                        var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');
                        if (validAttrs[lkey] === true &&
                            (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {
                            out(' ');
                            out(key);
                            out('="');
                            out(encodeEntities(value));
                            out('"');
                        }
                    });
                    out(unary ? '/>' : '>');
                }
            },
            end: function(tag) {
                tag = angular.lowercase(tag);
                if (!ignore && validElements[tag] === true) {
                    out('</');
                    out(tag);
                    out('>');
                }
                if (tag == ignore) {
                    ignore = false;
                }
            },
            chars: function(chars) {
                if (!ignore) {
                    out(encodeEntities(chars));
                }
            }
        };
    }


    // define ngSanitize module and register $sanitize service
    angular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);

    /* global sanitizeText: false */

    /**
 * @ngdoc filter
 * @name linky
 * @function
 *
 * @description
 * Finds links in text input and turns them into html links. Supports http/https/ftp/mailto and
 * plain email address links.
 *
 * Requires the {@link ngSanitize `ngSanitize`} module to be installed.
 *
 * @param {string} text Input text.
 * @param {string} target Window (_blank|_self|_parent|_top) or named frame to open links in.
 * @returns {string} Html-linkified text.
 *
 * @usage
   <span ng-bind-html="linky_expression | linky"></span>
 *
 * @example
   <example module="ngSanitize" deps="angular-sanitize.js">
     <file name="index.html">
       <script>
         function Ctrl($scope) {
           $scope.snippet =
             'Pretty text with some links:\n'+
             'http://angularjs.org/,\n'+
             'mailto:us@somewhere.org,\n'+
             'another@somewhere.org,\n'+
             'and one more: ftp://127.0.0.1/.';
           $scope.snippetWithTarget = 'http://angularjs.org/';
         }
       </script>
       <div ng-controller="Ctrl">
       Snippet: <textarea ng-model="snippet" cols="60" rows="3"></textarea>
       <table>
         <tr>
           <td>Filter</td>
           <td>Source</td>
           <td>Rendered</td>
         </tr>
         <tr id="linky-filter">
           <td>linky filter</td>
           <td>
             <pre>&lt;div ng-bind-html="snippet | linky"&gt;<br>&lt;/div&gt;</pre>
           </td>
           <td>
             <div ng-bind-html="snippet | linky"></div>
           </td>
         </tr>
         <tr id="linky-target">
          <td>linky target</td>
          <td>
            <pre>&lt;div ng-bind-html="snippetWithTarget | linky:'_blank'"&gt;<br>&lt;/div&gt;</pre>
          </td>
          <td>
            <div ng-bind-html="snippetWithTarget | linky:'_blank'"></div>
          </td>
         </tr>
         <tr id="escaped-html">
           <td>no filter</td>
           <td><pre>&lt;div ng-bind="snippet"&gt;<br>&lt;/div&gt;</pre></td>
           <td><div ng-bind="snippet"></div></td>
         </tr>
       </table>
     </file>
     <file name="protractor.js" type="protractor">
       it('should linkify the snippet with urls', function() {
         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).
             toBe('Pretty text with some links: http://angularjs.org/, us@somewhere.org, ' +
                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');
         expect(element.all(by.css('#linky-filter a')).count()).toEqual(4);
       });

       it('should not linkify snippet without the linky filter', function() {
         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText()).
             toBe('Pretty text with some links: http://angularjs.org/, mailto:us@somewhere.org, ' +
                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');
         expect(element.all(by.css('#escaped-html a')).count()).toEqual(0);
       });

       it('should update', function() {
         element(by.model('snippet')).clear();
         element(by.model('snippet')).sendKeys('new http://link.');
         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).
             toBe('new http://link.');
         expect(element.all(by.css('#linky-filter a')).count()).toEqual(1);
         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText())
             .toBe('new http://link.');
       });

       it('should work with the target property', function() {
        expect(element(by.id('linky-target')).
            element(by.binding("snippetWithTarget | linky:'_blank'")).getText()).
            toBe('http://angularjs.org/');
        expect(element(by.css('#linky-target a')).getAttribute('target')).toEqual('_blank');
       });
     </file>
   </example>
 */
    angular.module('ngSanitize').filter('linky', ['$sanitize',
        function($sanitize) {
            var LINKY_URL_REGEXP =
                /((ftp|https?):\/\/|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>]/,
                MAILTO_REGEXP = /^mailto:/;

            return function(text, target) {
                if (!text) return text;
                var match;
                var raw = text;
                var html = [];
                var url;
                var i;
                while ((match = raw.match(LINKY_URL_REGEXP))) {
                    // We can not end in these as they are sometimes found at the end of the sentence
                    url = match[0];
                    // if we did not match ftp/http/mailto then assume mailto
                    if (match[2] == match[3]) url = 'mailto:' + url;
                    i = match.index;
                    addText(raw.substr(0, i));
                    addLink(url, match[0].replace(MAILTO_REGEXP, ''));
                    raw = raw.substring(i + match[0].length);
                }
                addText(raw);
                return $sanitize(html.join(''));

                function addText(text) {
                    if (!text) {
                        return;
                    }
                    html.push(sanitizeText(text));
                }

                function addLink(url, text) {
                    html.push('<a ');
                    if (angular.isDefined(target)) {
                        html.push('target="');
                        html.push(target);
                        html.push('" ');
                    }
                    html.push('href="');
                    html.push(url);
                    html.push('">');
                    addText(text);
                    html.push('</a>');
                }
            };
        }
    ]);


})(window, window.angular);
/**
 * angular-once - one time bindings for AngularJS
 * @version v0.1.7
 * @link https://github.com/tadeuszwojcik/angular-once
 * @author Tadeusz Wójcik <tadeuszwojcik@gmail.com>
 * @license WTFPL License, https://github.com/tadeuszwojcik/angular-once/blob/master/LICENSE.txt
 */

(function (window, angular, undefined) {
  'use strict';

  function setOneTimeBinding($scope, element, watch, watcherParser, bindingParser, done) {
    // get value to watch
    var watchingValue = watcherParser($scope);
    // if we have a valid value, render the binding's value
    if (watchingValue !== undefined) {
      // if watching and binding $parsers are the same, use watching's value, else $parse the new value
      return done(element, watcherParser == bindingParser ? watchingValue : bindingParser($scope));
    }

    // we do not have a valid value, so we register a $watch
    var watcherRemover = $scope.$watch(watch, function (newValue) {
      // wait until we have a valid value
      if (newValue == undefined) return;
      // remove this $watch
      removeWatcher();
      // if watching and binding $parsers are the same, use watching's value, else $parse the new value
      return done(element, watcherParser == bindingParser ? newValue : bindingParser($scope));
    });

    function removeWatcher() {
      if (watcherRemover) {
        watcherRemover();
      }
    }

    $scope.$on("$destroy", removeWatcher);
  }

  var once = angular.module('once', []);

  function makeBindingDirective(definition) {
    once.directive(definition.name, ['$parse', function ($parse) {
      return {
        priority: definition.priority || 0,
        link: function ($scope, element, attrs) {
          var watch = attrs.onceWaitFor || attrs[definition.name];
          var watcherParser = $parse(watch);
          var bindingParser = attrs.onceWaitFor ? $parse(attrs[definition.name]) : watcherParser;
          setOneTimeBinding($scope, element, watch, watcherParser, bindingParser, definition.binding);
        }
      };
    }]);
  }

  var bindingsDefinitions = [
    {
      name: 'onceText',
      binding: function (element, value) {
        element.text(value !== null ? value : "");
      }
    },
    {
      name: 'onceHtml',
      binding: function (element, value) {
        element.html(value);
      }
    },
    {
      name: 'onceSrc',
      priority: 99,
      binding: function (element, value) {
        element.attr('src', value);
      }
    },
    {
      name: 'onceHref',
      priority: 99,
      binding: function (element, value) {
        element.attr('href', value);
      }
    },
    {
      name: 'onceTitle',
      binding: function (element, value) {
        element.attr('title', value);
      }
    },
    {
      name: 'onceAlt',
      binding: function (element, value) {
        element.attr('alt', value);
      }
    },
    {
      name: 'onceId',
      binding: function (element, value) {
        element.attr('id', value);
      }
    },
    {
      name: 'onceIf',
      priority: 600,
      binding: function (element, value) {
        if (!value) {
          element.remove();
        }
      }
    },
    {
      name: 'onceClass',
      binding: function (element, value) {
        if (angular.isObject(value) && !angular.isArray(value)) {
          var results = [];
          angular.forEach(value, function (val, index) {
            if (val) results.push(index);
          });
          value = results;
        }
        if (value) {
          element.addClass(angular.isArray(value) ? value.join(' ') : value);
        }
      }
    },
    {
      name: 'onceStyle',
      binding: function (element, value) {
        element.css(value);
      }
    },
    {
      name: 'onceShow',
      binding: function (element, value) {
        if (value) {
          element.css('display', '');
        } else {
          element.css('display', 'none');
        }
      }
    },
    {
      name: 'onceHide',
      binding: function (element, value) {
        if (value) {
          element.css('display', 'none');
        } else {
          element.css('display', '');
        }
      }
    }
  ];

  angular.forEach(bindingsDefinitions, makeBindingDirective);

  once.directive('once', ['$parse', function ($parse) {
      return function ($scope, element, attrs) {
          angular.forEach(attrs, function (attr, attrName) {
              if (!/^onceAttr[A-Z]/.test(attrName)) return;
              var watch = attrs.onceWaitFor || attrs[attrName];
              var watcherParser = $parse(watch);
              var bindingParser = attrs.onceWaitFor ? $parse(attrs[attrName]) : watcherParser;
              var binding = function (element,value) {
                  var dashedName = attrName.replace(/[A-Z]/g, function (match) { return '-' + match.toLowerCase(); });
                  var name = dashedName.substr(10);

                  element.attr(name, value);
              }
              setOneTimeBinding($scope, element, watch, watcherParser, bindingParser, binding);
          });
      };
  }]);

})(window, window.angular);

/**
 * angular-translate - v1.1.1 - 2013-11-24
 * http://github.com/PascalPrecht/angular-translate
 * Copyright (c) 2013 ; Licensed
 */
angular.module('pascalprecht.translate', ['ng']).run([
  '$translate',
  function ($translate) {
    var key = $translate.storageKey(), storage = $translate.storage();
    if (storage) {
      if (!storage.get(key)) {
        if (angular.isString($translate.preferredLanguage())) {
          $translate.uses($translate.preferredLanguage());
        } else {
          storage.set(key, $translate.uses());
        }
      } else {
        $translate.uses(storage.get(key));
      }
    } else if (angular.isString($translate.preferredLanguage())) {
      $translate.uses($translate.preferredLanguage());
    }
  }
]);
angular.module('pascalprecht.translate').provider('$translate', [
  '$STORAGE_KEY',
  function ($STORAGE_KEY) {
    var $translationTable = {}, $preferredLanguage, $fallbackLanguage, $uses, $nextLang, $storageFactory, $storageKey = $STORAGE_KEY, $storagePrefix, $missingTranslationHandlerFactory, $interpolationFactory, $interpolatorFactories = [], $loaderFactory, $loaderOptions, $notFoundIndicatorLeft, $notFoundIndicatorRight, NESTED_OBJECT_DELIMITER = '.';
    var translations = function (langKey, translationTable) {
      if (!langKey && !translationTable) {
        return $translationTable;
      }
      if (langKey && !translationTable) {
        if (angular.isString(langKey)) {
          return $translationTable[langKey];
        } else {
          angular.extend($translationTable, flatObject(langKey));
        }
      } else {
        if (!angular.isObject($translationTable[langKey])) {
          $translationTable[langKey] = {};
        }
        angular.extend($translationTable[langKey], flatObject(translationTable));
      }
      return this;
    };
    var flatObject = function (data, path, result, prevKey) {
      var key, keyWithPath, val;
      if (!path) {
        path = [];
      }
      if (!result) {
        result = {};
      }
      for (key in data) {
        if (!data.hasOwnProperty(key))
          continue;
        val = data[key];
        if (angular.isObject(val)) {
          flatObject(val, path.concat(key), result, key);
        } else {
          keyWithPath = path.length ? '' + path.join(NESTED_OBJECT_DELIMITER) + NESTED_OBJECT_DELIMITER + key : key;
          if (path.length && key === prevKey) {
            keyWithShortPath = '' + path.join(NESTED_OBJECT_DELIMITER);
            result[keyWithShortPath] = '@:' + keyWithPath;
          }
          result[keyWithPath] = val;
        }
      }
      return result;
    };
    this.translations = translations;
    this.addInterpolation = function (factory) {
      $interpolatorFactories.push(factory);
      return this;
    };
    this.useMessageFormatInterpolation = function () {
      return this.useInterpolation('$translateMessageFormatInterpolation');
    };
    this.useInterpolation = function (factory) {
      $interpolationFactory = factory;
      return this;
    };
    this.preferredLanguage = function (langKey) {
      if (langKey) {
        $preferredLanguage = langKey;
        return this;
      } else {
        return $preferredLanguage;
      }
    };
    this.translationNotFoundIndicator = function (indicator) {
      this.translationNotFoundIndicatorLeft(indicator);
      this.translationNotFoundIndicatorRight(indicator);
      return this;
    };
    this.translationNotFoundIndicatorLeft = function (indicator) {
      if (!indicator) {
        return $notFoundIndicatorLeft;
      }
      $notFoundIndicatorLeft = indicator;
      return this;
    };
    this.translationNotFoundIndicatorRight = function (indicator) {
      if (!indicator) {
        return $notFoundIndicatorRight;
      }
      $notFoundIndicatorRight = indicator;
      return this;
    };
    this.fallbackLanguage = function (langKey) {
      if (langKey) {
        if (typeof langKey === 'string' || angular.isArray(langKey)) {
          $fallbackLanguage = langKey;
        } else {
        }
        return this;
      } else {
        return $fallbackLanguage;
      }
    };
    this.uses = function (langKey) {
      if (langKey) {
        if (!$translationTable[langKey] && !$loaderFactory) {
          throw new Error('$translateProvider couldn\'t find translationTable for langKey: \'' + langKey + '\'');
        }
        $uses = langKey;
        return this;
      } else {
        return $uses;
      }
    };
    var storageKey = function (key) {
      if (!key) {
        if ($storagePrefix) {
          return $storagePrefix + $storageKey;
        }
        return $storageKey;
      }
      $storageKey = key;
    };
    this.storageKey = storageKey;
    this.useUrlLoader = function (url) {
      return this.useLoader('$translateUrlLoader', { url: url });
    };
    this.useStaticFilesLoader = function (options) {
      return this.useLoader('$translateStaticFilesLoader', options);
    };
    this.useLoader = function (loaderFactory, options) {
      $loaderFactory = loaderFactory;
      $loaderOptions = options || {};
      return this;
    };
    this.useLocalStorage = function () {
      return this.useStorage('$translateLocalStorage');
    };
    this.useCookieStorage = function () {
      return this.useStorage('$translateCookieStorage');
    };
    this.useStorage = function (storageFactory) {
      $storageFactory = storageFactory;
      return this;
    };
    this.storagePrefix = function (prefix) {
      if (!prefix) {
        return prefix;
      }
      $storagePrefix = prefix;
      return this;
    };
    this.useMissingTranslationHandlerLog = function () {
      return this.useMissingTranslationHandler('$translateMissingTranslationHandlerLog');
    };
    this.useMissingTranslationHandler = function (factory) {
      $missingTranslationHandlerFactory = factory;
      return this;
    };
    this.$get = [
      '$log',
      '$injector',
      '$rootScope',
      '$q',
      function ($log, $injector, $rootScope, $q) {
        var Storage, defaultInterpolator = $injector.get($interpolationFactory || '$translateDefaultInterpolation'), pendingLoader = false, interpolatorHashMap = {};
        var loadAsync = function (key) {
          if (!key) {
            throw 'No language key specified for loading.';
          }
          var deferred = $q.defer();
          $rootScope.$broadcast('$translateLoadingStart');
          pendingLoader = true;
          $injector.get($loaderFactory)(angular.extend($loaderOptions, { key: key })).then(function (data) {
            $rootScope.$broadcast('$translateLoadingSuccess');
            var translationTable = {};
            if (angular.isArray(data)) {
              angular.forEach(data, function (table) {
                angular.extend(translationTable, table);
              });
            } else {
              angular.extend(translationTable, data);
            }
            pendingLoader = false;
            deferred.resolve({
              key: key,
              table: translationTable
            });
            $rootScope.$broadcast('$translateLoadingEnd');
          }, function (key) {
            $rootScope.$broadcast('$translateLoadingError');
            deferred.reject(key);
            $rootScope.$broadcast('$translateLoadingEnd');
          });
          return deferred.promise;
        };
        if ($storageFactory) {
          Storage = $injector.get($storageFactory);
          if (!Storage.get || !Storage.set) {
            throw new Error('Couldn\'t use storage \'' + $storageFactory + '\', missing get() or set() method!');
          }
        }
        if ($interpolatorFactories.length > 0) {
          angular.forEach($interpolatorFactories, function (interpolatorFactory) {
            var interpolator = $injector.get(interpolatorFactory);
            interpolator.setLocale($preferredLanguage || $uses);
            interpolatorHashMap[interpolator.getInterpolationIdentifier()] = interpolator;
          });
        }
        var checkValidFallback = function (usesLang) {
          if (usesLang && $fallbackLanguage) {
            if (angular.isArray($fallbackLanguage)) {
              var fallbackLanguagesSize = $fallbackLanguage.length;
              for (var current = 0; current < fallbackLanguagesSize; current++) {
                if ($uses === $translationTable[$fallbackLanguage[current]]) {
                  return false;
                }
              }
              return true;
            } else {
              return usesLang !== $fallbackLanguage;
            }
          } else {
            return false;
          }
          return false;
        };
        var $translate = function (translationId, interpolateParams, interpolationId) {
          var table = $uses ? $translationTable[$uses] : $translationTable, Interpolator = interpolationId ? interpolatorHashMap[interpolationId] : defaultInterpolator;
          if (table && table.hasOwnProperty(translationId)) {
            if (angular.isString(table[translationId]) && table[translationId].substr(0, 2) === '@:') {
              return $translate(table[translationId].substr(2), interpolateParams, interpolationId);
            }
            return Interpolator.interpolate(table[translationId], interpolateParams);
          }
          if ($missingTranslationHandlerFactory && !pendingLoader) {
            $injector.get($missingTranslationHandlerFactory)(translationId, $uses);
          }
          var normatedLanguages;
          if ($uses && $fallbackLanguage && checkValidFallback($uses)) {
            if (typeof $fallbackLanguage === 'string') {
              normatedLanguages = [];
              normatedLanguages.push($fallbackLanguage);
            } else {
              normatedLanguages = $fallbackLanguage;
            }
            var fallbackLanguagesSize = normatedLanguages.length;
            for (var current = 0; current < fallbackLanguagesSize; current++) {
              if ($uses !== $translationTable[normatedLanguages[current]]) {
                var translationFromList = $translationTable[normatedLanguages[current]][translationId];
                if (translationFromList) {
                  var returnValFromList;
                  Interpolator.setLocale(normatedLanguages[current]);
                  returnValFromList = Interpolator.interpolate(translationFromList, interpolateParams);
                  Interpolator.setLocale($uses);
                  return returnValFromList;
                }
              }
            }
          }
          if ($notFoundIndicatorLeft) {
            translationId = [
              $notFoundIndicatorLeft,
              translationId
            ].join(' ');
          }
          if ($notFoundIndicatorRight) {
            translationId = [
              translationId,
              $notFoundIndicatorRight
            ].join(' ');
          }
          return translationId;
        };
        $translate.preferredLanguage = function () {
          return $preferredLanguage;
        };
        $translate.fallbackLanguage = function () {
          return $fallbackLanguage;
        };
        $translate.proposedLanguage = function () {
          return $nextLang;
        };
        $translate.storage = function () {
          return Storage;
        };
        $translate.uses = function (key) {
          if (!key) {
            return $uses;
          }
          var deferred = $q.defer();
          $rootScope.$broadcast('$translateChangeStart');
          function useLanguage(key) {
            $uses = key;
            $rootScope.$broadcast('$translateChangeSuccess');
            if ($storageFactory) {
              Storage.set($translate.storageKey(), $uses);
            }
            defaultInterpolator.setLocale($uses);
            angular.forEach(interpolatorHashMap, function (interpolator, id) {
              interpolatorHashMap[id].setLocale($uses);
            });
            deferred.resolve(key);
            $rootScope.$broadcast('$translateChangeEnd');
          }
          if (!$translationTable[key] && $loaderFactory) {
            $nextLang = key;
            loadAsync(key).then(function (translation) {
              $nextLang = undefined;
              translations(translation.key, translation.table);
              useLanguage(translation.key);
            }, function (key) {
              $nextLang = undefined;
              $rootScope.$broadcast('$translateChangeError');
              deferred.reject(key);
              $rootScope.$broadcast('$translateChangeEnd');
            });
          } else {
            useLanguage(key);
          }
          return deferred.promise;
        };
        $translate.storageKey = function () {
          return storageKey();
        };
        $translate.refresh = function (langKey) {
          if (!$loaderFactory) {
            throw new Error('Couldn\'t refresh translation table, no loader registered!');
          }
          var deferred = $q.defer();
          function onLoadSuccess() {
            deferred.resolve();
            $rootScope.$broadcast('$translateRefreshEnd');
          }
          function onLoadFailure() {
            deferred.reject();
            $rootScope.$broadcast('$translateRefreshEnd');
          }
          if (!langKey) {
            $rootScope.$broadcast('$translateRefreshStart');
            var loaders = [];
            if ($fallbackLanguage) {
              if (typeof $fallbackLanguage === 'string') {
                loaders.push(loadAsync($fallbackLanguage));
              } else {
                var fallbackLanguagesSize = $fallbackLanguage.length;
                for (var current = 0; current < fallbackLanguagesSize; current++) {
                  loaders.push(loadAsync($fallbackLanguage[current]));
                }
              }
            }
            if ($uses) {
              loaders.push(loadAsync($uses));
            }
            if (loaders.length > 0) {
              $q.all(loaders).then(function (newTranslations) {
                for (var lang in $translationTable) {
                  if ($translationTable.hasOwnProperty(lang)) {
                    delete $translationTable[lang];
                  }
                }
                for (var i = 0, len = newTranslations.length; i < len; i++) {
                  translations(newTranslations[i].key, newTranslations[i].table);
                }
                if ($uses) {
                  $translate.uses($uses);
                }
                onLoadSuccess();
              }, function (key) {
                if (key === $uses) {
                  $rootScope.$broadcast('$translateChangeError');
                }
                onLoadFailure();
              });
            } else
              onLoadSuccess();
          } else if ($translationTable.hasOwnProperty(langKey)) {
            $rootScope.$broadcast('$translateRefreshStart');
            var loader = loadAsync(langKey);
            if (langKey === $uses) {
              loader.then(function (newTranslation) {
                $translationTable[langKey] = newTranslation.table;
                $translate.uses($uses);
                onLoadSuccess();
              }, function () {
                $rootScope.$broadcast('$translateChangeError');
                onLoadFailure();
              });
            } else {
              loader.then(function (newTranslation) {
                $translationTable[langKey] = newTranslation.table;
                onLoadSuccess();
              }, onLoadFailure);
            }
          } else
            deferred.reject();
          return deferred.promise;
        };
        if ($loaderFactory) {
          if (angular.equals($translationTable, {})) {
            $translate.uses($translate.uses());
          }
          if ($fallbackLanguage) {
            if (typeof $fallbackLanguage === 'string' && !$translationTable[$fallbackLanguage]) {
              loadAsync($fallbackLanguage);
            } else {
              var fallbackLanguagesSize = $fallbackLanguage.length;
              for (var current = 0; current < fallbackLanguagesSize; current++) {
                if (!$translationTable[$fallbackLanguage[current]]) {
                  loadAsync($fallbackLanguage[current]);
                }
              }
            }
          }
        }
        return $translate;
      }
    ];
  }
]);
angular.module('pascalprecht.translate').factory('$translateDefaultInterpolation', [
  '$interpolate',
  function ($interpolate) {
    var $translateInterpolator = {}, $locale, $identifier = 'default';
    $translateInterpolator.setLocale = function (locale) {
      $locale = locale;
    };
    $translateInterpolator.getInterpolationIdentifier = function () {
      return $identifier;
    };
    $translateInterpolator.interpolate = function (string, interpolateParams) {
      return $interpolate(string)(interpolateParams);
    };
    return $translateInterpolator;
  }
]);
angular.module('pascalprecht.translate').constant('$STORAGE_KEY', 'NG_TRANSLATE_LANG_KEY');
angular.module('pascalprecht.translate').directive('translate', [
  '$filter',
  '$interpolate',
  '$parse',
  function ($filter, $interpolate, $parse) {
    var translate = $filter('translate');
    return {
      restrict: 'AE',
      scope: true,
      link: function linkFn(scope, element, attr) {
        if (attr.translateInterpolation) {
          scope.interpolation = attr.translateInterpolation;
        }
        attr.$observe('translate', function (translationId) {
          if (angular.equals(translationId, '') || translationId === undefined) {
            scope.translationId = $interpolate(element.text().replace(/^\s+|\s+$/g, ''))(scope.$parent);
          } else {
            scope.translationId = translationId;
          }
        });
        attr.$observe('translateValues', function (interpolateParams) {
          if (interpolateParams)
            scope.$parent.$watch(function () {
              scope.interpolateParams = $parse(interpolateParams)(scope.$parent);
            });
        });
        scope.$on('$translateChangeSuccess', function () {
          element.html(translate(scope.translationId, scope.interpolateParams, scope.interpolation));
        });
        scope.$watch('[translationId, interpolateParams]', function (nValue) {
          if (scope.translationId) {
            element.html(translate(scope.translationId, scope.interpolateParams, scope.interpolation));
          }
        }, true);
      }
    };
  }
]);
angular.module('pascalprecht.translate').filter('translate', [
  '$parse',
  '$translate',
  function ($parse, $translate) {
    return function (translationId, interpolateParams, interpolation) {
      if (!angular.isObject(interpolateParams)) {
        interpolateParams = $parse(interpolateParams)();
      }
      return $translate(translationId, interpolateParams, interpolation);
    };
  }
]);
/**
 * angular-re-captcha v.X.X.X
 * https://github.com/mllrsohn/angular-re-captcha
 */
angular.module('reCAPTCHA', []).provider('reCAPTCHA', function() {
    var _publicKey = null,
        _options = {},
        self = this;

    this.setPublicKey = function(publicKey) {
        _publicKey = publicKey;
    };

    this.setOptions = function(options) {
        _options = options;
    };

    this._createScript = function($document, callback) {
        var scriptTag = $document.createElement('script');
        scriptTag.type = 'text/javascript';
        scriptTag.async = true;
        scriptTag.src = '//www.google.com/recaptcha/api/js/recaptcha_ajax.js';
        scriptTag.onreadystatechange = function() {
            if (this.readyState == 'complete') {
                callback();
            }
        };
        scriptTag.onload = callback;
        var s = $document.getElementsByTagName('body')[0];
        s.appendChild(scriptTag);
    };

    this.$get = ['$q', '$rootScope', '$window', '$document', function($q, $rootScope, $window, $document) {
        var deferred = $q.defer();

        if (!$window.Recaptcha) {
            self._createScript($document[0], deferred.resolve);
        } else {
            deferred.resolve();
        }

        return {
            create: function(element, callback) {
                if (!_publicKey) {
                    throw new Error('Please provide your PublicKey via setPublicKey');
                }
                _options.callback = callback;

                deferred.promise.then(function() {
                    $window.Recaptcha.create(
                        _publicKey,
                        element,
                        _options
                    );
                });
            },
            response: function() {
                return $window.Recaptcha.get_response();
            },
            challenge: function() {
                return $window.Recaptcha.get_challenge();
            },
            reload: function() {
                return $window.Recaptcha.reload();
            },
            destroy: function() {
                $window.Recaptcha.destroy();
            }
        };
    }];

}).directive('reCaptcha', ['reCAPTCHA', '$compile', function(reCAPTCHA, $compile) {
    return {
        restrict: 'A',
        require: 'ngModel',
        scope: {
            ngModel: '='
        },
        link: function(scope, element, attrs, controller) {
            var name = attrs.name || 'reCaptcha';
            scope.clear = function() {
                scope.ngModel = {
                    response: '',
                    challenge: false
                };
            };

            // Create reCAPTCHA
            reCAPTCHA.create(element[0], function() {

                // Reset on Start
                scope.clear();

                // watch if challenge changes
                scope.$watch(function() {
                    return reCAPTCHA.challenge();
                }, function (newValue) {
                    scope.ngModel.challenge = newValue;
                });

                // Attach model and click handler
                $compile(angular.element(document.querySelector('input#recaptcha_response_field')).attr('required', ''))(scope);
                $compile(angular.element(document.querySelector('input#recaptcha_response_field')).attr('ng-model', 'ngModel.response'))(scope);
                $compile(angular.element(document.querySelector('a#recaptcha_reload_btn')).attr('ng-click', 'clear()'))(scope);

            });

            // Destroy Element
            scope.$on('$destroy', reCAPTCHA.destroy);
        }
    };
}]);
/*
 * angular-ui-bootstrap
 * http://angular-ui.github.io/bootstrap/

 * Version: 0.11.0 - 2014-05-01
 * License: MIT
 */
angular.module("ui.bootstrap", ["ui.bootstrap.tpls", "ui.bootstrap.transition","ui.bootstrap.collapse","ui.bootstrap.accordion","ui.bootstrap.alert","ui.bootstrap.bindHtml","ui.bootstrap.buttons","ui.bootstrap.carousel","ui.bootstrap.dateparser","ui.bootstrap.position","ui.bootstrap.datepicker","ui.bootstrap.dropdown","ui.bootstrap.modal","ui.bootstrap.pagination","ui.bootstrap.progressbar","ui.bootstrap.rating","ui.bootstrap.tabs","ui.bootstrap.timepicker","ui.bootstrap.typeahead"]);
angular.module("ui.bootstrap.tpls", ["template/accordion/accordion-group.html","template/accordion/accordion.html","template/alert/alert.html","template/carousel/carousel.html","template/carousel/slide.html","template/datepicker/datepicker.html","template/datepicker/day.html","template/datepicker/month.html","template/datepicker/popup.html","template/datepicker/year.html","template/modal/backdrop.html","template/modal/window.html","template/pagination/pager.html","template/pagination/pagination.html","template/progressbar/bar.html","template/progressbar/progress.html","template/progressbar/progressbar.html","template/rating/rating.html","template/tabs/tab.html","template/tabs/tabset.html","template/timepicker/timepicker.html","template/typeahead/typeahead-match.html","template/typeahead/typeahead-popup.html"]);
angular.module('ui.bootstrap.transition', [])

/**
 * $transition service provides a consistent interface to trigger CSS 3 transitions and to be informed when they complete.
 * @param  {DOMElement} element  The DOMElement that will be animated.
 * @param  {string|object|function} trigger  The thing that will cause the transition to start:
 *   - As a string, it represents the css class to be added to the element.
 *   - As an object, it represents a hash of style attributes to be applied to the element.
 *   - As a function, it represents a function to be called that will cause the transition to occur.
 * @return {Promise}  A promise that is resolved when the transition finishes.
 */
.factory('$transition', ['$q', '$timeout', '$rootScope', function($q, $timeout, $rootScope) {

  var $transition = function(element, trigger, options) {
    options = options || {};
    var deferred = $q.defer();
    var endEventName = $transition[options.animation ? 'animationEndEventName' : 'transitionEndEventName'];

    var transitionEndHandler = function(event) {
      $rootScope.$apply(function() {
        element.unbind(endEventName, transitionEndHandler);
        deferred.resolve(element);
      });
    };

    if (endEventName) {
      element.bind(endEventName, transitionEndHandler);
    }

    // Wrap in a timeout to allow the browser time to update the DOM before the transition is to occur
    $timeout(function() {
      if ( angular.isString(trigger) ) {
        element.addClass(trigger);
      } else if ( angular.isFunction(trigger) ) {
        trigger(element);
      } else if ( angular.isObject(trigger) ) {
        element.css(trigger);
      }
      //If browser does not support transitions, instantly resolve
      if ( !endEventName ) {
        deferred.resolve(element);
      }
    });

    // Add our custom cancel function to the promise that is returned
    // We can call this if we are about to run a new transition, which we know will prevent this transition from ending,
    // i.e. it will therefore never raise a transitionEnd event for that transition
    deferred.promise.cancel = function() {
      if ( endEventName ) {
        element.unbind(endEventName, transitionEndHandler);
      }
      deferred.reject('Transition cancelled');
    };

    return deferred.promise;
  };

  // Work out the name of the transitionEnd event
  var transElement = document.createElement('trans');
  var transitionEndEventNames = {
    'WebkitTransition': 'webkitTransitionEnd',
    'MozTransition': 'transitionend',
    'OTransition': 'oTransitionEnd',
    'transition': 'transitionend'
  };
  var animationEndEventNames = {
    'WebkitTransition': 'webkitAnimationEnd',
    'MozTransition': 'animationend',
    'OTransition': 'oAnimationEnd',
    'transition': 'animationend'
  };
  function findEndEventName(endEventNames) {
    for (var name in endEventNames){
      if (transElement.style[name] !== undefined) {
        return endEventNames[name];
      }
    }
  }
  $transition.transitionEndEventName = findEndEventName(transitionEndEventNames);
  $transition.animationEndEventName = findEndEventName(animationEndEventNames);
  return $transition;
}]);

angular.module('ui.bootstrap.collapse', ['ui.bootstrap.transition'])

  .directive('collapse', ['$transition', function ($transition) {

    return {
      link: function (scope, element, attrs) {

        var initialAnimSkip = true;
        var currentTransition;

        function doTransition(change) {
          var newTransition = $transition(element, change);
          if (currentTransition) {
            currentTransition.cancel();
          }
          currentTransition = newTransition;
          newTransition.then(newTransitionDone, newTransitionDone);
          return newTransition;

          function newTransitionDone() {
            // Make sure it's this transition, otherwise, leave it alone.
            if (currentTransition === newTransition) {
              currentTransition = undefined;
            }
          }
        }

        function expand() {
          if (initialAnimSkip) {
            initialAnimSkip = false;
            expandDone();
          } else {
            element.removeClass('collapse').addClass('collapsing');
            doTransition({ height: element[0].scrollHeight + 'px' }).then(expandDone);
          }
        }

        function expandDone() {
          element.removeClass('collapsing');
          element.addClass('collapse in');
          element.css({height: 'auto'});
        }

        function collapse() {
          if (initialAnimSkip) {
            initialAnimSkip = false;
            collapseDone();
            element.css({height: 0});
          } else {
            // CSS transitions don't work with height: auto, so we have to manually change the height to a specific value
            element.css({ height: element[0].scrollHeight + 'px' });
            //trigger reflow so a browser realizes that height was updated from auto to a specific value
            var x = element[0].offsetWidth;

            element.removeClass('collapse in').addClass('collapsing');

            doTransition({ height: 0 }).then(collapseDone);
          }
        }

        function collapseDone() {
          element.removeClass('collapsing');
          element.addClass('collapse');
        }

        scope.$watch(attrs.collapse, function (shouldCollapse) {
          if (shouldCollapse) {
            collapse();
          } else {
            expand();
          }
        });
      }
    };
  }]);

angular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse'])

.constant('accordionConfig', {
  closeOthers: true
})

.controller('AccordionController', ['$scope', '$attrs', 'accordionConfig', function ($scope, $attrs, accordionConfig) {

  // This array keeps track of the accordion groups
  this.groups = [];

  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to
  this.closeOthers = function(openGroup) {
    var closeOthers = angular.isDefined($attrs.closeOthers) ? $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
    if ( closeOthers ) {
      angular.forEach(this.groups, function (group) {
        if ( group !== openGroup ) {
          group.isOpen = false;
        }
      });
    }
  };

  // This is called from the accordion-group directive to add itself to the accordion
  this.addGroup = function(groupScope) {
    var that = this;
    this.groups.push(groupScope);

    groupScope.$on('$destroy', function (event) {
      that.removeGroup(groupScope);
    });
  };

  // This is called from the accordion-group directive when to remove itself
  this.removeGroup = function(group) {
    var index = this.groups.indexOf(group);
    if ( index !== -1 ) {
      this.groups.splice(index, 1);
    }
  };

}])

// The accordion directive simply sets up the directive controller
// and adds an accordion CSS class to itself element.
.directive('accordion', function () {
  return {
    restrict:'EA',
    controller:'AccordionController',
    transclude: true,
    replace: false,
    templateUrl: 'template/accordion/accordion.html'
  };
})

// The accordion-group directive indicates a block of html that will expand and collapse in an accordion
.directive('accordionGroup', function() {
  return {
    require:'^accordion',         // We need this directive to be inside an accordion
    restrict:'EA',
    transclude:true,              // It transcludes the contents of the directive into the template
    replace: true,                // The element containing the directive will be replaced with the template
    templateUrl:'template/accordion/accordion-group.html',
    scope: {
      heading: '@',               // Interpolate the heading attribute onto this scope
      isOpen: '=?',
      isDisabled: '=?'
    },
    controller: function() {
      this.setHeading = function(element) {
        this.heading = element;
      };
    },
    link: function(scope, element, attrs, accordionCtrl) {
      accordionCtrl.addGroup(scope);

      scope.$watch('isOpen', function(value) {
        if ( value ) {
          accordionCtrl.closeOthers(scope);
        }
      });

      scope.toggleOpen = function() {
        if ( !scope.isDisabled ) {
          scope.isOpen = !scope.isOpen;
        }
      };
    }
  };
})

// Use accordion-heading below an accordion-group to provide a heading containing HTML
// <accordion-group>
//   <accordion-heading>Heading containing HTML - <img src="..."></accordion-heading>
// </accordion-group>
.directive('accordionHeading', function() {
  return {
    restrict: 'EA',
    transclude: true,   // Grab the contents to be used as the heading
    template: '',       // In effect remove this element!
    replace: true,
    require: '^accordionGroup',
    link: function(scope, element, attr, accordionGroupCtrl, transclude) {
      // Pass the heading to the accordion-group controller
      // so that it can be transcluded into the right place in the template
      // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]
      accordionGroupCtrl.setHeading(transclude(scope, function() {}));
    }
  };
})

// Use in the accordion-group template to indicate where you want the heading to be transcluded
// You must provide the property on the accordion-group controller that will hold the transcluded element
// <div class="accordion-group">
//   <div class="accordion-heading" ><a ... accordion-transclude="heading">...</a></div>
//   ...
// </div>
.directive('accordionTransclude', function() {
  return {
    require: '^accordionGroup',
    link: function(scope, element, attr, controller) {
      scope.$watch(function() { return controller[attr.accordionTransclude]; }, function(heading) {
        if ( heading ) {
          element.html('');
          element.append(heading);
        }
      });
    }
  };
});

angular.module('ui.bootstrap.alert', [])

.controller('AlertController', ['$scope', '$attrs', function ($scope, $attrs) {
  $scope.closeable = 'close' in $attrs;
}])

.directive('alert', function () {
  return {
    restrict:'EA',
    controller:'AlertController',
    templateUrl:'template/alert/alert.html',
    transclude:true,
    replace:true,
    scope: {
      type: '@',
      close: '&'
    }
  };
});

angular.module('ui.bootstrap.bindHtml', [])

  .directive('bindHtmlUnsafe', function () {
    return function (scope, element, attr) {
      element.addClass('ng-binding').data('$binding', attr.bindHtmlUnsafe);
      scope.$watch(attr.bindHtmlUnsafe, function bindHtmlUnsafeWatchAction(value) {
        element.html(value || '');
      });
    };
  });
angular.module('ui.bootstrap.buttons', [])

.constant('buttonConfig', {
  activeClass: 'active',
  toggleEvent: 'click'
})

.controller('ButtonsController', ['buttonConfig', function(buttonConfig) {
  this.activeClass = buttonConfig.activeClass || 'active';
  this.toggleEvent = buttonConfig.toggleEvent || 'click';
}])

.directive('btnRadio', function () {
  return {
    require: ['btnRadio', 'ngModel'],
    controller: 'ButtonsController',
    link: function (scope, element, attrs, ctrls) {
      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      //model -> UI
      ngModelCtrl.$render = function () {
        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));
      };

      //ui->model
      element.bind(buttonsCtrl.toggleEvent, function () {
        var isActive = element.hasClass(buttonsCtrl.activeClass);

        if (!isActive || angular.isDefined(attrs.uncheckable)) {
          scope.$apply(function () {
            ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.btnRadio));
            ngModelCtrl.$render();
          });
        }
      });
    }
  };
})

.directive('btnCheckbox', function () {
  return {
    require: ['btnCheckbox', 'ngModel'],
    controller: 'ButtonsController',
    link: function (scope, element, attrs, ctrls) {
      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      function getTrueValue() {
        return getCheckboxValue(attrs.btnCheckboxTrue, true);
      }

      function getFalseValue() {
        return getCheckboxValue(attrs.btnCheckboxFalse, false);
      }

      function getCheckboxValue(attributeValue, defaultValue) {
        var val = scope.$eval(attributeValue);
        return angular.isDefined(val) ? val : defaultValue;
      }

      //model -> UI
      ngModelCtrl.$render = function () {
        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
      };

      //ui->model
      element.bind(buttonsCtrl.toggleEvent, function () {
        scope.$apply(function () {
          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
          ngModelCtrl.$render();
        });
      });
    }
  };
});

/**
* @ngdoc overview
* @name ui.bootstrap.carousel
*
* @description
* AngularJS version of an image carousel.
*
*/
angular.module('ui.bootstrap.carousel', ['ui.bootstrap.transition'])
.controller('CarouselController', ['$scope', '$timeout', '$transition', function ($scope, $timeout, $transition) {
  var self = this,
    slides = self.slides = $scope.slides = [],
    currentIndex = -1,
    currentTimeout, isPlaying;
  self.currentSlide = null;

  var destroyed = false;
  /* direction: "prev" or "next" */
  self.select = $scope.select = function(nextSlide, direction) {
    var nextIndex = slides.indexOf(nextSlide);
    //Decide direction if it's not given
    if (direction === undefined) {
      direction = nextIndex > currentIndex ? 'next' : 'prev';
    }
    if (nextSlide && nextSlide !== self.currentSlide) {
      if ($scope.$currentTransition) {
        $scope.$currentTransition.cancel();
        //Timeout so ng-class in template has time to fix classes for finished slide
        $timeout(goNext);
      } else {
        goNext();
      }
    }
    function goNext() {
      // Scope has been destroyed, stop here.
      if (destroyed) { return; }
      //If we have a slide to transition from and we have a transition type and we're allowed, go
      if (self.currentSlide && angular.isString(direction) && !$scope.noTransition && nextSlide.$element) {
        //We shouldn't do class manip in here, but it's the same weird thing bootstrap does. need to fix sometime
        nextSlide.$element.addClass(direction);
        var reflow = nextSlide.$element[0].offsetWidth; //force reflow

        //Set all other slides to stop doing their stuff for the new transition
        angular.forEach(slides, function(slide) {
          angular.extend(slide, {direction: '', entering: false, leaving: false, active: false});
        });
        angular.extend(nextSlide, {direction: direction, active: true, entering: true});
        angular.extend(self.currentSlide||{}, {direction: direction, leaving: true});

        $scope.$currentTransition = $transition(nextSlide.$element, {});
        //We have to create new pointers inside a closure since next & current will change
        (function(next,current) {
          $scope.$currentTransition.then(
            function(){ transitionDone(next, current); },
            function(){ transitionDone(next, current); }
          );
        }(nextSlide, self.currentSlide));
      } else {
        transitionDone(nextSlide, self.currentSlide);
      }
      self.currentSlide = nextSlide;
      currentIndex = nextIndex;
      //every time you change slides, reset the timer
      restartTimer();
    }
    function transitionDone(next, current) {
      angular.extend(next, {direction: '', active: true, leaving: false, entering: false});
      angular.extend(current||{}, {direction: '', active: false, leaving: false, entering: false});
      $scope.$currentTransition = null;
    }
  };
  $scope.$on('$destroy', function () {
    destroyed = true;
  });

  /* Allow outside people to call indexOf on slides array */
  self.indexOfSlide = function(slide) {
    return slides.indexOf(slide);
  };

  $scope.next = function() {
    var newIndex = (currentIndex + 1) % slides.length;

    //Prevent this user-triggered transition from occurring if there is already one in progress
    if (!$scope.$currentTransition) {
      return self.select(slides[newIndex], 'next');
    }
  };

  $scope.prev = function() {
    var newIndex = currentIndex - 1 < 0 ? slides.length - 1 : currentIndex - 1;

    //Prevent this user-triggered transition from occurring if there is already one in progress
    if (!$scope.$currentTransition) {
      return self.select(slides[newIndex], 'prev');
    }
  };

  $scope.isActive = function(slide) {
     return self.currentSlide === slide;
  };

  $scope.$watch('interval', restartTimer);
  $scope.$on('$destroy', resetTimer);

  function restartTimer() {
    resetTimer();
    var interval = +$scope.interval;
    if (!isNaN(interval) && interval>=0) {
      currentTimeout = $timeout(timerFn, interval);
    }
  }

  function resetTimer() {
    if (currentTimeout) {
      $timeout.cancel(currentTimeout);
      currentTimeout = null;
    }
  }

  function timerFn() {
    if (isPlaying) {
      $scope.next();
      restartTimer();
    } else {
      $scope.pause();
    }
  }

  $scope.play = function() {
    if (!isPlaying) {
      isPlaying = true;
      restartTimer();
    }
  };
  $scope.pause = function() {
    if (!$scope.noPause) {
      isPlaying = false;
      resetTimer();
    }
  };

  self.addSlide = function(slide, element) {
    slide.$element = element;
    slides.push(slide);
    //if this is the first slide or the slide is set to active, select it
    if(slides.length === 1 || slide.active) {
      self.select(slides[slides.length-1]);
      if (slides.length == 1) {
        $scope.play();
      }
    } else {
      slide.active = false;
    }
  };

  self.removeSlide = function(slide) {
    //get the index of the slide inside the carousel
    var index = slides.indexOf(slide);
    slides.splice(index, 1);
    if (slides.length > 0 && slide.active) {
      if (index >= slides.length) {
        self.select(slides[index-1]);
      } else {
        self.select(slides[index]);
      }
    } else if (currentIndex > index) {
      currentIndex--;
    }
  };

}])

/**
 * @ngdoc directive
 * @name ui.bootstrap.carousel.directive:carousel
 * @restrict EA
 *
 * @description
 * Carousel is the outer container for a set of image 'slides' to showcase.
 *
 * @param {number=} interval The time, in milliseconds, that it will take the carousel to go to the next slide.
 * @param {boolean=} noTransition Whether to disable transitions on the carousel.
 * @param {boolean=} noPause Whether to disable pausing on the carousel (by default, the carousel interval pauses on hover).
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
    <carousel>
      <slide>
        <img src="http://placekitten.com/150/150" style="margin:auto;">
        <div class="carousel-caption">
          <p>Beautiful!</p>
        </div>
      </slide>
      <slide>
        <img src="http://placekitten.com/100/150" style="margin:auto;">
        <div class="carousel-caption">
          <p>D'aww!</p>
        </div>
      </slide>
    </carousel>
  </file>
  <file name="demo.css">
    .carousel-indicators {
      top: auto;
      bottom: 15px;
    }
  </file>
</example>
 */
.directive('carousel', [function() {
  return {
    restrict: 'EA',
    transclude: true,
    replace: true,
    controller: 'CarouselController',
    require: 'carousel',
    templateUrl: 'template/carousel/carousel.html',
    scope: {
      interval: '=',
      noTransition: '=',
      noPause: '='
    }
  };
}])

/**
 * @ngdoc directive
 * @name ui.bootstrap.carousel.directive:slide
 * @restrict EA
 *
 * @description
 * Creates a slide inside a {@link ui.bootstrap.carousel.directive:carousel carousel}.  Must be placed as a child of a carousel element.
 *
 * @param {boolean=} active Model binding, whether or not this slide is currently active.
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
<div ng-controller="CarouselDemoCtrl">
  <carousel>
    <slide ng-repeat="slide in slides" active="slide.active">
      <img ng-src="{{slide.image}}" style="margin:auto;">
      <div class="carousel-caption">
        <h4>Slide {{$index}}</h4>
        <p>{{slide.text}}</p>
      </div>
    </slide>
  </carousel>
  Interval, in milliseconds: <input type="number" ng-model="myInterval">
  <br />Enter a negative number to stop the interval.
</div>
  </file>
  <file name="script.js">
function CarouselDemoCtrl($scope) {
  $scope.myInterval = 5000;
}
  </file>
  <file name="demo.css">
    .carousel-indicators {
      top: auto;
      bottom: 15px;
    }
  </file>
</example>
*/

.directive('slide', function() {
  return {
    require: '^carousel',
    restrict: 'EA',
    transclude: true,
    replace: true,
    templateUrl: 'template/carousel/slide.html',
    scope: {
      active: '=?'
    },
    link: function (scope, element, attrs, carouselCtrl) {
      carouselCtrl.addSlide(scope, element);
      //when the scope is destroyed then remove the slide from the current slides array
      scope.$on('$destroy', function() {
        carouselCtrl.removeSlide(scope);
      });

      scope.$watch('active', function(active) {
        if (active) {
          carouselCtrl.select(scope);
        }
      });
    }
  };
});

angular.module('ui.bootstrap.dateparser', [])

.service('dateParser', ['$locale', 'orderByFilter', function($locale, orderByFilter) {

  this.parsers = {};

  var formatCodeToRegex = {
    'yyyy': {
      regex: '\\d{4}',
      apply: function(value) { this.year = +value; }
    },
    'yy': {
      regex: '\\d{2}',
      apply: function(value) { this.year = +value + 2000; }
    },
    'y': {
      regex: '\\d{1,4}',
      apply: function(value) { this.year = +value; }
    },
    'MMMM': {
      regex: $locale.DATETIME_FORMATS.MONTH.join('|'),
      apply: function(value) { this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value); }
    },
    'MMM': {
      regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),
      apply: function(value) { this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value); }
    },
    'MM': {
      regex: '0[1-9]|1[0-2]',
      apply: function(value) { this.month = value - 1; }
    },
    'M': {
      regex: '[1-9]|1[0-2]',
      apply: function(value) { this.month = value - 1; }
    },
    'dd': {
      regex: '[0-2][0-9]{1}|3[0-1]{1}',
      apply: function(value) { this.date = +value; }
    },
    'd': {
      regex: '[1-2]?[0-9]{1}|3[0-1]{1}',
      apply: function(value) { this.date = +value; }
    },
    'EEEE': {
      regex: $locale.DATETIME_FORMATS.DAY.join('|')
    },
    'EEE': {
      regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|')
    }
  };

  this.createParser = function(format) {
    var map = [], regex = format.split('');

    angular.forEach(formatCodeToRegex, function(data, code) {
      var index = format.indexOf(code);

      if (index > -1) {
        format = format.split('');

        regex[index] = '(' + data.regex + ')';
        format[index] = '$'; // Custom symbol to define consumed part of format
        for (var i = index + 1, n = index + code.length; i < n; i++) {
          regex[i] = '';
          format[i] = '$';
        }
        format = format.join('');

        map.push({ index: index, apply: data.apply });
      }
    });

    return {
      regex: new RegExp('^' + regex.join('') + '$'),
      map: orderByFilter(map, 'index')
    };
  };

  this.parse = function(input, format) {
    if ( !angular.isString(input) ) {
      return input;
    }

    format = $locale.DATETIME_FORMATS[format] || format;

    if ( !this.parsers[format] ) {
      this.parsers[format] = this.createParser(format);
    }

    var parser = this.parsers[format],
        regex = parser.regex,
        map = parser.map,
        results = input.match(regex);

    if ( results && results.length ) {
      var fields = { year: 1900, month: 0, date: 1, hours: 0 }, dt;

      for( var i = 1, n = results.length; i < n; i++ ) {
        var mapper = map[i-1];
        if ( mapper.apply ) {
          mapper.apply.call(fields, results[i]);
        }
      }

      if ( isValid(fields.year, fields.month, fields.date) ) {
        dt = new Date( fields.year, fields.month, fields.date, fields.hours);
      }

      return dt;
    }
  };

  // Check if date is valid for specific month (and year for February).
  // Month: 0 = Jan, 1 = Feb, etc
  function isValid(year, month, date) {
    if ( month === 1 && date > 28) {
        return date === 29 && ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0);
    }

    if ( month === 3 || month === 5 || month === 8 || month === 10) {
        return date < 31;
    }

    return true;
  }
}]);

angular.module('ui.bootstrap.position', [])

/**
 * A set of utility methods that can be use to retrieve position of DOM elements.
 * It is meant to be used where we need to absolute-position DOM elements in
 * relation to other, existing elements (this is the case for tooltips, popovers,
 * typeahead suggestions etc.).
 */
  .factory('$position', ['$document', '$window', function ($document, $window) {

    function getStyle(el, cssprop) {
      if (el.currentStyle) { //IE
        return el.currentStyle[cssprop];
      } else if ($window.getComputedStyle) {
        return $window.getComputedStyle(el)[cssprop];
      }
      // finally try and get inline style
      return el.style[cssprop];
    }

    /**
     * Checks if a given element is statically positioned
     * @param element - raw DOM element
     */
    function isStaticPositioned(element) {
      return (getStyle(element, 'position') || 'static' ) === 'static';
    }

    /**
     * returns the closest, non-statically positioned parentOffset of a given element
     * @param element
     */
    var parentOffsetEl = function (element) {
      var docDomEl = $document[0];
      var offsetParent = element.offsetParent || docDomEl;
      while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent) ) {
        offsetParent = offsetParent.offsetParent;
      }
      return offsetParent || docDomEl;
    };

    return {
      /**
       * Provides read-only equivalent of jQuery's position function:
       * http://api.jquery.com/position/
       */
      position: function (element) {
        var elBCR = this.offset(element);
        var offsetParentBCR = { top: 0, left: 0 };
        var offsetParentEl = parentOffsetEl(element[0]);
        if (offsetParentEl != $document[0]) {
          offsetParentBCR = this.offset(angular.element(offsetParentEl));
          offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;
          offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;
        }

        var boundingClientRect = element[0].getBoundingClientRect();
        return {
          width: boundingClientRect.width || element.prop('offsetWidth'),
          height: boundingClientRect.height || element.prop('offsetHeight'),
          top: elBCR.top - offsetParentBCR.top,
          left: elBCR.left - offsetParentBCR.left
        };
      },

      /**
       * Provides read-only equivalent of jQuery's offset function:
       * http://api.jquery.com/offset/
       */
      offset: function (element) {
        var boundingClientRect = element[0].getBoundingClientRect();
        return {
          width: boundingClientRect.width || element.prop('offsetWidth'),
          height: boundingClientRect.height || element.prop('offsetHeight'),
          top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),
          left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)
        };
      },

      /**
       * Provides coordinates for the targetEl in relation to hostEl
       */
      positionElements: function (hostEl, targetEl, positionStr, appendToBody) {

        var positionStrParts = positionStr.split('-');
        var pos0 = positionStrParts[0], pos1 = positionStrParts[1] || 'center';

        var hostElPos,
          targetElWidth,
          targetElHeight,
          targetElPos;

        hostElPos = appendToBody ? this.offset(hostEl) : this.position(hostEl);

        targetElWidth = targetEl.prop('offsetWidth');
        targetElHeight = targetEl.prop('offsetHeight');

        var shiftWidth = {
          center: function () {
            return hostElPos.left + hostElPos.width / 2 - targetElWidth / 2;
          },
          left: function () {
            return hostElPos.left;
          },
          right: function () {
            return hostElPos.left + hostElPos.width;
          }
        };

        var shiftHeight = {
          center: function () {
            return hostElPos.top + hostElPos.height / 2 - targetElHeight / 2;
          },
          top: function () {
            return hostElPos.top;
          },
          bottom: function () {
            return hostElPos.top + hostElPos.height;
          }
        };

        switch (pos0) {
          case 'right':
            targetElPos = {
              top: shiftHeight[pos1](),
              left: shiftWidth[pos0]()
            };
            break;
          case 'left':
            targetElPos = {
              top: shiftHeight[pos1](),
              left: hostElPos.left - targetElWidth
            };
            break;
          case 'bottom':
            targetElPos = {
              top: shiftHeight[pos0](),
              left: shiftWidth[pos1]()
            };
            break;
          default:
            targetElPos = {
              top: hostElPos.top - targetElHeight,
              left: shiftWidth[pos1]()
            };
            break;
        }

        return targetElPos;
      }
    };
  }]);

angular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.position'])

.constant('datepickerConfig', {
  formatDay: 'dd',
  formatMonth: 'MMMM',
  formatYear: 'yyyy',
  formatDayHeader: 'EEE',
  formatDayTitle: 'MMMM yyyy',
  formatMonthTitle: 'yyyy',
  datepickerMode: 'day',
  minMode: 'day',
  maxMode: 'year',
  showWeeks: true,
  startingDay: 0,
  yearRange: 20,
  minDate: null,
  maxDate: null
})

.controller('DatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$timeout', '$log', 'dateFilter', 'datepickerConfig', function($scope, $attrs, $parse, $interpolate, $timeout, $log, dateFilter, datepickerConfig) {
  var self = this,
      ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl;

  // Modes chain
  this.modes = ['day', 'month', 'year'];

  // Configuration attributes
  angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle',
                   'minMode', 'maxMode', 'showWeeks', 'startingDay', 'yearRange'], function( key, index ) {
    self[key] = angular.isDefined($attrs[key]) ? (index < 8 ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key])) : datepickerConfig[key];
  });

  // Watchable attributes
  angular.forEach(['minDate', 'maxDate'], function( key ) {
    if ( $attrs[key] ) {
      $scope.$parent.$watch($parse($attrs[key]), function(value) {
        self[key] = value ? new Date(value) : null;
        self.refreshView();
      });
    } else {
      self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;
    }
  });

  $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;
  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);
  this.activeDate = angular.isDefined($attrs.initDate) ? $scope.$parent.$eval($attrs.initDate) : new Date();

  $scope.isActive = function(dateObject) {
    if (self.compare(dateObject.date, self.activeDate) === 0) {
      $scope.activeDateId = dateObject.uid;
      return true;
    }
    return false;
  };

  this.init = function( ngModelCtrl_ ) {
    ngModelCtrl = ngModelCtrl_;

    ngModelCtrl.$render = function() {
      self.render();
    };
  };

  this.render = function() {
    if ( ngModelCtrl.$modelValue ) {
      var date = new Date( ngModelCtrl.$modelValue ),
          isValid = !isNaN(date);

      if ( isValid ) {
        this.activeDate = date;
      } else {
        $log.error('Datepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
      }
      ngModelCtrl.$setValidity('date', isValid);
    }
    this.refreshView();
  };

  this.refreshView = function() {
    if ( this.element ) {
      this._refreshView();

      var date = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : null;
      ngModelCtrl.$setValidity('date-disabled', !date || (this.element && !this.isDisabled(date)));
    }
  };

  this.createDateObject = function(date, format) {
    var model = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : null;
    return {
      date: date,
      label: dateFilter(date, format),
      selected: model && this.compare(date, model) === 0,
      disabled: this.isDisabled(date),
      current: this.compare(date, new Date()) === 0
    };
  };

  this.isDisabled = function( date ) {
    return ((this.minDate && this.compare(date, this.minDate) < 0) || (this.maxDate && this.compare(date, this.maxDate) > 0) || ($attrs.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode})));
  };

  // Split array into smaller arrays
  this.split = function(arr, size) {
    var arrays = [];
    while (arr.length > 0) {
      arrays.push(arr.splice(0, size));
    }
    return arrays;
  };

  $scope.select = function( date ) {
    if ( $scope.datepickerMode === self.minMode ) {
      var dt = ngModelCtrl.$modelValue ? new Date( ngModelCtrl.$modelValue ) : new Date(0, 0, 0, 0, 0, 0, 0);
      dt.setFullYear( date.getFullYear(), date.getMonth(), date.getDate() );
      ngModelCtrl.$setViewValue( dt );
      ngModelCtrl.$render();
    } else {
      self.activeDate = date;
      $scope.datepickerMode = self.modes[ self.modes.indexOf( $scope.datepickerMode ) - 1 ];
    }
  };

  $scope.move = function( direction ) {
    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),
        month = self.activeDate.getMonth() + direction * (self.step.months || 0);
    self.activeDate.setFullYear(year, month, 1);
    self.refreshView();
  };

  $scope.toggleMode = function( direction ) {
    direction = direction || 1;

    if (($scope.datepickerMode === self.maxMode && direction === 1) || ($scope.datepickerMode === self.minMode && direction === -1)) {
      return;
    }

    $scope.datepickerMode = self.modes[ self.modes.indexOf( $scope.datepickerMode ) + direction ];
  };

  // Key event mapper
  $scope.keys = { 13:'enter', 32:'space', 33:'pageup', 34:'pagedown', 35:'end', 36:'home', 37:'left', 38:'up', 39:'right', 40:'down' };

  var focusElement = function() {
    $timeout(function() {
      self.element[0].focus();
    }, 0 , false);
  };

  // Listen for focus requests from popup directive
  $scope.$on('datepicker.focus', focusElement);

  $scope.keydown = function( evt ) {
    var key = $scope.keys[evt.which];

    if ( !key || evt.shiftKey || evt.altKey ) {
      return;
    }

    evt.preventDefault();
    evt.stopPropagation();

    if (key === 'enter' || key === 'space') {
      if ( self.isDisabled(self.activeDate)) {
        return; // do nothing
      }
      $scope.select(self.activeDate);
      focusElement();
    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {
      $scope.toggleMode(key === 'up' ? 1 : -1);
      focusElement();
    } else {
      self.handleKeyDown(key, evt);
      self.refreshView();
    }
  };
}])

.directive( 'datepicker', function () {
  return {
    restrict: 'EA',
    replace: true,
    templateUrl: 'template/datepicker/datepicker.html',
    scope: {
      datepickerMode: '=?',
      dateDisabled: '&'
    },
    require: ['datepicker', '?^ngModel'],
    controller: 'DatepickerController',
    link: function(scope, element, attrs, ctrls) {
      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if ( ngModelCtrl ) {
        datepickerCtrl.init( ngModelCtrl );
      }
    }
  };
})

.directive('daypicker', ['dateFilter', function (dateFilter) {
  return {
    restrict: 'EA',
    replace: true,
    templateUrl: 'template/datepicker/day.html',
    require: '^datepicker',
    link: function(scope, element, attrs, ctrl) {
      scope.showWeeks = ctrl.showWeeks;

      ctrl.step = { months: 1 };
      ctrl.element = element;

      var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      function getDaysInMonth( year, month ) {
        return ((month === 1) && (year % 4 === 0) && ((year % 100 !== 0) || (year % 400 === 0))) ? 29 : DAYS_IN_MONTH[month];
      }

      function getDates(startDate, n) {
        var dates = new Array(n), current = new Date(startDate), i = 0;
        current.setHours(12); // Prevent repeated dates because of timezone bug
        while ( i < n ) {
          dates[i++] = new Date(current);
          current.setDate( current.getDate() + 1 );
        }
        return dates;
      }

      ctrl._refreshView = function() {
        var year = ctrl.activeDate.getFullYear(),
          month = ctrl.activeDate.getMonth(),
          firstDayOfMonth = new Date(year, month, 1),
          difference = ctrl.startingDay - firstDayOfMonth.getDay(),
          numDisplayedFromPreviousMonth = (difference > 0) ? 7 - difference : - difference,
          firstDate = new Date(firstDayOfMonth);

        if ( numDisplayedFromPreviousMonth > 0 ) {
          firstDate.setDate( - numDisplayedFromPreviousMonth + 1 );
        }

        // 42 is the number of days on a six-month calendar
        var days = getDates(firstDate, 42);
        for (var i = 0; i < 42; i ++) {
          days[i] = angular.extend(ctrl.createDateObject(days[i], ctrl.formatDay), {
            secondary: days[i].getMonth() !== month,
            uid: scope.uniqueId + '-' + i
          });
        }

        scope.labels = new Array(7);
        for (var j = 0; j < 7; j++) {
          scope.labels[j] = {
            abbr: dateFilter(days[j].date, ctrl.formatDayHeader),
            full: dateFilter(days[j].date, 'EEEE')
          };
        }

        scope.title = dateFilter(ctrl.activeDate, ctrl.formatDayTitle);
        scope.rows = ctrl.split(days, 7);

        if ( scope.showWeeks ) {
          scope.weekNumbers = [];
          var weekNumber = getISO8601WeekNumber( scope.rows[0][0].date ),
              numWeeks = scope.rows.length;
          while( scope.weekNumbers.push(weekNumber++) < numWeeks ) {}
        }
      };

      ctrl.compare = function(date1, date2) {
        return (new Date( date1.getFullYear(), date1.getMonth(), date1.getDate() ) - new Date( date2.getFullYear(), date2.getMonth(), date2.getDate() ) );
      };

      function getISO8601WeekNumber(date) {
        var checkDate = new Date(date);
        checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday
        var time = checkDate.getTime();
        checkDate.setMonth(0); // Compare with Jan 1
        checkDate.setDate(1);
        return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
      }

      ctrl.handleKeyDown = function( key, evt ) {
        var date = ctrl.activeDate.getDate();

        if (key === 'left') {
          date = date - 1;   // up
        } else if (key === 'up') {
          date = date - 7;   // down
        } else if (key === 'right') {
          date = date + 1;   // down
        } else if (key === 'down') {
          date = date + 7;
        } else if (key === 'pageup' || key === 'pagedown') {
          var month = ctrl.activeDate.getMonth() + (key === 'pageup' ? - 1 : 1);
          ctrl.activeDate.setMonth(month, 1);
          date = Math.min(getDaysInMonth(ctrl.activeDate.getFullYear(), ctrl.activeDate.getMonth()), date);
        } else if (key === 'home') {
          date = 1;
        } else if (key === 'end') {
          date = getDaysInMonth(ctrl.activeDate.getFullYear(), ctrl.activeDate.getMonth());
        }
        ctrl.activeDate.setDate(date);
      };

      ctrl.refreshView();
    }
  };
}])

.directive('monthpicker', ['dateFilter', function (dateFilter) {
  return {
    restrict: 'EA',
    replace: true,
    templateUrl: 'template/datepicker/month.html',
    require: '^datepicker',
    link: function(scope, element, attrs, ctrl) {
      ctrl.step = { years: 1 };
      ctrl.element = element;

      ctrl._refreshView = function() {
        var months = new Array(12),
            year = ctrl.activeDate.getFullYear();

        for ( var i = 0; i < 12; i++ ) {
          months[i] = angular.extend(ctrl.createDateObject(new Date(year, i, 1), ctrl.formatMonth), {
            uid: scope.uniqueId + '-' + i
          });
        }

        scope.title = dateFilter(ctrl.activeDate, ctrl.formatMonthTitle);
        scope.rows = ctrl.split(months, 3);
      };

      ctrl.compare = function(date1, date2) {
        return new Date( date1.getFullYear(), date1.getMonth() ) - new Date( date2.getFullYear(), date2.getMonth() );
      };

      ctrl.handleKeyDown = function( key, evt ) {
        var date = ctrl.activeDate.getMonth();

        if (key === 'left') {
          date = date - 1;   // up
        } else if (key === 'up') {
          date = date - 3;   // down
        } else if (key === 'right') {
          date = date + 1;   // down
        } else if (key === 'down') {
          date = date + 3;
        } else if (key === 'pageup' || key === 'pagedown') {
          var year = ctrl.activeDate.getFullYear() + (key === 'pageup' ? - 1 : 1);
          ctrl.activeDate.setFullYear(year);
        } else if (key === 'home') {
          date = 0;
        } else if (key === 'end') {
          date = 11;
        }
        ctrl.activeDate.setMonth(date);
      };

      ctrl.refreshView();
    }
  };
}])

.directive('yearpicker', ['dateFilter', function (dateFilter) {
  return {
    restrict: 'EA',
    replace: true,
    templateUrl: 'template/datepicker/year.html',
    require: '^datepicker',
    link: function(scope, element, attrs, ctrl) {
      var range = ctrl.yearRange;

      ctrl.step = { years: range };
      ctrl.element = element;

      function getStartingYear( year ) {
        return parseInt((year - 1) / range, 10) * range + 1;
      }

      ctrl._refreshView = function() {
        var years = new Array(range);

        for ( var i = 0, start = getStartingYear(ctrl.activeDate.getFullYear()); i < range; i++ ) {
          years[i] = angular.extend(ctrl.createDateObject(new Date(start + i, 0, 1), ctrl.formatYear), {
            uid: scope.uniqueId + '-' + i
          });
        }

        scope.title = [years[0].label, years[range - 1].label].join(' - ');
        scope.rows = ctrl.split(years, 5);
      };

      ctrl.compare = function(date1, date2) {
        return date1.getFullYear() - date2.getFullYear();
      };

      ctrl.handleKeyDown = function( key, evt ) {
        var date = ctrl.activeDate.getFullYear();

        if (key === 'left') {
          date = date - 1;   // up
        } else if (key === 'up') {
          date = date - 5;   // down
        } else if (key === 'right') {
          date = date + 1;   // down
        } else if (key === 'down') {
          date = date + 5;
        } else if (key === 'pageup' || key === 'pagedown') {
          date += (key === 'pageup' ? - 1 : 1) * ctrl.step.years;
        } else if (key === 'home') {
          date = getStartingYear( ctrl.activeDate.getFullYear() );
        } else if (key === 'end') {
          date = getStartingYear( ctrl.activeDate.getFullYear() ) + range - 1;
        }
        ctrl.activeDate.setFullYear(date);
      };

      ctrl.refreshView();
    }
  };
}])

.constant('datepickerPopupConfig', {
  datepickerPopup: 'yyyy-MM-dd',
  currentText: 'Today',
  clearText: 'Clear',
  closeText: 'Done',
  closeOnDateSelection: true,
  appendToBody: false,
  showButtonBar: true
})

.directive('datepickerPopup', ['$compile', '$parse', '$document', '$position', 'dateFilter', 'dateParser', 'datepickerPopupConfig',
function ($compile, $parse, $document, $position, dateFilter, dateParser, datepickerPopupConfig) {
  return {
    restrict: 'EA',
    require: 'ngModel',
    scope: {
      isOpen: '=?',
      currentText: '@',
      clearText: '@',
      closeText: '@',
      dateDisabled: '&'
    },
    link: function(scope, element, attrs, ngModel) {
      var dateFormat,
          closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? scope.$parent.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection,
          appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? scope.$parent.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody;

      scope.showButtonBar = angular.isDefined(attrs.showButtonBar) ? scope.$parent.$eval(attrs.showButtonBar) : datepickerPopupConfig.showButtonBar;

      scope.getText = function( key ) {
        return scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];
      };

      attrs.$observe('datepickerPopup', function(value) {
          dateFormat = value || datepickerPopupConfig.datepickerPopup;
          ngModel.$render();
      });

      // popup element used to display calendar
      var popupEl = angular.element('<div datepicker-popup-wrap><div datepicker></div></div>');
      popupEl.attr({
        'ng-model': 'date',
        'ng-change': 'dateSelection()'
      });

      function cameltoDash( string ){
        return string.replace(/([A-Z])/g, function($1) { return '-' + $1.toLowerCase(); });
      }

      // datepicker element
      var datepickerEl = angular.element(popupEl.children()[0]);
      if ( attrs.datepickerOptions ) {
        angular.forEach(scope.$parent.$eval(attrs.datepickerOptions), function( value, option ) {
          datepickerEl.attr( cameltoDash(option), value );
        });
      }

      angular.forEach(['minDate', 'maxDate'], function( key ) {
        if ( attrs[key] ) {
          scope.$parent.$watch($parse(attrs[key]), function(value){
            scope[key] = value;
          });
          datepickerEl.attr(cameltoDash(key), key);
        }
      });
      if (attrs.dateDisabled) {
        datepickerEl.attr('date-disabled', 'dateDisabled({ date: date, mode: mode })');
      }

      function parseDate(viewValue) {
        if (!viewValue) {
          ngModel.$setValidity('date', true);
          return null;
        } else if (angular.isDate(viewValue) && !isNaN(viewValue)) {
          ngModel.$setValidity('date', true);
          return viewValue;
        } else if (angular.isString(viewValue)) {
          var date = dateParser.parse(viewValue, dateFormat) || new Date(viewValue);
          if (isNaN(date)) {
            ngModel.$setValidity('date', false);
            return undefined;
          } else {
            ngModel.$setValidity('date', true);
            return date;
          }
        } else {
          ngModel.$setValidity('date', false);
          return undefined;
        }
      }
      ngModel.$parsers.unshift(parseDate);

      // Inner change
      scope.dateSelection = function(dt) {
        if (angular.isDefined(dt)) {
          scope.date = dt;
        }
        ngModel.$setViewValue(scope.date);
        ngModel.$render();

        if ( closeOnDateSelection ) {
          scope.isOpen = false;
          element[0].focus();
        }
      };

      element.bind('input change keyup', function() {
        scope.$apply(function() {
          scope.date = ngModel.$modelValue;
        });
      });

      // Outter change
      ngModel.$render = function() {
        var date = ngModel.$viewValue ? dateFilter(ngModel.$viewValue, dateFormat) : '';
        element.val(date);
        scope.date = parseDate( ngModel.$modelValue );
      };

      var documentClickBind = function(event) {
        if (scope.isOpen && event.target !== element[0]) {
          scope.$apply(function() {
            scope.isOpen = false;
          });
        }
      };

      var keydown = function(evt, noApply) {
        scope.keydown(evt);
      };
      element.bind('keydown', keydown);

      scope.keydown = function(evt) {
        if (evt.which === 27) {
          evt.preventDefault();
          evt.stopPropagation();
          scope.close();
        } else if (evt.which === 40 && !scope.isOpen) {
          scope.isOpen = true;
        }
      };

      scope.$watch('isOpen', function(value) {
        if (value) {
          scope.$broadcast('datepicker.focus');
          scope.position = appendToBody ? $position.offset(element) : $position.position(element);
          scope.position.top = scope.position.top + element.prop('offsetHeight');

          $document.bind('click', documentClickBind);
        } else {
          $document.unbind('click', documentClickBind);
        }
      });

      scope.select = function( date ) {
        if (date === 'today') {
          var today = new Date();
          if (angular.isDate(ngModel.$modelValue)) {
            date = new Date(ngModel.$modelValue);
            date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());
          } else {
            date = new Date(today.setHours(0, 0, 0, 0));
          }
        }
        scope.dateSelection( date );
      };

      scope.close = function() {
        scope.isOpen = false;
        element[0].focus();
      };

      var $popup = $compile(popupEl)(scope);
      if ( appendToBody ) {
        $document.find('body').append($popup);
      } else {
        element.after($popup);
      }

      scope.$on('$destroy', function() {
        $popup.remove();
        element.unbind('keydown', keydown);
        $document.unbind('click', documentClickBind);
      });
    }
  };
}])

.directive('datepickerPopupWrap', function() {
  return {
    restrict:'EA',
    replace: true,
    transclude: true,
    templateUrl: 'template/datepicker/popup.html',
    link:function (scope, element, attrs) {
      element.bind('click', function(event) {
        event.preventDefault();
        event.stopPropagation();
      });
    }
  };
});

angular.module('ui.bootstrap.dropdown', [])

.constant('dropdownConfig', {
  openClass: 'open'
})

.service('dropdownService', ['$document', function($document) {
  var openScope = null;

  this.open = function( dropdownScope ) {
    if ( !openScope ) {
      $document.bind('click', closeDropdown);
      $document.bind('keydown', escapeKeyBind);
    }

    if ( openScope && openScope !== dropdownScope ) {
        openScope.isOpen = false;
    }

    openScope = dropdownScope;
  };

  this.close = function( dropdownScope ) {
    if ( openScope === dropdownScope ) {
      openScope = null;
      $document.unbind('click', closeDropdown);
      $document.unbind('keydown', escapeKeyBind);
    }
  };

  var closeDropdown = function( evt ) {
    if (evt && evt.isDefaultPrevented()) {
        return;
    }

    openScope.$apply(function() {
      openScope.isOpen = false;
    });
  };

  var escapeKeyBind = function( evt ) {
    if ( evt.which === 27 ) {
      openScope.focusToggleElement();
      closeDropdown();
    }
  };
}])

.controller('DropdownController', ['$scope', '$attrs', '$parse', 'dropdownConfig', 'dropdownService', '$animate', function($scope, $attrs, $parse, dropdownConfig, dropdownService, $animate) {
  var self = this,
      scope = $scope.$new(), // create a child scope so we are not polluting original one
      openClass = dropdownConfig.openClass,
      getIsOpen,
      setIsOpen = angular.noop,
      toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop;

  this.init = function( element ) {
    self.$element = element;

    if ( $attrs.isOpen ) {
      getIsOpen = $parse($attrs.isOpen);
      setIsOpen = getIsOpen.assign;

      $scope.$watch(getIsOpen, function(value) {
        scope.isOpen = !!value;
      });
    }
  };

  this.toggle = function( open ) {
    return scope.isOpen = arguments.length ? !!open : !scope.isOpen;
  };

  // Allow other directives to watch status
  this.isOpen = function() {
    return scope.isOpen;
  };

  scope.focusToggleElement = function() {
    if ( self.toggleElement ) {
      self.toggleElement[0].focus();
    }
  };

  scope.$watch('isOpen', function( isOpen, wasOpen ) {
    $animate[isOpen ? 'addClass' : 'removeClass'](self.$element, openClass);

    if ( isOpen ) {
      scope.focusToggleElement();
      dropdownService.open( scope );
    } else {
      dropdownService.close( scope );
    }

    setIsOpen($scope, isOpen);
    if (angular.isDefined(isOpen) && isOpen !== wasOpen) {
      toggleInvoker($scope, { open: !!isOpen });
    }
  });

  $scope.$on('$locationChangeSuccess', function() {
    scope.isOpen = false;
  });

  $scope.$on('$destroy', function() {
    scope.$destroy();
  });
}])

.directive('dropdown', function() {
  return {
    restrict: 'CA',
    controller: 'DropdownController',
    link: function(scope, element, attrs, dropdownCtrl) {
      dropdownCtrl.init( element );
    }
  };
})

.directive('dropdownToggle', function() {
  return {
    restrict: 'CA',
    require: '?^dropdown',
    link: function(scope, element, attrs, dropdownCtrl) {
      if ( !dropdownCtrl ) {
        return;
      }

      dropdownCtrl.toggleElement = element;

      var toggleDropdown = function(event) {
        event.preventDefault();

        if ( !element.hasClass('disabled') && !attrs.disabled ) {
          scope.$apply(function() {
            dropdownCtrl.toggle();
          });
        }
      };

      element.bind('click', toggleDropdown);

      // WAI-ARIA
      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });
      scope.$watch(dropdownCtrl.isOpen, function( isOpen ) {
        element.attr('aria-expanded', !!isOpen);
      });

      scope.$on('$destroy', function() {
        element.unbind('click', toggleDropdown);
      });
    }
  };
});

angular.module('ui.bootstrap.modal', ['ui.bootstrap.transition'])

/**
 * A helper, internal data structure that acts as a map but also allows getting / removing
 * elements in the LIFO order
 */
  .factory('$$stackedMap', function () {
    return {
      createNew: function () {
        var stack = [];

        return {
          add: function (key, value) {
            stack.push({
              key: key,
              value: value
            });
          },
          get: function (key) {
            for (var i = 0; i < stack.length; i++) {
              if (key == stack[i].key) {
                return stack[i];
              }
            }
          },
          keys: function() {
            var keys = [];
            for (var i = 0; i < stack.length; i++) {
              keys.push(stack[i].key);
            }
            return keys;
          },
          top: function () {
            return stack[stack.length - 1];
          },
          remove: function (key) {
            var idx = -1;
            for (var i = 0; i < stack.length; i++) {
              if (key == stack[i].key) {
                idx = i;
                break;
              }
            }
            return stack.splice(idx, 1)[0];
          },
          removeTop: function () {
            return stack.splice(stack.length - 1, 1)[0];
          },
          length: function () {
            return stack.length;
          }
        };
      }
    };
  })

/**
 * A helper directive for the $modal service. It creates a backdrop element.
 */
  .directive('modalBackdrop', ['$timeout', function ($timeout) {
    return {
      restrict: 'EA',
      replace: true,
      templateUrl: 'template/modal/backdrop.html',
      link: function (scope) {

        scope.animate = false;

        //trigger CSS transitions
        $timeout(function () {
          scope.animate = true;
        });
      }
    };
  }])

  .directive('modalWindow', ['$modalStack', '$timeout', function ($modalStack, $timeout) {
    return {
      restrict: 'EA',
      scope: {
        index: '@',
        animate: '='
      },
      replace: true,
      transclude: true,
      templateUrl: function(tElement, tAttrs) {
        return tAttrs.templateUrl || 'template/modal/window.html';
      },
      link: function (scope, element, attrs) {
        element.addClass(attrs.windowClass || '');
        scope.size = attrs.size;

        $timeout(function () {
          // trigger CSS transitions
          scope.animate = true;
          // focus a freshly-opened modal
          element[0].focus();
        });

        scope.close = function (evt) {
          var modal = $modalStack.getTop();
          if (modal && modal.value.backdrop && modal.value.backdrop != 'static' && (evt.target === evt.currentTarget)) {
            evt.preventDefault();
            evt.stopPropagation();
            $modalStack.dismiss(modal.key, 'backdrop click');
          }
        };
      }
    };
  }])

  .factory('$modalStack', ['$transition', '$timeout', '$document', '$compile', '$rootScope', '$$stackedMap',
    function ($transition, $timeout, $document, $compile, $rootScope, $$stackedMap) {

      var OPENED_MODAL_CLASS = 'modal-open';

      var backdropDomEl, backdropScope;
      var openedWindows = $$stackedMap.createNew();
      var $modalStack = {};

      function backdropIndex() {
        var topBackdropIndex = -1;
        var opened = openedWindows.keys();
        for (var i = 0; i < opened.length; i++) {
          if (openedWindows.get(opened[i]).value.backdrop) {
            topBackdropIndex = i;
          }
        }
        return topBackdropIndex;
      }

      $rootScope.$watch(backdropIndex, function(newBackdropIndex){
        if (backdropScope) {
          backdropScope.index = newBackdropIndex;
        }
      });

      function removeModalWindow(modalInstance) {

        var body = $document.find('body').eq(0);
        var modalWindow = openedWindows.get(modalInstance).value;

        //clean up the stack
        openedWindows.remove(modalInstance);

        //remove window DOM element
        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, 300, function() {
          modalWindow.modalScope.$destroy();
          body.toggleClass(OPENED_MODAL_CLASS, openedWindows.length() > 0);
          checkRemoveBackdrop();
        });
      }

      function checkRemoveBackdrop() {
          //remove backdrop if no longer needed
          if (backdropDomEl && backdropIndex() == -1) {
            var backdropScopeRef = backdropScope;
            removeAfterAnimate(backdropDomEl, backdropScope, 150, function () {
              backdropScopeRef.$destroy();
              backdropScopeRef = null;
            });
            backdropDomEl = undefined;
            backdropScope = undefined;
          }
      }

      function removeAfterAnimate(domEl, scope, emulateTime, done) {
        // Closing animation
        scope.animate = false;

        var transitionEndEventName = $transition.transitionEndEventName;
        if (transitionEndEventName) {
          // transition out
          var timeout = $timeout(afterAnimating, emulateTime);

          domEl.bind(transitionEndEventName, function () {
            $timeout.cancel(timeout);
            afterAnimating();
            scope.$apply();
          });
        } else {
          // Ensure this call is async
          $timeout(afterAnimating, 0);
        }

        function afterAnimating() {
          if (afterAnimating.done) {
            return;
          }
          afterAnimating.done = true;

          domEl.remove();
          if (done) {
            done();
          }
        }
      }

      $document.bind('keydown', function (evt) {
        var modal;

        if (evt.which === 27) {
          modal = openedWindows.top();
          if (modal && modal.value.keyboard) {
            evt.preventDefault();
            $rootScope.$apply(function () {
              $modalStack.dismiss(modal.key, 'escape key press');
            });
          }
        }
      });

      $modalStack.open = function (modalInstance, modal) {

        openedWindows.add(modalInstance, {
          deferred: modal.deferred,
          modalScope: modal.scope,
          backdrop: modal.backdrop,
          keyboard: modal.keyboard
        });

        var body = $document.find('body').eq(0),
            currBackdropIndex = backdropIndex();

        if (currBackdropIndex >= 0 && !backdropDomEl) {
          backdropScope = $rootScope.$new(true);
          backdropScope.index = currBackdropIndex;
          backdropDomEl = $compile('<div modal-backdrop></div>')(backdropScope);
          body.append(backdropDomEl);
        }

        var angularDomEl = angular.element('<div modal-window></div>');
        angularDomEl.attr({
          'template-url': modal.windowTemplateUrl,
          'window-class': modal.windowClass,
          'size': modal.size,
          'index': openedWindows.length() - 1,
          'animate': 'animate'
        }).html(modal.content);

        var modalDomEl = $compile(angularDomEl)(modal.scope);
        openedWindows.top().value.modalDomEl = modalDomEl;
        body.append(modalDomEl);
        body.addClass(OPENED_MODAL_CLASS);
      };

      $modalStack.close = function (modalInstance, result) {
        var modalWindow = openedWindows.get(modalInstance).value;
        if (modalWindow) {
          modalWindow.deferred.resolve(result);
          removeModalWindow(modalInstance);
        }
      };

      $modalStack.dismiss = function (modalInstance, reason) {
        var modalWindow = openedWindows.get(modalInstance).value;
        if (modalWindow) {
          modalWindow.deferred.reject(reason);
          removeModalWindow(modalInstance);
        }
      };

      $modalStack.dismissAll = function (reason) {
        var topModal = this.getTop();
        while (topModal) {
          this.dismiss(topModal.key, reason);
          topModal = this.getTop();
        }
      };

      $modalStack.getTop = function () {
        return openedWindows.top();
      };

      return $modalStack;
    }])

  .provider('$modal', function () {

    var $modalProvider = {
      options: {
        backdrop: true, //can be also false or 'static'
        keyboard: true
      },
      $get: ['$injector', '$rootScope', '$q', '$http', '$templateCache', '$controller', '$modalStack',
        function ($injector, $rootScope, $q, $http, $templateCache, $controller, $modalStack) {

          var $modal = {};

          function getTemplatePromise(options) {
            return options.template ? $q.when(options.template) :
              $http.get(options.templateUrl, {cache: $templateCache}).then(function (result) {
                return result.data;
              });
          }

          function getResolvePromises(resolves) {
            var promisesArr = [];
            angular.forEach(resolves, function (value, key) {
              if (angular.isFunction(value) || angular.isArray(value)) {
                promisesArr.push($q.when($injector.invoke(value)));
              }
            });
            return promisesArr;
          }

          $modal.open = function (modalOptions) {

            var modalResultDeferred = $q.defer();
            var modalOpenedDeferred = $q.defer();

            //prepare an instance of a modal to be injected into controllers and returned to a caller
            var modalInstance = {
              result: modalResultDeferred.promise,
              opened: modalOpenedDeferred.promise,
              close: function (result) {
                $modalStack.close(modalInstance, result);
              },
              dismiss: function (reason) {
                $modalStack.dismiss(modalInstance, reason);
              }
            };

            //merge and clean up options
            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);
            modalOptions.resolve = modalOptions.resolve || {};

            //verify options
            if (!modalOptions.template && !modalOptions.templateUrl) {
              throw new Error('One of template or templateUrl options is required.');
            }

            var templateAndResolvePromise =
              $q.all([getTemplatePromise(modalOptions)].concat(getResolvePromises(modalOptions.resolve)));


            templateAndResolvePromise.then(function resolveSuccess(tplAndVars) {

              var modalScope = (modalOptions.scope || $rootScope).$new();
              modalScope.$close = modalInstance.close;
              modalScope.$dismiss = modalInstance.dismiss;

              var ctrlInstance, ctrlLocals = {};
              var resolveIter = 1;

              //controllers
              if (modalOptions.controller) {
                ctrlLocals.$scope = modalScope;
                ctrlLocals.$modalInstance = modalInstance;
                angular.forEach(modalOptions.resolve, function (value, key) {
                  ctrlLocals[key] = tplAndVars[resolveIter++];
                });

                ctrlInstance = $controller(modalOptions.controller, ctrlLocals);
              }

              $modalStack.open(modalInstance, {
                scope: modalScope,
                deferred: modalResultDeferred,
                content: tplAndVars[0],
                backdrop: modalOptions.backdrop,
                keyboard: modalOptions.keyboard,
                windowClass: modalOptions.windowClass,
                windowTemplateUrl: modalOptions.windowTemplateUrl,
                size: modalOptions.size
              });

            }, function resolveError(reason) {
              modalResultDeferred.reject(reason);
            });

            templateAndResolvePromise.then(function () {
              modalOpenedDeferred.resolve(true);
            }, function () {
              modalOpenedDeferred.reject(false);
            });

            return modalInstance;
          };

          return $modal;
        }]
    };

    return $modalProvider;
  });

angular.module('ui.bootstrap.pagination', [])

.controller('PaginationController', ['$scope', '$attrs', '$parse', function ($scope, $attrs, $parse) {
  var self = this,
      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl
      setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;

  this.init = function(ngModelCtrl_, config) {
    ngModelCtrl = ngModelCtrl_;
    this.config = config;

    ngModelCtrl.$render = function() {
      self.render();
    };

    if ($attrs.itemsPerPage) {
      $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {
        self.itemsPerPage = parseInt(value, 10);
        $scope.totalPages = self.calculateTotalPages();
      });
    } else {
      this.itemsPerPage = config.itemsPerPage;
    }
  };

  this.calculateTotalPages = function() {
    var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);
    return Math.max(totalPages || 0, 1);
  };

  this.render = function() {
    $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;
  };

  $scope.selectPage = function(page) {
    if ( $scope.page !== page && page > 0 && page <= $scope.totalPages) {
      ngModelCtrl.$setViewValue(page);
      ngModelCtrl.$render();
    }
  };

  $scope.getText = function( key ) {
    return $scope[key + 'Text'] || self.config[key + 'Text'];
  };
  $scope.noPrevious = function() {
    return $scope.page === 1;
  };
  $scope.noNext = function() {
    return $scope.page === $scope.totalPages;
  };

  $scope.$watch('totalItems', function() {
    $scope.totalPages = self.calculateTotalPages();
  });

  $scope.$watch('totalPages', function(value) {
    setNumPages($scope.$parent, value); // Readonly variable

    if ( $scope.page > value ) {
      $scope.selectPage(value);
    } else {
      ngModelCtrl.$render();
    }
  });
}])

.constant('paginationConfig', {
  itemsPerPage: 10,
  boundaryLinks: false,
  directionLinks: true,
  firstText: 'First',
  previousText: 'Previous',
  nextText: 'Next',
  lastText: 'Last',
  rotate: true
})

.directive('pagination', ['$parse', 'paginationConfig', function($parse, paginationConfig) {
  return {
    restrict: 'EA',
    scope: {
      totalItems: '=',
      firstText: '@',
      previousText: '@',
      nextText: '@',
      lastText: '@'
    },
    require: ['pagination', '?ngModel'],
    controller: 'PaginationController',
    templateUrl: 'template/pagination/pagination.html',
    replace: true,
    link: function(scope, element, attrs, ctrls) {
      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if (!ngModelCtrl) {
         return; // do nothing if no ng-model
      }

      // Setup configuration parameters
      var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize,
          rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;
      scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks;
      scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks;

      paginationCtrl.init(ngModelCtrl, paginationConfig);

      if (attrs.maxSize) {
        scope.$parent.$watch($parse(attrs.maxSize), function(value) {
          maxSize = parseInt(value, 10);
          paginationCtrl.render();
        });
      }

      // Create page object used in template
      function makePage(number, text, isActive) {
        return {
          number: number,
          text: text,
          active: isActive
        };
      }

      function getPages(currentPage, totalPages) {
        var pages = [];

        // Default page limits
        var startPage = 1, endPage = totalPages;
        var isMaxSized = ( angular.isDefined(maxSize) && maxSize < totalPages );

        // recompute if maxSize
        if ( isMaxSized ) {
          if ( rotate ) {
            // Current page is displayed in the middle of the visible ones
            startPage = Math.max(currentPage - Math.floor(maxSize/2), 1);
            endPage   = startPage + maxSize - 1;

            // Adjust if limit is exceeded
            if (endPage > totalPages) {
              endPage   = totalPages;
              startPage = endPage - maxSize + 1;
            }
          } else {
            // Visible pages are paginated with maxSize
            startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;

            // Adjust last page if limit is exceeded
            endPage = Math.min(startPage + maxSize - 1, totalPages);
          }
        }

        // Add page number links
        for (var number = startPage; number <= endPage; number++) {
          var page = makePage(number, number, number === currentPage);
          pages.push(page);
        }

        // Add links to move between page sets
        if ( isMaxSized && ! rotate ) {
          if ( startPage > 1 ) {
            var previousPageSet = makePage(startPage - 1, '...', false);
            pages.unshift(previousPageSet);
          }

          if ( endPage < totalPages ) {
            var nextPageSet = makePage(endPage + 1, '...', false);
            pages.push(nextPageSet);
          }
        }

        return pages;
      }

      var originalRender = paginationCtrl.render;
      paginationCtrl.render = function() {
        originalRender();
        if (scope.page > 0 && scope.page <= scope.totalPages) {
          scope.pages = getPages(scope.page, scope.totalPages);
        }
      };
    }
  };
}])

.constant('pagerConfig', {
  itemsPerPage: 10,
  previousText: 'Â« Previous',
  nextText: 'Next Â»',
  align: true
})

.directive('pager', ['pagerConfig', function(pagerConfig) {
  return {
    restrict: 'EA',
    scope: {
      totalItems: '=',
      previousText: '@',
      nextText: '@'
    },
    require: ['pager', '?ngModel'],
    controller: 'PaginationController',
    templateUrl: 'template/pagination/pager.html',
    replace: true,
    link: function(scope, element, attrs, ctrls) {
      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if (!ngModelCtrl) {
         return; // do nothing if no ng-model
      }

      scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align;
      paginationCtrl.init(ngModelCtrl, pagerConfig);
    }
  };
}]);

angular.module('ui.bootstrap.progressbar', [])

.constant('progressConfig', {
  animate: true,
  max: 100
})

.controller('ProgressController', ['$scope', '$attrs', 'progressConfig', function($scope, $attrs, progressConfig) {
    var self = this,
        animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;

    this.bars = [];
    $scope.max = angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : progressConfig.max;

    this.addBar = function(bar, element) {
        if ( !animate ) {
            element.css({'transition': 'none'});
        }

        this.bars.push(bar);

        bar.$watch('value', function( value ) {
            bar.percent = +(100 * value / $scope.max).toFixed(2);
        });

        bar.$on('$destroy', function() {
            element = null;
            self.removeBar(bar);
        });
    };

    this.removeBar = function(bar) {
        this.bars.splice(this.bars.indexOf(bar), 1);
    };
}])

.directive('progress', function() {
    return {
        restrict: 'EA',
        replace: true,
        transclude: true,
        controller: 'ProgressController',
        require: 'progress',
        scope: {},
        templateUrl: 'template/progressbar/progress.html'
    };
})

.directive('bar', function() {
    return {
        restrict: 'EA',
        replace: true,
        transclude: true,
        require: '^progress',
        scope: {
            value: '=',
            type: '@'
        },
        templateUrl: 'template/progressbar/bar.html',
        link: function(scope, element, attrs, progressCtrl) {
            progressCtrl.addBar(scope, element);
        }
    };
})

.directive('progressbar', function() {
    return {
        restrict: 'EA',
        replace: true,
        transclude: true,
        controller: 'ProgressController',
        scope: {
            value: '=',
            type: '@'
        },
        templateUrl: 'template/progressbar/progressbar.html',
        link: function(scope, element, attrs, progressCtrl) {
            progressCtrl.addBar(scope, angular.element(element.children()[0]));
        }
    };
});
angular.module('ui.bootstrap.rating', [])

.constant('ratingConfig', {
  max: 5,
  stateOn: null,
  stateOff: null
})

.controller('RatingController', ['$scope', '$attrs', 'ratingConfig', function($scope, $attrs, ratingConfig) {
  var ngModelCtrl  = { $setViewValue: angular.noop };

  this.init = function(ngModelCtrl_) {
    ngModelCtrl = ngModelCtrl_;
    ngModelCtrl.$render = this.render;

    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;
    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;

    var ratingStates = angular.isDefined($attrs.ratingStates) ? $scope.$parent.$eval($attrs.ratingStates) :
                        new Array( angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max );
    $scope.range = this.buildTemplateObjects(ratingStates);
  };

  this.buildTemplateObjects = function(states) {
    for (var i = 0, n = states.length; i < n; i++) {
      states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff }, states[i]);
    }
    return states;
  };

  $scope.rate = function(value) {
    if ( !$scope.readonly && value >= 0 && value <= $scope.range.length ) {
      ngModelCtrl.$setViewValue(value);
      ngModelCtrl.$render();
    }
  };

  $scope.enter = function(value) {
    if ( !$scope.readonly ) {
      $scope.value = value;
    }
    $scope.onHover({value: value});
  };

  $scope.reset = function() {
    $scope.value = ngModelCtrl.$viewValue;
    $scope.onLeave();
  };

  $scope.onKeydown = function(evt) {
    if (/(37|38|39|40)/.test(evt.which)) {
      evt.preventDefault();
      evt.stopPropagation();
      $scope.rate( $scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1) );
    }
  };

  this.render = function() {
    $scope.value = ngModelCtrl.$viewValue;
  };
}])

.directive('rating', function() {
  return {
    restrict: 'EA',
    require: ['rating', 'ngModel'],
    scope: {
      readonly: '=?',
      onHover: '&',
      onLeave: '&'
    },
    controller: 'RatingController',
    templateUrl: 'template/rating/rating.html',
    replace: true,
    link: function(scope, element, attrs, ctrls) {
      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if ( ngModelCtrl ) {
        ratingCtrl.init( ngModelCtrl );
      }
    }
  };
});

/**
 * @ngdoc overview
 * @name ui.bootstrap.tabs
 *
 * @description
 * AngularJS version of the tabs directive.
 */

angular.module('ui.bootstrap.tabs', [])

.controller('TabsetController', ['$scope', function TabsetCtrl($scope) {
  var ctrl = this,
      tabs = ctrl.tabs = $scope.tabs = [];

  ctrl.select = function(selectedTab) {
    angular.forEach(tabs, function(tab) {
      if (tab.active && tab !== selectedTab) {
        tab.active = false;
        tab.onDeselect();
      }
    });
    selectedTab.active = true;
    selectedTab.onSelect();
  };

  ctrl.addTab = function addTab(tab) {
    tabs.push(tab);
    // we can't run the select function on the first tab
    // since that would select it twice
    if (tabs.length === 1) {
      tab.active = true;
    } else if (tab.active) {
      ctrl.select(tab);
    }
  };

  ctrl.removeTab = function removeTab(tab) {
    var index = tabs.indexOf(tab);
    //Select a new tab if the tab to be removed is selected
    if (tab.active && tabs.length > 1) {
      //If this is the last tab, select the previous tab. else, the next tab.
      var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;
      ctrl.select(tabs[newActiveIndex]);
    }
    tabs.splice(index, 1);
  };
}])

/**
 * @ngdoc directive
 * @name ui.bootstrap.tabs.directive:tabset
 * @restrict EA
 *
 * @description
 * Tabset is the outer container for the tabs directive
 *
 * @param {boolean=} vertical Whether or not to use vertical styling for the tabs.
 * @param {boolean=} justified Whether or not to use justified styling for the tabs.
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
    <tabset>
      <tab heading="Tab 1"><b>First</b> Content!</tab>
      <tab heading="Tab 2"><i>Second</i> Content!</tab>
    </tabset>
    <hr />
    <tabset vertical="true">
      <tab heading="Vertical Tab 1"><b>First</b> Vertical Content!</tab>
      <tab heading="Vertical Tab 2"><i>Second</i> Vertical Content!</tab>
    </tabset>
    <tabset justified="true">
      <tab heading="Justified Tab 1"><b>First</b> Justified Content!</tab>
      <tab heading="Justified Tab 2"><i>Second</i> Justified Content!</tab>
    </tabset>
  </file>
</example>
 */
.directive('tabset', function() {
  return {
    restrict: 'EA',
    transclude: true,
    replace: true,
    scope: {
      type: '@'
    },
    controller: 'TabsetController',
    templateUrl: 'template/tabs/tabset.html',
    link: function(scope, element, attrs) {
      scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;
      scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;
    }
  };
})

/**
 * @ngdoc directive
 * @name ui.bootstrap.tabs.directive:tab
 * @restrict EA
 *
 * @param {string=} heading The visible heading, or title, of the tab. Set HTML headings with {@link ui.bootstrap.tabs.directive:tabHeading tabHeading}.
 * @param {string=} select An expression to evaluate when the tab is selected.
 * @param {boolean=} active A binding, telling whether or not this tab is selected.
 * @param {boolean=} disabled A binding, telling whether or not this tab is disabled.
 *
 * @description
 * Creates a tab with a heading and content. Must be placed within a {@link ui.bootstrap.tabs.directive:tabset tabset}.
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
    <div ng-controller="TabsDemoCtrl">
      <button class="btn btn-small" ng-click="items[0].active = true">
        Select item 1, using active binding
      </button>
      <button class="btn btn-small" ng-click="items[1].disabled = !items[1].disabled">
        Enable/disable item 2, using disabled binding
      </button>
      <br />
      <tabset>
        <tab heading="Tab 1">First Tab</tab>
        <tab select="alertMe()">
          <tab-heading><i class="icon-bell"></i> Alert me!</tab-heading>
          Second Tab, with alert callback and html heading!
        </tab>
        <tab ng-repeat="item in items"
          heading="{{item.title}}"
          disabled="item.disabled"
          active="item.active">
          {{item.content}}
        </tab>
      </tabset>
    </div>
  </file>
  <file name="script.js">
    function TabsDemoCtrl($scope) {
      $scope.items = [
        { title:"Dynamic Title 1", content:"Dynamic Item 0" },
        { title:"Dynamic Title 2", content:"Dynamic Item 1", disabled: true }
      ];

      $scope.alertMe = function() {
        setTimeout(function() {
          alert("You've selected the alert tab!");
        });
      };
    };
  </file>
</example>
 */

/**
 * @ngdoc directive
 * @name ui.bootstrap.tabs.directive:tabHeading
 * @restrict EA
 *
 * @description
 * Creates an HTML heading for a {@link ui.bootstrap.tabs.directive:tab tab}. Must be placed as a child of a tab element.
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
    <tabset>
      <tab>
        <tab-heading><b>HTML</b> in my titles?!</tab-heading>
        And some content, too!
      </tab>
      <tab>
        <tab-heading><i class="icon-heart"></i> Icon heading?!?</tab-heading>
        That's right.
      </tab>
    </tabset>
  </file>
</example>
 */
.directive('tab', ['$parse', function($parse) {
  return {
    require: '^tabset',
    restrict: 'EA',
    replace: true,
    templateUrl: 'template/tabs/tab.html',
    transclude: true,
    scope: {
      active: '=?',
      heading: '@',
      onSelect: '&select', //This callback is called in contentHeadingTransclude
                          //once it inserts the tab's content into the dom
      onDeselect: '&deselect'
    },
    controller: function() {
      //Empty controller so other directives can require being 'under' a tab
    },
    compile: function(elm, attrs, transclude) {
      return function postLink(scope, elm, attrs, tabsetCtrl) {
        scope.$watch('active', function(active) {
          if (active) {
            tabsetCtrl.select(scope);
          }
        });

        scope.disabled = false;
        if ( attrs.disabled ) {
          scope.$parent.$watch($parse(attrs.disabled), function(value) {
            scope.disabled = !! value;
          });
        }

        scope.select = function() {
          if ( !scope.disabled ) {
            scope.active = true;
          }
        };

        tabsetCtrl.addTab(scope);
        scope.$on('$destroy', function() {
          tabsetCtrl.removeTab(scope);
        });

        //We need to transclude later, once the content container is ready.
        //when this link happens, we're inside a tab heading.
        scope.$transcludeFn = transclude;
      };
    }
  };
}])

.directive('tabHeadingTransclude', [function() {
  return {
    restrict: 'A',
    require: '^tab',
    link: function(scope, elm, attrs, tabCtrl) {
      scope.$watch('headingElement', function updateHeadingElement(heading) {
        if (heading) {
          elm.html('');
          elm.append(heading);
        }
      });
    }
  };
}])

.directive('tabContentTransclude', function() {
  return {
    restrict: 'A',
    require: '^tabset',
    link: function(scope, elm, attrs) {
      var tab = scope.$eval(attrs.tabContentTransclude);

      //Now our tab is ready to be transcluded: both the tab heading area
      //and the tab content area are loaded.  Transclude 'em both.
      tab.$transcludeFn(tab.$parent, function(contents) {
        angular.forEach(contents, function(node) {
          if (isTabHeading(node)) {
            //Let tabHeadingTransclude know.
            tab.headingElement = node;
          } else {
            elm.append(node);
          }
        });
      });
    }
  };
  function isTabHeading(node) {
    return node.tagName &&  (
      node.hasAttribute('tab-heading') ||
      node.hasAttribute('data-tab-heading') ||
      node.tagName.toLowerCase() === 'tab-heading' ||
      node.tagName.toLowerCase() === 'data-tab-heading'
    );
  }
})

;

angular.module('ui.bootstrap.timepicker', [])

.constant('timepickerConfig', {
  hourStep: 1,
  minuteStep: 1,
  showMeridian: true,
  meridians: null,
  readonlyInput: false,
  mousewheel: true
})

.controller('TimepickerController', ['$scope', '$attrs', '$parse', '$log', '$locale', 'timepickerConfig', function($scope, $attrs, $parse, $log, $locale, timepickerConfig) {
  var selected = new Date(),
      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl
      meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS;

  this.init = function( ngModelCtrl_, inputs ) {
    ngModelCtrl = ngModelCtrl_;
    ngModelCtrl.$render = this.render;

    var hoursInputEl = inputs.eq(0),
        minutesInputEl = inputs.eq(1);

    var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;
    if ( mousewheel ) {
      this.setupMousewheelEvents( hoursInputEl, minutesInputEl );
    }

    $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;
    this.setupInputEvents( hoursInputEl, minutesInputEl );
  };

  var hourStep = timepickerConfig.hourStep;
  if ($attrs.hourStep) {
    $scope.$parent.$watch($parse($attrs.hourStep), function(value) {
      hourStep = parseInt(value, 10);
    });
  }

  var minuteStep = timepickerConfig.minuteStep;
  if ($attrs.minuteStep) {
    $scope.$parent.$watch($parse($attrs.minuteStep), function(value) {
      minuteStep = parseInt(value, 10);
    });
  }

  // 12H / 24H mode
  $scope.showMeridian = timepickerConfig.showMeridian;
  if ($attrs.showMeridian) {
    $scope.$parent.$watch($parse($attrs.showMeridian), function(value) {
      $scope.showMeridian = !!value;

      if ( ngModelCtrl.$error.time ) {
        // Evaluate from template
        var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
        if (angular.isDefined( hours ) && angular.isDefined( minutes )) {
          selected.setHours( hours );
          refresh();
        }
      } else {
        updateTemplate();
      }
    });
  }

  // Get $scope.hours in 24H mode if valid
  function getHoursFromTemplate ( ) {
    var hours = parseInt( $scope.hours, 10 );
    var valid = ( $scope.showMeridian ) ? (hours > 0 && hours < 13) : (hours >= 0 && hours < 24);
    if ( !valid ) {
      return undefined;
    }

    if ( $scope.showMeridian ) {
      if ( hours === 12 ) {
        hours = 0;
      }
      if ( $scope.meridian === meridians[1] ) {
        hours = hours + 12;
      }
    }
    return hours;
  }

  function getMinutesFromTemplate() {
    var minutes = parseInt($scope.minutes, 10);
    return ( minutes >= 0 && minutes < 60 ) ? minutes : undefined;
  }

  function pad( value ) {
    return ( angular.isDefined(value) && value.toString().length < 2 ) ? '0' + value : value;
  }

  // Respond on mousewheel spin
  this.setupMousewheelEvents = function( hoursInputEl, minutesInputEl ) {
    var isScrollingUp = function(e) {
      if (e.originalEvent) {
        e = e.originalEvent;
      }
      //pick correct delta variable depending on event
      var delta = (e.wheelDelta) ? e.wheelDelta : -e.deltaY;
      return (e.detail || delta > 0);
    };

    hoursInputEl.bind('mousewheel wheel', function(e) {
      $scope.$apply( (isScrollingUp(e)) ? $scope.incrementHours() : $scope.decrementHours() );
      e.preventDefault();
    });

    minutesInputEl.bind('mousewheel wheel', function(e) {
      $scope.$apply( (isScrollingUp(e)) ? $scope.incrementMinutes() : $scope.decrementMinutes() );
      e.preventDefault();
    });

  };

  this.setupInputEvents = function( hoursInputEl, minutesInputEl ) {
    if ( $scope.readonlyInput ) {
      $scope.updateHours = angular.noop;
      $scope.updateMinutes = angular.noop;
      return;
    }

    var invalidate = function(invalidHours, invalidMinutes) {
      ngModelCtrl.$setViewValue( null );
      ngModelCtrl.$setValidity('time', false);
      if (angular.isDefined(invalidHours)) {
        $scope.invalidHours = invalidHours;
      }
      if (angular.isDefined(invalidMinutes)) {
        $scope.invalidMinutes = invalidMinutes;
      }
    };

    $scope.updateHours = function() {
      var hours = getHoursFromTemplate();

      if ( angular.isDefined(hours) ) {
        selected.setHours( hours );
        refresh( 'h' );
      } else {
        invalidate(true);
      }
    };

    hoursInputEl.bind('blur', function(e) {
      if ( !$scope.invalidHours && $scope.hours < 10) {
        $scope.$apply( function() {
          $scope.hours = pad( $scope.hours );
        });
      }
    });

    $scope.updateMinutes = function() {
      var minutes = getMinutesFromTemplate();

      if ( angular.isDefined(minutes) ) {
        selected.setMinutes( minutes );
        refresh( 'm' );
      } else {
        invalidate(undefined, true);
      }
    };

    minutesInputEl.bind('blur', function(e) {
      if ( !$scope.invalidMinutes && $scope.minutes < 10 ) {
        $scope.$apply( function() {
          $scope.minutes = pad( $scope.minutes );
        });
      }
    });

  };

  this.render = function() {
    var date = ngModelCtrl.$modelValue ? new Date( ngModelCtrl.$modelValue ) : null;

    if ( isNaN(date) ) {
      ngModelCtrl.$setValidity('time', false);
      $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
    } else {
      if ( date ) {
        selected = date;
      }
      makeValid();
      updateTemplate();
    }
  };

  // Call internally when we know that model is valid.
  function refresh( keyboardChange ) {
    makeValid();
    ngModelCtrl.$setViewValue( new Date(selected) );
    updateTemplate( keyboardChange );
  }

  function makeValid() {
    ngModelCtrl.$setValidity('time', true);
    $scope.invalidHours = false;
    $scope.invalidMinutes = false;
  }

  function updateTemplate( keyboardChange ) {
    var hours = selected.getHours(), minutes = selected.getMinutes();

    if ( $scope.showMeridian ) {
      hours = ( hours === 0 || hours === 12 ) ? 12 : hours % 12; // Convert 24 to 12 hour system
    }

    $scope.hours = keyboardChange === 'h' ? hours : pad(hours);
    $scope.minutes = keyboardChange === 'm' ? minutes : pad(minutes);
    $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
  }

  function addMinutes( minutes ) {
    var dt = new Date( selected.getTime() + minutes * 60000 );
    selected.setHours( dt.getHours(), dt.getMinutes() );
    refresh();
  }

  $scope.incrementHours = function() {
    addMinutes( hourStep * 60 );
  };
  $scope.decrementHours = function() {
    addMinutes( - hourStep * 60 );
  };
  $scope.incrementMinutes = function() {
    addMinutes( minuteStep );
  };
  $scope.decrementMinutes = function() {
    addMinutes( - minuteStep );
  };
  $scope.toggleMeridian = function() {
    addMinutes( 12 * 60 * (( selected.getHours() < 12 ) ? 1 : -1) );
  };
}])

.directive('timepicker', function () {
  return {
    restrict: 'EA',
    require: ['timepicker', '?^ngModel'],
    controller:'TimepickerController',
    replace: true,
    scope: {},
    templateUrl: 'template/timepicker/timepicker.html',
    link: function(scope, element, attrs, ctrls) {
      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if ( ngModelCtrl ) {
        timepickerCtrl.init( ngModelCtrl, element.find('input') );
      }
    }
  };
});

angular.module('ui.bootstrap.typeahead', ['ui.bootstrap.position', 'ui.bootstrap.bindHtml'])

/**
 * A helper service that can parse typeahead's syntax (string provided by users)
 * Extracted to a separate service for ease of unit testing
 */
  .factory('typeaheadParser', ['$parse', function ($parse) {

  //                      00000111000000000000022200000000000000003333333333333330000000000044000
  var TYPEAHEAD_REGEXP = /^\s*(.*?)(?:\s+as\s+(.*?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+(.*)$/;

  return {
    parse:function (input) {

      var match = input.match(TYPEAHEAD_REGEXP);
      if (!match) {
        throw new Error(
          'Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_"' +
            ' but got "' + input + '".');
      }

      return {
        itemName:match[3],
        source:$parse(match[4]),
        viewMapper:$parse(match[2] || match[1]),
        modelMapper:$parse(match[1])
      };
    }
  };
}])

  .directive('typeahead', ['$compile', '$parse', '$q', '$timeout', '$document', '$position', 'typeaheadParser',
    function ($compile, $parse, $q, $timeout, $document, $position, typeaheadParser) {

  var HOT_KEYS = [9, 13, 27, 38, 40];

  return {
    require:'ngModel',
    link:function (originalScope, element, attrs, modelCtrl) {

      //SUPPORTED ATTRIBUTES (OPTIONS)

      //minimal no of characters that needs to be entered before typeahead kicks-in
      var minSearch = originalScope.$eval(attrs.typeaheadMinLength) || 1;

      //minimal wait time after last character typed before typehead kicks-in
      var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;

      //should it restrict model values to the ones selected from the popup only?
      var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;

      //binding to a variable that indicates if matches are being retrieved asynchronously
      var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;

      //a callback executed when a match is selected
      var onSelectCallback = $parse(attrs.typeaheadOnSelect);

      var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;

      var appendToBody =  attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;

      //INTERNAL VARIABLES

      //model setter executed upon match selection
      var $setModelValue = $parse(attrs.ngModel).assign;

      //expressions used by typeahead
      var parserResult = typeaheadParser.parse(attrs.typeahead);

      var hasFocus;

      //create a child scope for the typeahead directive so we are not polluting original scope
      //with typeahead-specific data (matches, query etc.)
      var scope = originalScope.$new();
      originalScope.$on('$destroy', function(){
        scope.$destroy();
      });

      // WAI-ARIA
      var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
      element.attr({
        'aria-autocomplete': 'list',
        'aria-expanded': false,
        'aria-owns': popupId
      });

      //pop-up element used to display matches
      var popUpEl = angular.element('<div typeahead-popup></div>');
      popUpEl.attr({
        id: popupId,
        matches: 'matches',
        active: 'activeIdx',
        select: 'select(activeIdx)',
        query: 'query',
        position: 'position'
      });
      //custom item template
      if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
        popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);
      }

      var resetMatches = function() {
        scope.matches = [];
        scope.activeIdx = -1;
        element.attr('aria-expanded', false);
      };

      var getMatchId = function(index) {
        return popupId + '-option-' + index;
      };

      // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.
      // This attribute is added or removed automatically when the `activeIdx` changes.
      scope.$watch('activeIdx', function(index) {
        if (index < 0) {
          element.removeAttr('aria-activedescendant');
        } else {
          element.attr('aria-activedescendant', getMatchId(index));
        }
      });

      var getMatchesAsync = function(inputValue) {

        var locals = {$viewValue: inputValue};
        isLoadingSetter(originalScope, true);
        $q.when(parserResult.source(originalScope, locals)).then(function(matches) {

          //it might happen that several async queries were in progress if a user were typing fast
          //but we are interested only in responses that correspond to the current view value
          var onCurrentRequest = (inputValue === modelCtrl.$viewValue);
          if (onCurrentRequest && hasFocus) {
            if (matches && matches.length > 0) {

              scope.activeIdx = 0;
              scope.matches.length = 0;

              //transform labels
              for(var i=0; i<matches.length; i++) {
                locals[parserResult.itemName] = matches[i];
                scope.matches.push({
                  id: getMatchId(i),
                  label: parserResult.viewMapper(scope, locals),
                  model: matches[i]
                });
              }

              scope.query = inputValue;
              //position pop-up with matches - we need to re-calculate its position each time we are opening a window
              //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page
              //due to other elements being rendered
              scope.position = appendToBody ? $position.offset(element) : $position.position(element);
              scope.position.top = scope.position.top + element.prop('offsetHeight');

              element.attr('aria-expanded', true);
            } else {
              resetMatches();
            }
          }
          if (onCurrentRequest) {
            isLoadingSetter(originalScope, false);
          }
        }, function(){
          resetMatches();
          isLoadingSetter(originalScope, false);
        });
      };

      resetMatches();

      //we need to propagate user's query so we can higlight matches
      scope.query = undefined;

      //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later
      var timeoutPromise;

      //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM
      //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue
      modelCtrl.$parsers.unshift(function (inputValue) {

        hasFocus = true;

        if (inputValue && inputValue.length >= minSearch) {
          if (waitTime > 0) {
            if (timeoutPromise) {
              $timeout.cancel(timeoutPromise);//cancel previous timeout
            }
            timeoutPromise = $timeout(function () {
              getMatchesAsync(inputValue);
            }, waitTime);
          } else {
            getMatchesAsync(inputValue);
          }
        } else {
          isLoadingSetter(originalScope, false);
          resetMatches();
        }

        if (isEditable) {
          return inputValue;
        } else {
          if (!inputValue) {
            // Reset in case user had typed something previously.
            modelCtrl.$setValidity('editable', true);
            return inputValue;
          } else {
            modelCtrl.$setValidity('editable', false);
            return undefined;
          }
        }
      });

      modelCtrl.$formatters.push(function (modelValue) {

        var candidateViewValue, emptyViewValue;
        var locals = {};

        if (inputFormatter) {

          locals['$model'] = modelValue;
          return inputFormatter(originalScope, locals);

        } else {

          //it might happen that we don't have enough info to properly render input value
          //we need to check for this situation and simply return model value if we can't apply custom formatting
          locals[parserResult.itemName] = modelValue;
          candidateViewValue = parserResult.viewMapper(originalScope, locals);
          locals[parserResult.itemName] = undefined;
          emptyViewValue = parserResult.viewMapper(originalScope, locals);

          return candidateViewValue!== emptyViewValue ? candidateViewValue : modelValue;
        }
      });

      scope.select = function (activeIdx) {
        //called from within the $digest() cycle
        var locals = {};
        var model, item;

        locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
        model = parserResult.modelMapper(originalScope, locals);
        $setModelValue(originalScope, model);
        modelCtrl.$setValidity('editable', true);

        onSelectCallback(originalScope, {
          $item: item,
          $model: model,
          $label: parserResult.viewMapper(originalScope, locals)
        });

        resetMatches();

        //return focus to the input element if a match was selected via a mouse click event
        // use timeout to avoid $rootScope:inprog error
        $timeout(function() { element[0].focus(); }, 0, false);
      };

      //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)
      element.bind('keydown', function (evt) {

        //typeahead is open and an "interesting" key was pressed
        if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
          return;
        }

        evt.preventDefault();

        if (evt.which === 40) {
          scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
          scope.$digest();

        } else if (evt.which === 38) {
          scope.activeIdx = (scope.activeIdx ? scope.activeIdx : scope.matches.length) - 1;
          scope.$digest();

        } else if (evt.which === 13 || evt.which === 9) {
          scope.$apply(function () {
            scope.select(scope.activeIdx);
          });

        } else if (evt.which === 27) {
          evt.stopPropagation();

          resetMatches();
          scope.$digest();
        }
      });

      element.bind('blur', function (evt) {
        hasFocus = false;
      });

      // Keep reference to click handler to unbind it.
      var dismissClickHandler = function (evt) {
        if (element[0] !== evt.target) {
          resetMatches();
          scope.$digest();
        }
      };

      $document.bind('click', dismissClickHandler);

      originalScope.$on('$destroy', function(){
        $document.unbind('click', dismissClickHandler);
      });

      var $popup = $compile(popUpEl)(scope);
      if ( appendToBody ) {
        $document.find('body').append($popup);
      } else {
        element.after($popup);
      }
    }
  };

}])

  .directive('typeaheadPopup', function () {
    return {
      restrict:'EA',
      scope:{
        matches:'=',
        query:'=',
        active:'=',
        position:'=',
        select:'&'
      },
      replace:true,
      templateUrl:'template/typeahead/typeahead-popup.html',
      link:function (scope, element, attrs) {

        scope.templateUrl = attrs.templateUrl;

        scope.isOpen = function () {
          return scope.matches.length > 0;
        };

        scope.isActive = function (matchIdx) {
          return scope.active == matchIdx;
        };

        scope.selectActive = function (matchIdx) {
          scope.active = matchIdx;
        };

        scope.selectMatch = function (activeIdx) {
          scope.select({activeIdx:activeIdx});
        };
      }
    };
  })

  .directive('typeaheadMatch', ['$http', '$templateCache', '$compile', '$parse', function ($http, $templateCache, $compile, $parse) {
    return {
      restrict:'EA',
      scope:{
        index:'=',
        match:'=',
        query:'='
      },
      link:function (scope, element, attrs) {
        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'template/typeahead/typeahead-match.html';
        $http.get(tplUrl, {cache: $templateCache}).success(function(tplContent){
           element.replaceWith($compile(tplContent.trim())(scope));
        });
      }
    };
  }])

  .filter('typeaheadHighlight', function() {

    function escapeRegexp(queryToEscape) {
      return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
    }

    return function(matchItem, query) {
      return query ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem;
    };
  });

angular.module("template/accordion/accordion-group.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/accordion/accordion-group.html",
    "<div class=\"panel panel-default\">\n" +
    "  <div class=\"panel-heading\">\n" +
    "    <h4 class=\"panel-title\">\n" +
    "      <a class=\"accordion-toggle\" ng-click=\"toggleOpen()\" accordion-transclude=\"heading\"><span ng-class=\"{'text-muted': isDisabled}\">{{heading}}</span></a>\n" +
    "    </h4>\n" +
    "  </div>\n" +
    "  <div class=\"panel-collapse\" collapse=\"!isOpen\">\n" +
    "     <div class=\"panel-body\" ng-transclude></div>\n" +
    "  </div>\n" +
    "</div>");
}]);

angular.module("template/accordion/accordion.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/accordion/accordion.html",
    "<div class=\"panel-group\" ng-transclude></div>");
}]);

angular.module("template/alert/alert.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/alert/alert.html",
    "<div class=\"alert\" ng-class=\"{'alert-{{type || 'warning'}}': true, 'alert-dismissable': closeable}\" role=\"alert\">\n" +
    "    <button ng-show=\"closeable\" type=\"button\" class=\"close\" ng-click=\"close()\">\n" +
    "        <span aria-hidden=\"true\">&times;</span>\n" +
    "        <span class=\"sr-only\">Close</span>\n" +
    "    </button>\n" +
    "    <div ng-transclude></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/carousel/carousel.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/carousel/carousel.html",
    "<div ng-mouseenter=\"pause()\" ng-mouseleave=\"play()\" class=\"carousel\" ng-swipe-right=\"prev()\" ng-swipe-left=\"next()\">\n" +
    "    <ol class=\"carousel-indicators\" ng-show=\"slides.length > 1\">\n" +
    "        <li ng-repeat=\"slide in slides track by $index\" ng-class=\"{active: isActive(slide)}\" ng-click=\"select(slide)\"></li>\n" +
    "    </ol>\n" +
    "    <div class=\"carousel-inner\" ng-transclude></div>\n" +
    "    <a class=\"left carousel-control\" ng-click=\"prev()\" ng-show=\"slides.length > 1\"><span class=\"glyphicon glyphicon-chevron-left\"></span></a>\n" +
    "    <a class=\"right carousel-control\" ng-click=\"next()\" ng-show=\"slides.length > 1\"><span class=\"glyphicon glyphicon-chevron-right\"></span></a>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/carousel/slide.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/carousel/slide.html",
    "<div ng-class=\"{\n" +
    "    'active': leaving || (active && !entering),\n" +
    "    'prev': (next || active) && direction=='prev',\n" +
    "    'next': (next || active) && direction=='next',\n" +
    "    'right': direction=='prev',\n" +
    "    'left': direction=='next'\n" +
    "  }\" class=\"item text-center\" ng-transclude></div>\n" +
    "");
}]);

angular.module("template/datepicker/datepicker.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/datepicker/datepicker.html",
    "<div ng-switch=\"datepickerMode\" role=\"application\" ng-keydown=\"keydown($event)\">\n" +
    "  <daypicker ng-switch-when=\"day\" tabindex=\"0\"></daypicker>\n" +
    "  <monthpicker ng-switch-when=\"month\" tabindex=\"0\"></monthpicker>\n" +
    "  <yearpicker ng-switch-when=\"year\" tabindex=\"0\"></yearpicker>\n" +
    "</div>");
}]);

angular.module("template/datepicker/day.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/datepicker/day.html",
    "<table role=\"grid\" aria-labelledby=\"{{uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
    "  <thead>\n" +
    "    <tr>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" +
    "      <th colspan=\"{{5 + showWeeks}}\"><button id=\"{{uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm\" ng-click=\"toggleMode()\" tabindex=\"-1\" style=\"width:100%;\"><strong>{{title}}</strong></button></th>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" +
    "    </tr>\n" +
    "    <tr>\n" +
    "      <th ng-show=\"showWeeks\" class=\"text-center\"></th>\n" +
    "      <th ng-repeat=\"label in labels track by $index\" class=\"text-center\"><small aria-label=\"{{label.full}}\">{{label.abbr}}</small></th>\n" +
    "    </tr>\n" +
    "  </thead>\n" +
    "  <tbody>\n" +
    "    <tr ng-repeat=\"row in rows track by $index\">\n" +
    "      <td ng-show=\"showWeeks\" class=\"text-center h6\"><em>{{ weekNumbers[$index] }}</em></td>\n" +
    "      <td ng-repeat=\"dt in row track by dt.date\" class=\"text-center\" role=\"gridcell\" id=\"{{dt.uid}}\" aria-disabled=\"{{!!dt.disabled}}\">\n" +
    "        <button type=\"button\" style=\"width:100%;\" class=\"btn btn-default btn-sm\" ng-class=\"{'btn-info': dt.selected, active: isActive(dt)}\" ng-click=\"select(dt.date)\" ng-disabled=\"dt.disabled\" tabindex=\"-1\"><span ng-class=\"{'text-muted': dt.secondary, 'text-info': dt.current}\">{{dt.label}}</span></button>\n" +
    "      </td>\n" +
    "    </tr>\n" +
    "  </tbody>\n" +
    "</table>\n" +
    "");
}]);

angular.module("template/datepicker/month.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/datepicker/month.html",
    "<table role=\"grid\" aria-labelledby=\"{{uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
    "  <thead>\n" +
    "    <tr>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" +
    "      <th><button id=\"{{uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm\" ng-click=\"toggleMode()\" tabindex=\"-1\" style=\"width:100%;\"><strong>{{title}}</strong></button></th>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" +
    "    </tr>\n" +
    "  </thead>\n" +
    "  <tbody>\n" +
    "    <tr ng-repeat=\"row in rows track by $index\">\n" +
    "      <td ng-repeat=\"dt in row track by dt.date\" class=\"text-center\" role=\"gridcell\" id=\"{{dt.uid}}\" aria-disabled=\"{{!!dt.disabled}}\">\n" +
    "        <button type=\"button\" style=\"width:100%;\" class=\"btn btn-default\" ng-class=\"{'btn-info': dt.selected, active: isActive(dt)}\" ng-click=\"select(dt.date)\" ng-disabled=\"dt.disabled\" tabindex=\"-1\"><span ng-class=\"{'text-info': dt.current}\">{{dt.label}}</span></button>\n" +
    "      </td>\n" +
    "    </tr>\n" +
    "  </tbody>\n" +
    "</table>\n" +
    "");
}]);

angular.module("template/datepicker/popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/datepicker/popup.html",
    "<ul class=\"dropdown-menu\" ng-style=\"{display: (isOpen && 'block') || 'none', top: position.top+'px', left: position.left+'px'}\" ng-keydown=\"keydown($event)\">\n" +
    "   <li ng-transclude></li>\n" +
    "   <li ng-if=\"showButtonBar\" style=\"padding:10px 9px 2px\">\n" +
    "       <span class=\"btn-group\">\n" +
    "           <button type=\"button\" class=\"btn btn-sm btn-info\" ng-click=\"select('today')\">{{ getText('current') }}</button>\n" +
    "           <button type=\"button\" class=\"btn btn-sm btn-danger\" ng-click=\"select(null)\">{{ getText('clear') }}</button>\n" +
    "       </span>\n" +
    "       <button type=\"button\" class=\"btn btn-sm btn-success pull-right\" ng-click=\"close()\">{{ getText('close') }}</button>\n" +
    "   </li>\n" +
    "</ul>\n" +
    "");
}]);

angular.module("template/datepicker/year.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/datepicker/year.html",
    "<table role=\"grid\" aria-labelledby=\"{{uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
    "  <thead>\n" +
    "    <tr>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" +
    "      <th colspan=\"3\"><button id=\"{{uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm\" ng-click=\"toggleMode()\" tabindex=\"-1\" style=\"width:100%;\"><strong>{{title}}</strong></button></th>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" +
    "    </tr>\n" +
    "  </thead>\n" +
    "  <tbody>\n" +
    "    <tr ng-repeat=\"row in rows track by $index\">\n" +
    "      <td ng-repeat=\"dt in row track by dt.date\" class=\"text-center\" role=\"gridcell\" id=\"{{dt.uid}}\" aria-disabled=\"{{!!dt.disabled}}\">\n" +
    "        <button type=\"button\" style=\"width:100%;\" class=\"btn btn-default\" ng-class=\"{'btn-info': dt.selected, active: isActive(dt)}\" ng-click=\"select(dt.date)\" ng-disabled=\"dt.disabled\" tabindex=\"-1\"><span ng-class=\"{'text-info': dt.current}\">{{dt.label}}</span></button>\n" +
    "      </td>\n" +
    "    </tr>\n" +
    "  </tbody>\n" +
    "</table>\n" +
    "");
}]);

angular.module("template/modal/backdrop.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/modal/backdrop.html",
    "<div class=\"modal-backdrop fade\"\n" +
    "     ng-class=\"{in: animate}\"\n" +
    "     ng-style=\"{'z-index': 1040 + (index && 1 || 0) + index*10}\"\n" +
    "></div>\n" +
    "");
}]);

angular.module("template/modal/window.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/modal/window.html",
    "<div tabindex=\"-1\" role=\"dialog\" class=\"modal fade\" ng-class=\"{in: animate}\" ng-style=\"{'z-index': 1050 + index*10, display: 'block'}\" ng-click=\"close($event)\">\n" +
    "    <div class=\"modal-dialog\" ng-class=\"{'modal-sm': size == 'sm', 'modal-lg': size == 'lg'}\"><div class=\"modal-content\" ng-transclude></div></div>\n" +
    "</div>");
}]);

angular.module("template/pagination/pager.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/pagination/pager.html",
    "<ul class=\"pager\">\n" +
    "  <li ng-class=\"{disabled: noPrevious(), previous: align}\"><a href ng-click=\"selectPage(page - 1)\">{{getText('previous')}}</a></li>\n" +
    "  <li ng-class=\"{disabled: noNext(), next: align}\"><a href ng-click=\"selectPage(page + 1)\">{{getText('next')}}</a></li>\n" +
    "</ul>");
}]);

angular.module("template/pagination/pagination.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/pagination/pagination.html",
    "<ul class=\"pagination\">\n" +
    "  <li ng-if=\"boundaryLinks\" ng-class=\"{disabled: noPrevious()}\"><a href ng-click=\"selectPage(1)\">{{getText('first')}}</a></li>\n" +
    "  <li ng-if=\"directionLinks\" ng-class=\"{disabled: noPrevious()}\"><a href ng-click=\"selectPage(page - 1)\">{{getText('previous')}}</a></li>\n" +
    "  <li ng-repeat=\"page in pages track by $index\" ng-class=\"{active: page.active}\"><a href ng-click=\"selectPage(page.number)\">{{page.text}}</a></li>\n" +
    "  <li ng-if=\"directionLinks\" ng-class=\"{disabled: noNext()}\"><a href ng-click=\"selectPage(page + 1)\">{{getText('next')}}</a></li>\n" +
    "  <li ng-if=\"boundaryLinks\" ng-class=\"{disabled: noNext()}\"><a href ng-click=\"selectPage(totalPages)\">{{getText('last')}}</a></li>\n" +
    "</ul>");
}]);

angular.module("template/progressbar/bar.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/progressbar/bar.html",
    "<div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: percent + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" ng-transclude></div>");
}]);

angular.module("template/progressbar/progress.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/progressbar/progress.html",
    "<div class=\"progress\" ng-transclude></div>");
}]);

angular.module("template/progressbar/progressbar.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/progressbar/progressbar.html",
    "<div class=\"progress\">\n" +
    "  <div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: percent + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" ng-transclude></div>\n" +
    "</div>");
}]);

angular.module("template/rating/rating.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/rating/rating.html",
    "<span ng-mouseleave=\"reset()\" ng-keydown=\"onKeydown($event)\" tabindex=\"0\" role=\"slider\" aria-valuemin=\"0\" aria-valuemax=\"{{range.length}}\" aria-valuenow=\"{{value}}\">\n" +
    "    <i ng-repeat=\"r in range track by $index\" ng-mouseenter=\"enter($index + 1)\" ng-click=\"rate($index + 1)\" class=\"glyphicon\" ng-class=\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\">\n" +
    "        <span class=\"sr-only\">({{ $index < value ? '*' : ' ' }})</span>\n" +
    "    </i>\n" +
    "</span>");
}]);

angular.module("template/tabs/tab.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/tabs/tab.html",
    "<li ng-class=\"{active: active, disabled: disabled}\">\n" +
    "  <a ng-click=\"select()\" tab-heading-transclude>{{heading}}</a>\n" +
    "</li>\n" +
    "");
}]);

angular.module("template/tabs/tabset-titles.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/tabs/tabset-titles.html",
    "<ul class=\"nav {{type && 'nav-' + type}}\" ng-class=\"{'nav-stacked': vertical}\">\n" +
    "</ul>\n" +
    "");
}]);

angular.module("template/tabs/tabset.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/tabs/tabset.html",
    "\n" +
    "<div>\n" +
    "  <ul class=\"nav nav-{{type || 'tabs'}}\" ng-class=\"{'nav-stacked': vertical, 'nav-justified': justified}\" ng-transclude></ul>\n" +
    "  <div class=\"tab-content\">\n" +
    "    <div class=\"tab-pane\" \n" +
    "         ng-repeat=\"tab in tabs\" \n" +
    "         ng-class=\"{active: tab.active}\"\n" +
    "         tab-content-transclude=\"tab\">\n" +
    "    </div>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/timepicker/timepicker.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/timepicker/timepicker.html",
    "<table>\n" +
    "   <tbody>\n" +
    "       <tr class=\"text-center\">\n" +
    "           <td><a ng-click=\"incrementHours()\" class=\"btn btn-link\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
    "           <td>&nbsp;</td>\n" +
    "           <td><a ng-click=\"incrementMinutes()\" class=\"btn btn-link\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
    "           <td ng-show=\"showMeridian\"></td>\n" +
    "       </tr>\n" +
    "       <tr>\n" +
    "           <td style=\"width:50px;\" class=\"form-group\" ng-class=\"{'has-error': invalidHours}\">\n" +
    "               <input type=\"text\" ng-model=\"hours\" ng-change=\"updateHours()\" class=\"form-control text-center\" ng-mousewheel=\"incrementHours()\" ng-readonly=\"readonlyInput\" maxlength=\"2\">\n" +
    "           </td>\n" +
    "           <td>:</td>\n" +
    "           <td style=\"width:50px;\" class=\"form-group\" ng-class=\"{'has-error': invalidMinutes}\">\n" +
    "               <input type=\"text\" ng-model=\"minutes\" ng-change=\"updateMinutes()\" class=\"form-control text-center\" ng-readonly=\"readonlyInput\" maxlength=\"2\">\n" +
    "           </td>\n" +
    "           <td ng-show=\"showMeridian\"><button type=\"button\" class=\"btn btn-default text-center\" ng-click=\"toggleMeridian()\">{{meridian}}</button></td>\n" +
    "       </tr>\n" +
    "       <tr class=\"text-center\">\n" +
    "           <td><a ng-click=\"decrementHours()\" class=\"btn btn-link\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
    "           <td>&nbsp;</td>\n" +
    "           <td><a ng-click=\"decrementMinutes()\" class=\"btn btn-link\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
    "           <td ng-show=\"showMeridian\"></td>\n" +
    "       </tr>\n" +
    "   </tbody>\n" +
    "</table>\n" +
    "");
}]);

angular.module("template/typeahead/typeahead-match.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/typeahead/typeahead-match.html",
    "<a tabindex=\"-1\" bind-html-unsafe=\"match.label | typeaheadHighlight:query\"></a>");
}]);

angular.module("template/typeahead/typeahead-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/typeahead/typeahead-popup.html",
    "<ul class=\"dropdown-menu\" ng-if=\"isOpen()\" ng-style=\"{top: position.top+'px', left: position.left+'px'}\" style=\"display: block;\" role=\"listbox\" aria-hidden=\"{{!isOpen()}}\">\n" +
    "    <li ng-repeat=\"match in matches track by $index\" ng-class=\"{active: isActive($index) }\" ng-mouseenter=\"selectActive($index)\" ng-click=\"selectMatch($index)\" role=\"option\" id=\"{{match.id}}\">\n" +
    "        <div typeahead-match index=\"$index\" match=\"match\" query=\"query\" template-url=\"templateUrl\"></div>\n" +
    "    </li>\n" +
    "</ul>");
}]);

/**
 * State-based routing for AngularJS
 * @version v0.2.10
 * @link http://angular-ui.github.com/
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */

/* commonjs package manager support (eg componentjs) */
if (typeof module !== "undefined" && typeof exports !== "undefined" && module.exports === exports){
  module.exports = 'ui.router';
}

(function (window, angular, undefined) {
/*jshint globalstrict:true*/
/*global angular:false*/
'use strict';

var isDefined = angular.isDefined,
    isFunction = angular.isFunction,
    isString = angular.isString,
    isObject = angular.isObject,
    isArray = angular.isArray,
    forEach = angular.forEach,
    extend = angular.extend,
    copy = angular.copy;

function inherit(parent, extra) {
  return extend(new (extend(function() {}, { prototype: parent }))(), extra);
}

function merge(dst) {
  forEach(arguments, function(obj) {
    if (obj !== dst) {
      forEach(obj, function(value, key) {
        if (!dst.hasOwnProperty(key)) dst[key] = value;
      });
    }
  });
  return dst;
}

/**
 * Finds the common ancestor path between two states.
 *
 * @param {Object} first The first state.
 * @param {Object} second The second state.
 * @return {Array} Returns an array of state names in descending order, not including the root.
 */
function ancestors(first, second) {
  var path = [];

  for (var n in first.path) {
    if (first.path[n] !== second.path[n]) break;
    path.push(first.path[n]);
  }
  return path;
}

/**
 * IE8-safe wrapper for `Object.keys()`.
 *
 * @param {Object} object A JavaScript object.
 * @return {Array} Returns the keys of the object as an array.
 */
function keys(object) {
  if (Object.keys) {
    return Object.keys(object);
  }
  var result = [];

  angular.forEach(object, function(val, key) {
    result.push(key);
  });
  return result;
}

/**
 * IE8-safe wrapper for `Array.prototype.indexOf()`.
 *
 * @param {Array} array A JavaScript array.
 * @param {*} value A value to search the array for.
 * @return {Number} Returns the array index value of `value`, or `-1` if not present.
 */
function arraySearch(array, value) {
  if (Array.prototype.indexOf) {
    return array.indexOf(value, Number(arguments[2]) || 0);
  }
  var len = array.length >>> 0, from = Number(arguments[2]) || 0;
  from = (from < 0) ? Math.ceil(from) : Math.floor(from);

  if (from < 0) from += len;

  for (; from < len; from++) {
    if (from in array && array[from] === value) return from;
  }
  return -1;
}

/**
 * Merges a set of parameters with all parameters inherited between the common parents of the
 * current state and a given destination state.
 *
 * @param {Object} currentParams The value of the current state parameters ($stateParams).
 * @param {Object} newParams The set of parameters which will be composited with inherited params.
 * @param {Object} $current Internal definition of object representing the current state.
 * @param {Object} $to Internal definition of object representing state to transition to.
 */
function inheritParams(currentParams, newParams, $current, $to) {
  var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];

  for (var i in parents) {
    if (!parents[i].params || !parents[i].params.length) continue;
    parentParams = parents[i].params;

    for (var j in parentParams) {
      if (arraySearch(inheritList, parentParams[j]) >= 0) continue;
      inheritList.push(parentParams[j]);
      inherited[parentParams[j]] = currentParams[parentParams[j]];
    }
  }
  return extend({}, inherited, newParams);
}

/**
 * Normalizes a set of values to string or `null`, filtering them by a list of keys.
 *
 * @param {Array} keys The list of keys to normalize/return.
 * @param {Object} values An object hash of values to normalize.
 * @return {Object} Returns an object hash of normalized string values.
 */
function normalize(keys, values) {
  var normalized = {};

  forEach(keys, function (name) {
    var value = values[name];
    normalized[name] = (value != null) ? String(value) : null;
  });
  return normalized;
}

/**
 * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.
 *
 * @param {Object} a The first object.
 * @param {Object} b The second object.
 * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,
 *                     it defaults to the list of keys in `a`.
 * @return {Boolean} Returns `true` if the keys match, otherwise `false`.
 */
function equalForKeys(a, b, keys) {
  if (!keys) {
    keys = [];
    for (var n in a) keys.push(n); // Used instead of Object.keys() for IE8 compatibility
  }

  for (var i=0; i<keys.length; i++) {
    var k = keys[i];
    if (a[k] != b[k]) return false; // Not '===', values aren't necessarily normalized
  }
  return true;
}

/**
 * Returns the subset of an object, based on a list of keys.
 *
 * @param {Array} keys
 * @param {Object} values
 * @return {Boolean} Returns a subset of `values`.
 */
function filterByKeys(keys, values) {
  var filtered = {};

  forEach(keys, function (name) {
    filtered[name] = values[name];
  });
  return filtered;
}
/**
 * @ngdoc overview
 * @name ui.router.util
 *
 * @description
 * # ui.router.util sub-module
 *
 * This module is a dependency of other sub-modules. Do not include this module as a dependency
 * in your angular app (use {@link ui.router} module instead).
 *
 */
angular.module('ui.router.util', ['ng']);

/**
 * @ngdoc overview
 * @name ui.router.router
 *
 * @requires ui.router.util
 *
 * @description
 * # ui.router.router sub-module
 *
 * This module is a dependency of other sub-modules. Do not include this module as a dependency
 * in your angular app (use {@link ui.router} module instead).
 */
angular.module('ui.router.router', ['ui.router.util']);

/**
 * @ngdoc overview
 * @name ui.router.state
 *
 * @requires ui.router.router
 * @requires ui.router.util
 *
 * @description
 * # ui.router.state sub-module
 *
 * This module is a dependency of the main ui.router module. Do not include this module as a dependency
 * in your angular app (use {@link ui.router} module instead).
 *
 */
angular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);

/**
 * @ngdoc overview
 * @name ui.router
 *
 * @requires ui.router.state
 *
 * @description
 * # ui.router
 *
 * ## The main module for ui.router
 * There are several sub-modules included with the ui.router module, however only this module is needed
 * as a dependency within your angular app. The other modules are for organization purposes.
 *
 * The modules are:
 * * ui.router - the main "umbrella" module
 * * ui.router.router -
 *
 * *You'll need to include **only** this module as the dependency within your angular app.*
 *
 * <pre>
 * <!doctype html>
 * <html ng-app="myApp">
 * <head>
 *   <script src="js/angular.js"></script>
 *   <!-- Include the ui-router script -->
 *   <script src="js/angular-ui-router.min.js"></script>
 *   <script>
 *     // ...and add 'ui.router' as a dependency
 *     var myApp = angular.module('myApp', ['ui.router']);
 *   </script>
 * </head>
 * <body>
 * </body>
 * </html>
 * </pre>
 */
angular.module('ui.router', ['ui.router.state']);

angular.module('ui.router.compat', ['ui.router']);

/**
 * @ngdoc object
 * @name ui.router.util.$resolve
 *
 * @requires $q
 * @requires $injector
 *
 * @description
 * Manages resolution of (acyclic) graphs of promises.
 */
$Resolve.$inject = ['$q', '$injector'];
function $Resolve(  $q,    $injector) {

  var VISIT_IN_PROGRESS = 1,
      VISIT_DONE = 2,
      NOTHING = {},
      NO_DEPENDENCIES = [],
      NO_LOCALS = NOTHING,
      NO_PARENT = extend($q.when(NOTHING), { $$promises: NOTHING, $$values: NOTHING });


  /**
   * @ngdoc function
   * @name ui.router.util.$resolve#study
   * @methodOf ui.router.util.$resolve
   *
   * @description
   * Studies a set of invocables that are likely to be used multiple times.
   * <pre>
   * $resolve.study(invocables)(locals, parent, self)
   * </pre>
   * is equivalent to
   * <pre>
   * $resolve.resolve(invocables, locals, parent, self)
   * </pre>
   * but the former is more efficient (in fact `resolve` just calls `study`
   * internally).
   *
   * @param {object} invocables Invocable objects
   * @return {function} a function to pass in locals, parent and self
   */
  this.study = function (invocables) {
    if (!isObject(invocables)) throw new Error("'invocables' must be an object");

    // Perform a topological sort of invocables to build an ordered plan
    var plan = [], cycle = [], visited = {};
    function visit(value, key) {
      if (visited[key] === VISIT_DONE) return;

      cycle.push(key);
      if (visited[key] === VISIT_IN_PROGRESS) {
        cycle.splice(0, cycle.indexOf(key));
        throw new Error("Cyclic dependency: " + cycle.join(" -> "));
      }
      visited[key] = VISIT_IN_PROGRESS;

      if (isString(value)) {
        plan.push(key, [ function() { return $injector.get(value); }], NO_DEPENDENCIES);
      } else {
        var params = $injector.annotate(value);
        forEach(params, function (param) {
          if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);
        });
        plan.push(key, value, params);
      }

      cycle.pop();
      visited[key] = VISIT_DONE;
    }
    forEach(invocables, visit);
    invocables = cycle = visited = null; // plan is all that's required

    function isResolve(value) {
      return isObject(value) && value.then && value.$$promises;
    }

    return function (locals, parent, self) {
      if (isResolve(locals) && self === undefined) {
        self = parent; parent = locals; locals = null;
      }
      if (!locals) locals = NO_LOCALS;
      else if (!isObject(locals)) {
        throw new Error("'locals' must be an object");
      }
      if (!parent) parent = NO_PARENT;
      else if (!isResolve(parent)) {
        throw new Error("'parent' must be a promise returned by $resolve.resolve()");
      }

      // To complete the overall resolution, we have to wait for the parent
      // promise and for the promise for each invokable in our plan.
      var resolution = $q.defer(),
          result = resolution.promise,
          promises = result.$$promises = {},
          values = extend({}, locals),
          wait = 1 + plan.length/3,
          merged = false;

      function done() {
        // Merge parent values we haven't got yet and publish our own $$values
        if (!--wait) {
          if (!merged) merge(values, parent.$$values);
          result.$$values = values;
          result.$$promises = true; // keep for isResolve()
          resolution.resolve(values);
        }
      }

      function fail(reason) {
        result.$$failure = reason;
        resolution.reject(reason);
      }

      // Short-circuit if parent has already failed
      if (isDefined(parent.$$failure)) {
        fail(parent.$$failure);
        return result;
      }

      // Merge parent values if the parent has already resolved, or merge
      // parent promises and wait if the parent resolve is still in progress.
      if (parent.$$values) {
        merged = merge(values, parent.$$values);
        done();
      } else {
        extend(promises, parent.$$promises);
        parent.then(done, fail);
      }

      // Process each invocable in the plan, but ignore any where a local of the same name exists.
      for (var i=0, ii=plan.length; i<ii; i+=3) {
        if (locals.hasOwnProperty(plan[i])) done();
        else invoke(plan[i], plan[i+1], plan[i+2]);
      }

      function invoke(key, invocable, params) {
        // Create a deferred for this invocation. Failures will propagate to the resolution as well.
        var invocation = $q.defer(), waitParams = 0;
        function onfailure(reason) {
          invocation.reject(reason);
          fail(reason);
        }
        // Wait for any parameter that we have a promise for (either from parent or from this
        // resolve; in that case study() will have made sure it's ordered before us in the plan).
        forEach(params, function (dep) {
          if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {
            waitParams++;
            promises[dep].then(function (result) {
              values[dep] = result;
              if (!(--waitParams)) proceed();
            }, onfailure);
          }
        });
        if (!waitParams) proceed();
        function proceed() {
          if (isDefined(result.$$failure)) return;
          try {
            invocation.resolve($injector.invoke(invocable, self, values));
            invocation.promise.then(function (result) {
              values[key] = result;
              done();
            }, onfailure);
          } catch (e) {
            onfailure(e);
          }
        }
        // Publish promise synchronously; invocations further down in the plan may depend on it.
        promises[key] = invocation.promise;
      }

      return result;
    };
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$resolve#resolve
   * @methodOf ui.router.util.$resolve
   *
   * @description
   * Resolves a set of invocables. An invocable is a function to be invoked via
   * `$injector.invoke()`, and can have an arbitrary number of dependencies.
   * An invocable can either return a value directly,
   * or a `$q` promise. If a promise is returned it will be resolved and the
   * resulting value will be used instead. Dependencies of invocables are resolved
   * (in this order of precedence)
   *
   * - from the specified `locals`
   * - from another invocable that is part of this `$resolve` call
   * - from an invocable that is inherited from a `parent` call to `$resolve`
   *   (or recursively
   * - from any ancestor `$resolve` of that parent).
   *
   * The return value of `$resolve` is a promise for an object that contains
   * (in this order of precedence)
   *
   * - any `locals` (if specified)
   * - the resolved return values of all injectables
   * - any values inherited from a `parent` call to `$resolve` (if specified)
   *
   * The promise will resolve after the `parent` promise (if any) and all promises
   * returned by injectables have been resolved. If any invocable
   * (or `$injector.invoke`) throws an exception, or if a promise returned by an
   * invocable is rejected, the `$resolve` promise is immediately rejected with the
   * same error. A rejection of a `parent` promise (if specified) will likewise be
   * propagated immediately. Once the `$resolve` promise has been rejected, no
   * further invocables will be called.
   *
   * Cyclic dependencies between invocables are not permitted and will caues `$resolve`
   * to throw an error. As a special case, an injectable can depend on a parameter
   * with the same name as the injectable, which will be fulfilled from the `parent`
   * injectable of the same name. This allows inherited values to be decorated.
   * Note that in this case any other injectable in the same `$resolve` with the same
   * dependency would see the decorated value, not the inherited value.
   *
   * Note that missing dependencies -- unlike cyclic dependencies -- will cause an
   * (asynchronous) rejection of the `$resolve` promise rather than a (synchronous)
   * exception.
   *
   * Invocables are invoked eagerly as soon as all dependencies are available.
   * This is true even for dependencies inherited from a `parent` call to `$resolve`.
   *
   * As a special case, an invocable can be a string, in which case it is taken to
   * be a service name to be passed to `$injector.get()`. This is supported primarily
   * for backwards-compatibility with the `resolve` property of `$routeProvider`
   * routes.
   *
   * @param {object} invocables functions to invoke or
   * `$injector` services to fetch.
   * @param {object} locals  values to make available to the injectables
   * @param {object} parent  a promise returned by another call to `$resolve`.
   * @param {object} self  the `this` for the invoked methods
   * @return {object} Promise for an object that contains the resolved return value
   * of all invocables, as well as any inherited and local values.
   */
  this.resolve = function (invocables, locals, parent, self) {
    return this.study(invocables)(locals, parent, self);
  };
}

angular.module('ui.router.util').service('$resolve', $Resolve);


/**
 * @ngdoc object
 * @name ui.router.util.$templateFactory
 *
 * @requires $http
 * @requires $templateCache
 * @requires $injector
 *
 * @description
 * Service. Manages loading of templates.
 */
$TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];
function $TemplateFactory(  $http,   $templateCache,   $injector) {

  /**
   * @ngdoc function
   * @name ui.router.util.$templateFactory#fromConfig
   * @methodOf ui.router.util.$templateFactory
   *
   * @description
   * Creates a template from a configuration object.
   *
   * @param {object} config Configuration object for which to load a template.
   * The following properties are search in the specified order, and the first one
   * that is defined is used to create the template:
   *
   * @param {string|object} config.template html string template or function to
   * load via {@link ui.router.util.$templateFactory#fromString fromString}.
   * @param {string|object} config.templateUrl url to load or a function returning
   * the url to load via {@link ui.router.util.$templateFactory#fromUrl fromUrl}.
   * @param {Function} config.templateProvider function to invoke via
   * {@link ui.router.util.$templateFactory#fromProvider fromProvider}.
   * @param {object} params  Parameters to pass to the template function.
   * @param {object} locals Locals to pass to `invoke` if the template is loaded
   * via a `templateProvider`. Defaults to `{ params: params }`.
   *
   * @return {string|object}  The template html as a string, or a promise for
   * that string,or `null` if no template is configured.
   */
  this.fromConfig = function (config, params, locals) {
    return (
      isDefined(config.template) ? this.fromString(config.template, params) :
      isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) :
      isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) :
      null
    );
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$templateFactory#fromString
   * @methodOf ui.router.util.$templateFactory
   *
   * @description
   * Creates a template from a string or a function returning a string.
   *
   * @param {string|object} template html template as a string or function that
   * returns an html template as a string.
   * @param {object} params Parameters to pass to the template function.
   *
   * @return {string|object} The template html as a string, or a promise for that
   * string.
   */
  this.fromString = function (template, params) {
    return isFunction(template) ? template(params) : template;
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$templateFactory#fromUrl
   * @methodOf ui.router.util.$templateFactory
   *
   * @description
   * Loads a template from the a URL via `$http` and `$templateCache`.
   *
   * @param {string|Function} url url of the template to load, or a function
   * that returns a url.
   * @param {Object} params Parameters to pass to the url function.
   * @return {string|Promise.<string>} The template html as a string, or a promise
   * for that string.
   */
  this.fromUrl = function (url, params) {
    if (isFunction(url)) url = url(params);
    if (url == null) return null;
    else return $http
        .get(url, { cache: $templateCache })
        .then(function(response) { return response.data; });
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$templateFactory#fromUrl
   * @methodOf ui.router.util.$templateFactory
   *
   * @description
   * Creates a template by invoking an injectable provider function.
   *
   * @param {Function} provider Function to invoke via `$injector.invoke`
   * @param {Object} params Parameters for the template.
   * @param {Object} locals Locals to pass to `invoke`. Defaults to
   * `{ params: params }`.
   * @return {string|Promise.<string>} The template html as a string, or a promise
   * for that string.
   */
  this.fromProvider = function (provider, params, locals) {
    return $injector.invoke(provider, null, locals || { params: params });
  };
}

angular.module('ui.router.util').service('$templateFactory', $TemplateFactory);

/**
 * @ngdoc object
 * @name ui.router.util.type:UrlMatcher
 *
 * @description
 * Matches URLs against patterns and extracts named parameters from the path or the search
 * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list
 * of search parameters. Multiple search parameter names are separated by '&'. Search parameters
 * do not influence whether or not a URL is matched, but their values are passed through into
 * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.
 *
 * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace
 * syntax, which optionally allows a regular expression for the parameter to be specified:
 *
 * * `':'` name - colon placeholder
 * * `'*'` name - catch-all placeholder
 * * `'{' name '}'` - curly placeholder
 * * `'{' name ':' regexp '}'` - curly placeholder with regexp. Should the regexp itself contain
 *   curly braces, they must be in matched pairs or escaped with a backslash.
 *
 * Parameter names may contain only word characters (latin letters, digits, and underscore) and
 * must be unique within the pattern (across both path and search parameters). For colon
 * placeholders or curly placeholders without an explicit regexp, a path parameter matches any
 * number of characters other than '/'. For catch-all placeholders the path parameter matches
 * any number of characters.
 *
 * Examples:
 *
 * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for
 *   trailing slashes, and patterns have to match the entire path, not just a prefix.
 * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or
 *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.
 * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.
 * * `'/user/{id:[^/]*}'` - Same as the previous example.
 * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id
 *   parameter consists of 1 to 8 hex digits.
 * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the
 *   path into the parameter 'path'.
 * * `'/files/*path'` - ditto.
 *
 * @param {string} pattern  the pattern to compile into a matcher.
 *
 * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any
 *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns
 *   non-null) will start with this prefix.
 *
 * @property {string} source  The pattern that was passed into the contructor
 *
 * @property {string} sourcePath  The path portion of the source property
 *
 * @property {string} sourceSearch  The search portion of the source property
 *
 * @property {string} regex  The constructed regex that will be used to match against the url when
 *   it is time to determine which url will match.
 *
 * @returns {Object}  New UrlMatcher object
 */
function UrlMatcher(pattern) {

  // Find all placeholders and create a compiled pattern, using either classic or curly syntax:
  //   '*' name
  //   ':' name
  //   '{' name '}'
  //   '{' name ':' regexp '}'
  // The regular expression is somewhat complicated due to the need to allow curly braces
  // inside the regular expression. The placeholder regexp breaks down as follows:
  //    ([:*])(\w+)               classic placeholder ($1 / $2)
  //    \{(\w+)(?:\:( ... ))?\}   curly brace placeholder ($3) with optional regexp ... ($4)
  //    (?: ... | ... | ... )+    the regexp consists of any number of atoms, an atom being either
  //    [^{}\\]+                  - anything other than curly braces or backslash
  //    \\.                       - a backslash escape
  //    \{(?:[^{}\\]+|\\.)*\}     - a matched set of curly braces containing other atoms
  var placeholder = /([:*])(\w+)|\{(\w+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
      names = {}, compiled = '^', last = 0, m,
      segments = this.segments = [],
      params = this.params = [];

  function addParameter(id) {
    if (!/^\w+(-+\w+)*$/.test(id)) throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
    if (names[id]) throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
    names[id] = true;
    params.push(id);
  }

  function quoteRegExp(string) {
    return string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
  }

  this.source = pattern;

  // Split into static segments separated by path parameter placeholders.
  // The number of segments is always 1 more than the number of parameters.
  var id, regexp, segment;
  while ((m = placeholder.exec(pattern))) {
    id = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null
    regexp = m[4] || (m[1] == '*' ? '.*' : '[^/]*');
    segment = pattern.substring(last, m.index);
    if (segment.indexOf('?') >= 0) break; // we're into the search part
    compiled += quoteRegExp(segment) + '(' + regexp + ')';
    addParameter(id);
    segments.push(segment);
    last = placeholder.lastIndex;
  }
  segment = pattern.substring(last);

  // Find any search parameter names and remove them from the last segment
  var i = segment.indexOf('?');
  if (i >= 0) {
    var search = this.sourceSearch = segment.substring(i);
    segment = segment.substring(0, i);
    this.sourcePath = pattern.substring(0, last+i);

    // Allow parameters to be separated by '?' as well as '&' to make concat() easier
    forEach(search.substring(1).split(/[&?]/), addParameter);
  } else {
    this.sourcePath = pattern;
    this.sourceSearch = '';
  }

  compiled += quoteRegExp(segment) + '$';
  segments.push(segment);
  this.regexp = new RegExp(compiled);
  this.prefix = segments[0];
}

/**
 * @ngdoc function
 * @name ui.router.util.type:UrlMatcher#concat
 * @methodOf ui.router.util.type:UrlMatcher
 *
 * @description
 * Returns a new matcher for a pattern constructed by appending the path part and adding the
 * search parameters of the specified pattern to this pattern. The current pattern is not
 * modified. This can be understood as creating a pattern for URLs that are relative to (or
 * suffixes of) the current pattern.
 *
 * @example
 * The following two matchers are equivalent:
 * ```
 * new UrlMatcher('/user/{id}?q').concat('/details?date');
 * new UrlMatcher('/user/{id}/details?q&date');
 * ```
 *
 * @param {string} pattern  The pattern to append.
 * @returns {ui.router.util.type:UrlMatcher}  A matcher for the concatenated pattern.
 */
UrlMatcher.prototype.concat = function (pattern) {
  // Because order of search parameters is irrelevant, we can add our own search
  // parameters to the end of the new pattern. Parse the new pattern by itself
  // and then join the bits together, but it's much easier to do this on a string level.
  return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch);
};

UrlMatcher.prototype.toString = function () {
  return this.source;
};

/**
 * @ngdoc function
 * @name ui.router.util.type:UrlMatcher#exec
 * @methodOf ui.router.util.type:UrlMatcher
 *
 * @description
 * Tests the specified path against this matcher, and returns an object containing the captured
 * parameter values, or null if the path does not match. The returned object contains the values
 * of any search parameters that are mentioned in the pattern, but their value may be null if
 * they are not present in `searchParams`. This means that search parameters are always treated
 * as optional.
 *
 * @example
 * ```
 * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', { x:'1', q:'hello' });
 * // returns { id:'bob', q:'hello', r:null }
 * ```
 *
 * @param {string} path  The URL path to match, e.g. `$location.path()`.
 * @param {Object} searchParams  URL search parameters, e.g. `$location.search()`.
 * @returns {Object}  The captured parameter values.
 */
UrlMatcher.prototype.exec = function (path, searchParams) {
  var m = this.regexp.exec(path);
  if (!m) return null;

  var params = this.params, nTotal = params.length,
    nPath = this.segments.length-1,
    values = {}, i;

  if (nPath !== m.length - 1) throw new Error("Unbalanced capture group in route '" + this.source + "'");

  for (i=0; i<nPath; i++) values[params[i]] = m[i+1];
  for (/**/; i<nTotal; i++) values[params[i]] = searchParams[params[i]];

  return values;
};

/**
 * @ngdoc function
 * @name ui.router.util.type:UrlMatcher#parameters
 * @methodOf ui.router.util.type:UrlMatcher
 *
 * @description
 * Returns the names of all path and search parameters of this pattern in an unspecified order.
 *
 * @returns {Array.<string>}  An array of parameter names. Must be treated as read-only. If the
 *    pattern has no parameters, an empty array is returned.
 */
UrlMatcher.prototype.parameters = function () {
  return this.params;
};

/**
 * @ngdoc function
 * @name ui.router.util.type:UrlMatcher#format
 * @methodOf ui.router.util.type:UrlMatcher
 *
 * @description
 * Creates a URL that matches this pattern by substituting the specified values
 * for the path and search parameters. Null values for path parameters are
 * treated as empty strings.
 *
 * @example
 * ```
 * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });
 * // returns '/user/bob?q=yes'
 * ```
 *
 * @param {Object} values  the values to substitute for the parameters in this pattern.
 * @returns {string}  the formatted URL (path and optionally search part).
 */
UrlMatcher.prototype.format = function (values) {
  var segments = this.segments, params = this.params;
  if (!values) return segments.join('');

  var nPath = segments.length-1, nTotal = params.length,
    result = segments[0], i, search, value;

  for (i=0; i<nPath; i++) {
    value = values[params[i]];
    // TODO: Maybe we should throw on null here? It's not really good style to use '' and null interchangeabley
    if (value != null) result += encodeURIComponent(value);
    result += segments[i+1];
  }
  for (/**/; i<nTotal; i++) {
    value = values[params[i]];
    if (value != null) {
      result += (search ? '&' : '?') + params[i] + '=' + encodeURIComponent(value);
      search = true;
    }
  }

  return result;
};



/**
 * @ngdoc object
 * @name ui.router.util.$urlMatcherFactory
 *
 * @description
 * Factory for {@link ui.router.util.type:UrlMatcher} instances. The factory is also available to providers
 * under the name `$urlMatcherFactoryProvider`.
 */
function $UrlMatcherFactory() {

  /**
   * @ngdoc function
   * @name ui.router.util.$urlMatcherFactory#compile
   * @methodOf ui.router.util.$urlMatcherFactory
   *
   * @description
   * Creates a {@link ui.router.util.type:UrlMatcher} for the specified pattern.
   *
   * @param {string} pattern  The URL pattern.
   * @returns {ui.router.util.type:UrlMatcher}  The UrlMatcher.
   */
  this.compile = function (pattern) {
    return new UrlMatcher(pattern);
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$urlMatcherFactory#isMatcher
   * @methodOf ui.router.util.$urlMatcherFactory
   *
   * @description
   * Returns true if the specified object is a UrlMatcher, or false otherwise.
   *
   * @param {Object} object  The object to perform the type check against.
   * @returns {Boolean}  Returns `true` if the object has the following functions: `exec`, `format`, and `concat`.
   */
  this.isMatcher = function (o) {
    return isObject(o) && isFunction(o.exec) && isFunction(o.format) && isFunction(o.concat);
  };

  /* No need to document $get, since it returns this */
  this.$get = function () {
    return this;
  };
}

// Register as a provider so it's available to other providers
angular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);

/**
 * @ngdoc object
 * @name ui.router.router.$urlRouterProvider
 *
 * @requires ui.router.util.$urlMatcherFactoryProvider
 *
 * @description
 * `$urlRouterProvider` has the responsibility of watching `$location`.
 * When `$location` changes it runs through a list of rules one by one until a
 * match is found. `$urlRouterProvider` is used behind the scenes anytime you specify
 * a url in a state configuration. All urls are compiled into a UrlMatcher object.
 *
 * There are several methods on `$urlRouterProvider` that make it useful to use directly
 * in your module config.
 */
$UrlRouterProvider.$inject = ['$urlMatcherFactoryProvider'];
function $UrlRouterProvider(  $urlMatcherFactory) {
  var rules = [],
      otherwise = null;

  // Returns a string that is a prefix of all strings matching the RegExp
  function regExpPrefix(re) {
    var prefix = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(re.source);
    return (prefix != null) ? prefix[1].replace(/\\(.)/g, "$1") : '';
  }

  // Interpolates matched values into a String.replace()-style pattern
  function interpolate(pattern, match) {
    return pattern.replace(/\$(\$|\d{1,2})/, function (m, what) {
      return match[what === '$' ? 0 : Number(what)];
    });
  }

  /**
   * @ngdoc function
   * @name ui.router.router.$urlRouterProvider#rule
   * @methodOf ui.router.router.$urlRouterProvider
   *
   * @description
   * Defines rules that are used by `$urlRouterProvider to find matches for
   * specific URLs.
   *
   * @example
   * <pre>
   * var app = angular.module('app', ['ui.router.router']);
   *
   * app.config(function ($urlRouterProvider) {
   *   // Here's an example of how you might allow case insensitive urls
   *   $urlRouterProvider.rule(function ($injector, $location) {
   *     var path = $location.path(),
   *         normalized = path.toLowerCase();
   *
   *     if (path !== normalized) {
   *       return normalized;
   *     }
   *   });
   * });
   * </pre>
   *
   * @param {object} rule Handler function that takes `$injector` and `$location`
   * services as arguments. You can use them to return a valid path as a string.
   *
   * @return {object} $urlRouterProvider - $urlRouterProvider instance
   */
  this.rule =
    function (rule) {
      if (!isFunction(rule)) throw new Error("'rule' must be a function");
      rules.push(rule);
      return this;
    };

  /**
   * @ngdoc object
   * @name ui.router.router.$urlRouterProvider#otherwise
   * @methodOf ui.router.router.$urlRouterProvider
   *
   * @description
   * Defines a path that is used when an invalied route is requested.
   *
   * @example
   * <pre>
   * var app = angular.module('app', ['ui.router.router']);
   *
   * app.config(function ($urlRouterProvider) {
   *   // if the path doesn't match any of the urls you configured
   *   // otherwise will take care of routing the user to the
   *   // specified url
   *   $urlRouterProvider.otherwise('/index');
   *
   *   // Example of using function rule as param
   *   $urlRouterProvider.otherwise(function ($injector, $location) {
   *     ...
   *   });
   * });
   * </pre>
   *
   * @param {string|object} rule The url path you want to redirect to or a function
   * rule that returns the url path. The function version is passed two params:
   * `$injector` and `$location` services.
   *
   * @return {object} $urlRouterProvider - $urlRouterProvider instance
   */
  this.otherwise =
    function (rule) {
      if (isString(rule)) {
        var redirect = rule;
        rule = function () { return redirect; };
      }
      else if (!isFunction(rule)) throw new Error("'rule' must be a function");
      otherwise = rule;
      return this;
    };


  function handleIfMatch($injector, handler, match) {
    if (!match) return false;
    var result = $injector.invoke(handler, handler, { $match: match });
    return isDefined(result) ? result : true;
  }

  /**
   * @ngdoc function
   * @name ui.router.router.$urlRouterProvider#when
   * @methodOf ui.router.router.$urlRouterProvider
   *
   * @description
   * Registers a handler for a given url matching. if handle is a string, it is
   * treated as a redirect, and is interpolated according to the syyntax of match
   * (i.e. like String.replace() for RegExp, or like a UrlMatcher pattern otherwise).
   *
   * If the handler is a function, it is injectable. It gets invoked if `$location`
   * matches. You have the option of inject the match object as `$match`.
   *
   * The handler can return
   *
   * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`
   *   will continue trying to find another one that matches.
   * - **string** which is treated as a redirect and passed to `$location.url()`
   * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.
   *
   * @example
   * <pre>
   * var app = angular.module('app', ['ui.router.router']);
   *
   * app.config(function ($urlRouterProvider) {
   *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {
   *     if ($state.$current.navigable !== state ||
   *         !equalForKeys($match, $stateParams) {
   *      $state.transitionTo(state, $match, false);
   *     }
   *   });
   * });
   * </pre>
   *
   * @param {string|object} what The incoming path that you want to redirect.
   * @param {string|object} handler The path you want to redirect your user to.
   */
  this.when =
    function (what, handler) {
      var redirect, handlerIsString = isString(handler);
      if (isString(what)) what = $urlMatcherFactory.compile(what);

      if (!handlerIsString && !isFunction(handler) && !isArray(handler))
        throw new Error("invalid 'handler' in when()");

      var strategies = {
        matcher: function (what, handler) {
          if (handlerIsString) {
            redirect = $urlMatcherFactory.compile(handler);
            handler = ['$match', function ($match) { return redirect.format($match); }];
          }
          return extend(function ($injector, $location) {
            return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));
          }, {
            prefix: isString(what.prefix) ? what.prefix : ''
          });
        },
        regex: function (what, handler) {
          if (what.global || what.sticky) throw new Error("when() RegExp must not be global or sticky");

          if (handlerIsString) {
            redirect = handler;
            handler = ['$match', function ($match) { return interpolate(redirect, $match); }];
          }
          return extend(function ($injector, $location) {
            return handleIfMatch($injector, handler, what.exec($location.path()));
          }, {
            prefix: regExpPrefix(what)
          });
        }
      };

      var check = { matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp };

      for (var n in check) {
        if (check[n]) {
          return this.rule(strategies[n](what, handler));
        }
      }

      throw new Error("invalid 'what' in when()");
    };

  /**
   * @ngdoc object
   * @name ui.router.router.$urlRouter
   *
   * @requires $location
   * @requires $rootScope
   * @requires $injector
   *
   * @description
   *
   */
  this.$get =
    [        '$location', '$rootScope', '$injector',
    function ($location,   $rootScope,   $injector) {
      // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree
      function update(evt) {
        if (evt && evt.defaultPrevented) return;
        function check(rule) {
          var handled = rule($injector, $location);
          if (handled) {
            if (isString(handled)) $location.replace().url(handled);
            return true;
          }
          return false;
        }
        var n=rules.length, i;
        for (i=0; i<n; i++) {
          if (check(rules[i])) return;
        }
        // always check otherwise last to allow dynamic updates to the set of rules
        if (otherwise) check(otherwise);
      }

      $rootScope.$on('$locationChangeSuccess', update);

      return {
        /**
         * @ngdoc function
         * @name ui.router.router.$urlRouter#sync
         * @methodOf ui.router.router.$urlRouter
         *
         * @description
         * Triggers an update; the same update that happens when the address bar url changes, aka `$locationChangeSuccess`.
         * This method is useful when you need to use `preventDefault()` on the `$locationChangeSuccess` event,
         * perform some custom logic (route protection, auth, config, redirection, etc) and then finally proceed
         * with the transition by calling `$urlRouter.sync()`.
         *
         * @example
         * <pre>
         * angular.module('app', ['ui.router']);
         *   .run(function($rootScope, $urlRouter) {
         *     $rootScope.$on('$locationChangeSuccess', function(evt) {
         *       // Halt state change from even starting
         *       evt.preventDefault();
         *       // Perform custom logic
         *       var meetsRequirement = ...
         *       // Continue with the update and state transition if logic allows
         *       if (meetsRequirement) $urlRouter.sync();
         *     });
         * });
         * </pre>
         */
        sync: function () {
          update();
        }
      };
    }];
}

angular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);

/**
 * @ngdoc object
 * @name ui.router.state.$stateProvider
 *
 * @requires ui.router.router.$urlRouterProvider
 * @requires ui.router.util.$urlMatcherFactoryProvider
 * @requires $locationProvider
 *
 * @description
 * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely
 * on state.
 *
 * A state corresponds to a "place" in the application in terms of the overall UI and
 * navigation. A state describes (via the controller / template / view properties) what
 * the UI looks like and does at that place.
 *
 * States often have things in common, and the primary way of factoring out these
 * commonalities in this model is via the state hierarchy, i.e. parent/child states aka
 * nested states.
 *
 * The `$stateProvider` provides interfaces to declare these states for your app.
 */
$StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider', '$locationProvider'];
function $StateProvider(   $urlRouterProvider,   $urlMatcherFactory,           $locationProvider) {

  var root, states = {}, $state, queue = {}, abstractKey = 'abstract';

  // Builds state properties from definition passed to registerState()
  var stateBuilder = {

    // Derive parent state from a hierarchical name only if 'parent' is not explicitly defined.
    // state.children = [];
    // if (parent) parent.children.push(state);
    parent: function(state) {
      if (isDefined(state.parent) && state.parent) return findState(state.parent);
      // regex matches any valid composite state name
      // would match "contact.list" but not "contacts"
      var compositeName = /^(.+)\.[^.]+$/.exec(state.name);
      return compositeName ? findState(compositeName[1]) : root;
    },

    // inherit 'data' from parent and override by own values (if any)
    data: function(state) {
      if (state.parent && state.parent.data) {
        state.data = state.self.data = extend({}, state.parent.data, state.data);
      }
      return state.data;
    },

    // Build a URLMatcher if necessary, either via a relative or absolute URL
    url: function(state) {
      var url = state.url;

      if (isString(url)) {
        if (url.charAt(0) == '^') {
          return $urlMatcherFactory.compile(url.substring(1));
        }
        return (state.parent.navigable || root).url.concat(url);
      }

      if ($urlMatcherFactory.isMatcher(url) || url == null) {
        return url;
      }
      throw new Error("Invalid url '" + url + "' in state '" + state + "'");
    },

    // Keep track of the closest ancestor state that has a URL (i.e. is navigable)
    navigable: function(state) {
      return state.url ? state : (state.parent ? state.parent.navigable : null);
    },

    // Derive parameters for this state and ensure they're a super-set of parent's parameters
    params: function(state) {
      if (!state.params) {
        return state.url ? state.url.parameters() : state.parent.params;
      }
     // if (!isArray(state.params)) throw new Error("Invalid params in state '" + state + "'");
     // debugger;
      //if (state.url) throw new Error("Both params and url specicified in state '" + state + "'");
      return state.params;
    },

    // If there is no explicit multi-view configuration, make one up so we don't have
    // to handle both cases in the view directive later. Note that having an explicit
    // 'views' property will mean the default unnamed view properties are ignored. This
    // is also a good time to resolve view names to absolute names, so everything is a
    // straight lookup at link time.
    views: function(state) {
      var views = {};

      forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {
        if (name.indexOf('@') < 0) name += '@' + state.parent.name;
        views[name] = view;
      });
      return views;
    },

    ownParams: function(state) {
      if (!state.parent) {
        return state.params;
      }
      var paramNames = {}; forEach(state.params, function (p) { paramNames[p] = true; });

      forEach(state.parent.params, function (p) {
        if (!paramNames[p]) {
          throw new Error("Missing required parameter '" + p + "' in state '" + state.name + "'");
        }
        paramNames[p] = false;
      });
      var ownParams = [];

      forEach(paramNames, function (own, p) {
        if (own) ownParams.push(p);
      });
      return ownParams;
    },

    // Keep a full path from the root down to this state as this is needed for state activation.
    path: function(state) {
      return state.parent ? state.parent.path.concat(state) : []; // exclude root from path
    },

    // Speed up $state.contains() as it's used a lot
    includes: function(state) {
      var includes = state.parent ? extend({}, state.parent.includes) : {};
      includes[state.name] = true;
      return includes;
    },

    $delegates: {}
  };

  function isRelative(stateName) {
    return stateName.indexOf(".") === 0 || stateName.indexOf("^") === 0;
  }

  function findState(stateOrName, base) {
    var isStr = isString(stateOrName),
        name  = isStr ? stateOrName : stateOrName.name,
        path  = isRelative(name);

    if (path) {
      if (!base) throw new Error("No reference point given for path '"  + name + "'");
      var rel = name.split("."), i = 0, pathLength = rel.length, current = base;

      for (; i < pathLength; i++) {
        if (rel[i] === "" && i === 0) {
          current = base;
          continue;
        }
        if (rel[i] === "^") {
          if (!current.parent) throw new Error("Path '" + name + "' not valid for state '" + base.name + "'");
          current = current.parent;
          continue;
        }
        break;
      }
      rel = rel.slice(i).join(".");
      name = current.name + (current.name && rel ? "." : "") + rel;
    }
    var state = states[name];

    if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {
      return state;
    }
    return undefined;
  }

  function queueState(parentName, state) {
    if (!queue[parentName]) {
      queue[parentName] = [];
    }
    queue[parentName].push(state);
  }

  function registerState(state) {
    // Wrap a new object around the state so we can store our private details easily.
    state = inherit(state, {
      self: state,
      resolve: state.resolve || {},
      toString: function() { return this.name; }
    });

    var name = state.name;
    if (!isString(name) || name.indexOf('@') >= 0) throw new Error("State must have a valid name");
    if (states.hasOwnProperty(name)) throw new Error("State '" + name + "'' is already defined");

    // Get parent name
    var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.'))
        : (isString(state.parent)) ? state.parent
        : '';

    // If parent is not registered yet, add state to queue and register later
    if (parentName && !states[parentName]) {
      return queueState(parentName, state.self);
    }

    for (var key in stateBuilder) {
      if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);
    }
    states[name] = state;

    // Register the state in the global state list and with $urlRouter if necessary.
    if (!state[abstractKey] && state.url) {
      $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {
        if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {
          $state.transitionTo(state, $match, { location: false });
        }
      }]);
    }

    // Register any queued children
    if (queue[name]) {
      for (var i = 0; i < queue[name].length; i++) {
        registerState(queue[name][i]);
      }
    }

    return state;
  }

  // Checks text to see if it looks like a glob.
  function isGlob (text) {
    return text.indexOf('*') > -1;
  }

  // Returns true if glob matches current $state name.
  function doesStateMatchGlob (glob) {
    var globSegments = glob.split('.'),
        segments = $state.$current.name.split('.');

    //match greedy starts
    if (globSegments[0] === '**') {
       segments = segments.slice(segments.indexOf(globSegments[1]));
       segments.unshift('**');
    }
    //match greedy ends
    if (globSegments[globSegments.length - 1] === '**') {
       segments.splice(segments.indexOf(globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);
       segments.push('**');
    }

    if (globSegments.length != segments.length) {
      return false;
    }

    //match single stars
    for (var i = 0, l = globSegments.length; i < l; i++) {
      if (globSegments[i] === '*') {
        segments[i] = '*';
      }
    }

    return segments.join('') === globSegments.join('');
  }


  // Implicit root state that is always active
  root = registerState({
    name: '',
    url: '^',
    views: null,
    'abstract': true
  });
  root.navigable = null;


  /**
   * @ngdoc function
   * @name ui.router.state.$stateProvider#decorator
   * @methodOf ui.router.state.$stateProvider
   *
   * @description
   * Allows you to extend (carefully) or override (at your own peril) the
   * `stateBuilder` object used internally by `$stateProvider`. This can be used
   * to add custom functionality to ui-router, for example inferring templateUrl
   * based on the state name.
   *
   * When passing only a name, it returns the current (original or decorated) builder
   * function that matches `name`.
   *
   * The builder functions that can be decorated are listed below. Though not all
   * necessarily have a good use case for decoration, that is up to you to decide.
   *
   * In addition, users can attach custom decorators, which will generate new
   * properties within the state's internal definition. There is currently no clear
   * use-case for this beyond accessing internal states (i.e. $state.$current),
   * however, expect this to become increasingly relevant as we introduce additional
   * meta-programming features.
   *
   * **Warning**: Decorators should not be interdependent because the order of
   * execution of the builder functions in non-deterministic. Builder functions
   * should only be dependent on the state definition object and super function.
   *
   *
   * Existing builder functions and current return values:
   *
   * - **parent** `{object}` - returns the parent state object.
   * - **data** `{object}` - returns state data, including any inherited data that is not
   *   overridden by own values (if any).
   * - **url** `{object}` - returns a {link ui.router.util.type:UrlMatcher} or null.
   * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is
   *   navigable).
   * - **params** `{object}` - returns an array of state params that are ensured to
   *   be a super-set of parent's params.
   * - **views** `{object}` - returns a views object where each key is an absolute view
   *   name (i.e. "viewName@stateName") and each value is the config object
   *   (template, controller) for the view. Even when you don't use the views object
   *   explicitly on a state config, one is still created for you internally.
   *   So by decorating this builder function you have access to decorating template
   *   and controller properties.
   * - **ownParams** `{object}` - returns an array of params that belong to the state,
   *   not including any params defined by ancestor states.
   * - **path** `{string}` - returns the full path from the root down to this state.
   *   Needed for state activation.
   * - **includes** `{object}` - returns an object that includes every state that
   *   would pass a '$state.includes()' test.
   *
   * @example
   * <pre>
   * // Override the internal 'views' builder with a function that takes the state
   * // definition, and a reference to the internal function being overridden:
   * $stateProvider.decorator('views', function ($state, parent) {
   *   var result = {},
   *       views = parent(state);
   *
   *   angular.forEach(view, function (config, name) {
   *     var autoName = (state.name + '.' + name).replace('.', '/');
   *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';
   *     result[name] = config;
   *   });
   *   return result;
   * });
   *
   * $stateProvider.state('home', {
   *   views: {
   *     'contact.list': { controller: 'ListController' },
   *     'contact.item': { controller: 'ItemController' }
   *   }
   * });
   *
   * // ...
   *
   * $state.go('home');
   * // Auto-populates list and item views with /partials/home/contact/list.html,
   * // and /partials/home/contact/item.html, respectively.
   * </pre>
   *
   * @param {string} name The name of the builder function to decorate.
   * @param {object} func A function that is responsible for decorating the original
   * builder function. The function receives two parameters:
   *
   *   - `{object}` - state - The state config object.
   *   - `{object}` - super - The original builder function.
   *
   * @return {object} $stateProvider - $stateProvider instance
   */
  this.decorator = decorator;
  function decorator(name, func) {
    /*jshint validthis: true */
    if (isString(name) && !isDefined(func)) {
      return stateBuilder[name];
    }
    if (!isFunction(func) || !isString(name)) {
      return this;
    }
    if (stateBuilder[name] && !stateBuilder.$delegates[name]) {
      stateBuilder.$delegates[name] = stateBuilder[name];
    }
    stateBuilder[name] = func;
    return this;
  }

  /**
   * @ngdoc function
   * @name ui.router.state.$stateProvider#state
   * @methodOf ui.router.state.$stateProvider
   *
   * @description
   * Registers a state configuration under a given state name. The stateConfig object
   * has the following acceptable properties.
   *
   * <a id='template'></a>
   *
   * - **`template`** - {string|function=} - html template as a string or a function that returns
   *   an html template as a string which should be used by the uiView directives. This property
   *   takes precedence over templateUrl.
   *
   *   If `template` is a function, it will be called with the following parameters:
   *
   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by
   *     applying the current state
   *
   * <a id='templateUrl'></a>
   *
   * - **`templateUrl`** - {string|function=} - path or function that returns a path to an html
   *   template that should be used by uiView.
   *
   *   If `templateUrl` is a function, it will be called with the following parameters:
   *
   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by
   *     applying the current state
   *
   * <a id='templateProvider'></a>
   *
   * - **`templateProvider`** - {function=} - Provider function that returns HTML content
   *   string.
   *
   * <a id='controller'></a>
   *
   * - **`controller`** - {string|function=} -  Controller fn that should be associated with newly
   *   related scope or the name of a registered controller if passed as a string.
   *
   * <a id='controllerProvider'></a>
   *
   * - **`controllerProvider`** - {function=} - Injectable provider function that returns
   *   the actual controller or string.
   *
   * <a id='controllerAs'></a>
   *
   * - **`controllerAs`** – {string=} – A controller alias name. If present the controller will be
   *   published to scope under the controllerAs name.
   *
   * <a id='resolve'></a>
   *
   * - **`resolve`** - {object.&lt;string, function&gt;=} - An optional map of dependencies which
   *   should be injected into the controller. If any of these dependencies are promises,
   *   the router will wait for them all to be resolved or one to be rejected before the
   *   controller is instantiated. If all the promises are resolved successfully, the values
   *   of the resolved promises are injected and $stateChangeSuccess event is fired. If any
   *   of the promises are rejected the $stateChangeError event is fired. The map object is:
   *
   *   - key - {string}: name of dependency to be injected into controller
   *   - factory - {string|function}: If string then it is alias for service. Otherwise if function,
   *     it is injected and return value it treated as dependency. If result is a promise, it is
   *     resolved before its value is injected into controller.
   *
   * <a id='url'></a>
   *
   * - **`url`** - {string=} - A url with optional parameters. When a state is navigated or
   *   transitioned to, the `$stateParams` service will be populated with any
   *   parameters that were passed.
   *
   * <a id='params'></a>
   *
   * - **`params`** - {object=} - An array of parameter names or regular expressions. Only
   *   use this within a state if you are not using url. Otherwise you can specify your
   *   parameters within the url. When a state is navigated or transitioned to, the
   *   $stateParams service will be populated with any parameters that were passed.
   *
   * <a id='views'></a>
   *
   * - **`views`** - {object=} - Use the views property to set up multiple views or to target views
   *   manually/explicitly.
   *
   * <a id='abstract'></a>
   *
   * - **`abstract`** - {boolean=} - An abstract state will never be directly activated,
   *   but can provide inherited properties to its common children states.
   *
   * <a id='onEnter'></a>
   *
   * - **`onEnter`** - {object=} - Callback function for when a state is entered. Good way
   *   to trigger an action or dispatch an event, such as opening a dialog.
   *
   * <a id='onExit'></a>
   *
   * - **`onExit`** - {object=} - Callback function for when a state is exited. Good way to
   *   trigger an action or dispatch an event, such as opening a dialog.
   *
   * <a id='reloadOnSearch'></a>
   *
   * - **`reloadOnSearch = true`** - {boolean=} - If `false`, will not retrigger the same state
   *   just because a search/query parameter has changed (via $location.search() or $location.hash()).
   *   Useful for when you'd like to modify $location.search() without triggering a reload.
   *
   * <a id='data'></a>
   *
   * - **`data`** - {object=} - Arbitrary data object, useful for custom configuration.
   *
   * @example
   * <pre>
   * // Some state name examples
   *
   * // stateName can be a single top-level name (must be unique).
   * $stateProvider.state("home", {});
   *
   * // Or it can be a nested state name. This state is a child of the
   * // above "home" state.
   * $stateProvider.state("home.newest", {});
   *
   * // Nest states as deeply as needed.
   * $stateProvider.state("home.newest.abc.xyz.inception", {});
   *
   * // state() returns $stateProvider, so you can chain state declarations.
   * $stateProvider
   *   .state("home", {})
   *   .state("about", {})
   *   .state("contacts", {});
   * </pre>
   *
   * @param {string} name A unique state name, e.g. "home", "about", "contacts".
   * To create a parent/child state use a dot, e.g. "about.sales", "home.newest".
   * @param {object} definition State configuration object.
   */
  this.state = state;
  function state(name, definition) {
    /*jshint validthis: true */
    if (isObject(name)) definition = name;
    else definition.name = name;
    registerState(definition);
    return this;
  }

  /**
   * @ngdoc object
   * @name ui.router.state.$state
   *
   * @requires $rootScope
   * @requires $q
   * @requires ui.router.state.$view
   * @requires $injector
   * @requires ui.router.util.$resolve
   * @requires ui.router.state.$stateParams
   *
   * @property {object} params A param object, e.g. {sectionId: section.id)}, that
   * you'd like to test against the current active state.
   * @property {object} current A reference to the state's config object. However
   * you passed it in. Useful for accessing custom data.
   * @property {object} transition Currently pending transition. A promise that'll
   * resolve or reject.
   *
   * @description
   * `$state` service is responsible for representing states as well as transitioning
   * between them. It also provides interfaces to ask for current state or even states
   * you're coming from.
   */
  // $urlRouter is injected just to ensure it gets instantiated
  this.$get = $get;
  $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$location', '$urlRouter', '$browser'];
  function $get(   $rootScope,   $q,   $view,   $injector,   $resolve,   $stateParams,   $location,   $urlRouter,   $browser) {

    var TransitionSuperseded = $q.reject(new Error('transition superseded'));
    var TransitionPrevented = $q.reject(new Error('transition prevented'));
    var TransitionAborted = $q.reject(new Error('transition aborted'));
    var TransitionFailed = $q.reject(new Error('transition failed'));
    var currentLocation = $location.url();
    var baseHref = $browser.baseHref();

    function syncUrl() {
      if ($location.url() !== currentLocation) {
        $location.url(currentLocation);
        $location.replace();
      }
    }

    root.locals = { resolve: null, globals: { $stateParams: {} } };
    $state = {
      params: {},
      current: root.self,
      $current: root,
      transition: null
    };

    /**
     * @ngdoc function
     * @name ui.router.state.$state#reload
     * @methodOf ui.router.state.$state
     *
     * @description
     * A method that force reloads the current state. All resolves are re-resolved, events are not re-fired,
     * and controllers reinstantiated (bug with controllers reinstantiating right now, fixing soon).
     *
     * @example
     * <pre>
     * var app angular.module('app', ['ui.router']);
     *
     * app.controller('ctrl', function ($scope, $state) {
     *   $scope.reload = function(){
     *     $state.reload();
     *   }
     * });
     * </pre>
     *
     * `reload()` is just an alias for:
     * <pre>
     * $state.transitionTo($state.current, $stateParams, {
     *   reload: true, inherit: false, notify: false
     * });
     * </pre>
     */
    $state.reload = function reload() {
      $state.transitionTo($state.current, $stateParams, { reload: true, inherit: false, notify: false });
    };

    /**
     * @ngdoc function
     * @name ui.router.state.$state#go
     * @methodOf ui.router.state.$state
     *
     * @description
     * Convenience method for transitioning to a new state. `$state.go` calls
     * `$state.transitionTo` internally but automatically sets options to
     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`.
     * This allows you to easily use an absolute or relative to path and specify
     * only the parameters you'd like to update (while letting unspecified parameters
     * inherit from the currently active ancestor states).
     *
     * @example
     * <pre>
     * var app = angular.module('app', ['ui.router']);
     *
     * app.controller('ctrl', function ($scope, $state) {
     *   $scope.changeState = function () {
     *     $state.go('contact.detail');
     *   };
     * });
     * </pre>
     * <img src='../ngdoc_assets/StateGoExamples.png'/>
     *
     * @param {string} to Absolute state name or relative state path. Some examples:
     *
     * - `$state.go('contact.detail')` - will go to the `contact.detail` state
     * - `$state.go('^')` - will go to a parent state
     * - `$state.go('^.sibling')` - will go to a sibling state
     * - `$state.go('.child.grandchild')` - will go to grandchild state
     *
     * @param {object=} params A map of the parameters that will be sent to the state,
     * will populate $stateParams. Any parameters that are not specified will be inherited from currently
     * defined parameters. This allows, for example, going to a sibling state that shares parameters
     * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.
     * transitioning to a sibling will get you the parameters for all parents, transitioning to a child
     * will get you all current parameters, etc.
     * @param {object=} options Options object. The options are:
     *
     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`
     *    will not. If string, must be `"replace"`, which will update url and also replace last history record.
     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.
     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'),
     *    defines which state to be relative from.
     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.
     * - **`reload`** (v0.2.5) - {boolean=false}, If `true` will force transition even if the state or params
     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd
     *    use this when you want to force a reload when *everything* is the same, including search params.
     *
     * @returns {promise} A promise representing the state of the new transition.
     *
     * Possible success values:
     *
     * - $state.current
     *
     * <br/>Possible rejection values:
     *
     * - 'transition superseded' - when a newer transition has been started after this one
     * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener
     * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or
     *   when a `$stateNotFound` `event.retry` promise errors.
     * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.
     * - *resolve error* - when an error has occurred with a `resolve`
     *
     */
    $state.go = function go(to, params, options) {
      return this.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));
    };

    /**
     * @ngdoc function
     * @name ui.router.state.$state#transitionTo
     * @methodOf ui.router.state.$state
     *
     * @description
     * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}
     * uses `transitionTo` internally. `$state.go` is recommended in most situations.
     *
     * @example
     * <pre>
     * var app = angular.module('app', ['ui.router']);
     *
     * app.controller('ctrl', function ($scope, $state) {
     *   $scope.changeState = function () {
     *     $state.transitionTo('contact.detail');
     *   };
     * });
     * </pre>
     *
     * @param {string} to State name.
     * @param {object=} toParams A map of the parameters that will be sent to the state,
     * will populate $stateParams.
     * @param {object=} options Options object. The options are:
     *
     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`
     *    will not. If string, must be `"replace"`, which will update url and also replace last history record.
     * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.
     * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'),
     *    defines which state to be relative from.
     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.
     * - **`reload`** (v0.2.5) - {boolean=false}, If `true` will force transition even if the state or params
     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd
     *    use this when you want to force a reload when *everything* is the same, including search params.
     *
     * @returns {promise} A promise representing the state of the new transition. See
     * {@link ui.router.state.$state#methods_go $state.go}.
     */
    $state.transitionTo = function transitionTo(to, toParams, options) {
      toParams = toParams || {};
      options = extend({
        location: true, inherit: false, relative: null, notify: true, reload: false, $retry: false
      }, options || {});

      var from = $state.$current, fromParams = $state.params, fromPath = from.path;
      var evt, toState = findState(to, options.relative);

      if (!isDefined(toState)) {
        // Broadcast not found event and abort the transition if prevented
        var redirect = { to: to, toParams: toParams, options: options };

        /**
         * @ngdoc event
         * @name ui.router.state.$state#$stateNotFound
         * @eventOf ui.router.state.$state
         * @eventType broadcast on root scope
         * @description
         * Fired when a requested state **cannot be found** using the provided state name during transition.
         * The event is broadcast allowing any handlers a single chance to deal with the error (usually by
         * lazy-loading the unfound state). A special `unfoundState` object is passed to the listener handler,
         * you can see its three properties in the example. You can use `event.preventDefault()` to abort the
         * transition and the promise returned from `go` will be rejected with a `'transition aborted'` value.
         *
         * @param {Object} event Event object.
         * @param {Object} unfoundState Unfound State information. Contains: `to, toParams, options` properties.
         * @param {State} fromState Current state object.
         * @param {Object} fromParams Current state params.
         *
         * @example
         *
         * <pre>
         * // somewhere, assume lazy.state has not been defined
         * $state.go("lazy.state", {a:1, b:2}, {inherit:false});
         *
         * // somewhere else
         * $scope.$on('$stateNotFound',
         * function(event, unfoundState, fromState, fromParams){
         *     console.log(unfoundState.to); // "lazy.state"
         *     console.log(unfoundState.toParams); // {a:1, b:2}
         *     console.log(unfoundState.options); // {inherit:false} + default options
         * })
         * </pre>
         */
        evt = $rootScope.$broadcast('$stateNotFound', redirect, from.self, fromParams);
        if (evt.defaultPrevented) {
          syncUrl();
          return TransitionAborted;
        }

        // Allow the handler to return a promise to defer state lookup retry
        if (evt.retry) {
          if (options.$retry) {
            syncUrl();
            return TransitionFailed;
          }
          var retryTransition = $state.transition = $q.when(evt.retry);
          retryTransition.then(function() {
            if (retryTransition !== $state.transition) return TransitionSuperseded;
            redirect.options.$retry = true;
            return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);
          }, function() {
            return TransitionAborted;
          });
          syncUrl();
          return retryTransition;
        }

        // Always retry once if the $stateNotFound was not prevented
        // (handles either redirect changed or state lazy-definition)
        to = redirect.to;
        toParams = redirect.toParams;
        options = redirect.options;
        toState = findState(to, options.relative);
        if (!isDefined(toState)) {
          if (options.relative) throw new Error("Could not resolve '" + to + "' from state '" + options.relative + "'");
          throw new Error("No such state '" + to + "'");
        }
      }
      if (toState[abstractKey]) throw new Error("Cannot transition to abstract state '" + to + "'");
      if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);
      to = toState;

      var toPath = to.path;

      // Starting from the root of the path, keep all levels that haven't changed
      var keep, state, locals = root.locals, toLocals = [];
      for (keep = 0, state = toPath[keep];
           state && state === fromPath[keep] && equalForKeys(toParams, fromParams, state.ownParams) && !options.reload;
           keep++, state = toPath[keep]) {
        locals = toLocals[keep] = state.locals;
      }

      // If we're going to the same state and all locals are kept, we've got nothing to do.
      // But clear 'transition', as we still want to cancel any other pending transitions.
      // TODO: We may not want to bump 'transition' if we're called from a location change that we've initiated ourselves,
      // because we might accidentally abort a legitimate transition initiated from code?
      if (shouldTriggerReload(to, from, locals, options) ) {
        if ( to.self.reloadOnSearch !== false )
          syncUrl();
        $state.transition = null;
        return $q.when($state.current);
      }

      // Normalize/filter parameters before we pass them to event handlers etc.
      toParams = normalize(to.params, toParams || {});

      // Broadcast start event and cancel the transition if requested
      if (options.notify) {
        /**
         * @ngdoc event
         * @name ui.router.state.$state#$stateChangeStart
         * @eventOf ui.router.state.$state
         * @eventType broadcast on root scope
         * @description
         * Fired when the state transition **begins**. You can use `event.preventDefault()`
         * to prevent the transition from happening and then the transition promise will be
         * rejected with a `'transition prevented'` value.
         *
         * @param {Object} event Event object.
         * @param {State} toState The state being transitioned to.
         * @param {Object} toParams The params supplied to the `toState`.
         * @param {State} fromState The current state, pre-transition.
         * @param {Object} fromParams The params supplied to the `fromState`.
         *
         * @example
         *
         * <pre>
         * $rootScope.$on('$stateChangeStart',
         * function(event, toState, toParams, fromState, fromParams){
         *     event.preventDefault();
         *     // transitionTo() promise will be rejected with
         *     // a 'transition prevented' error
         * })
         * </pre>
         */
        evt = $rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams);
        if (evt.defaultPrevented) {
          syncUrl();
          return TransitionPrevented;
        }
      }

      // Resolve locals for the remaining states, but don't update any global state just
      // yet -- if anything fails to resolve the current state needs to remain untouched.
      // We also set up an inheritance chain for the locals here. This allows the view directive
      // to quickly look up the correct definition for each view in the current state. Even
      // though we create the locals object itself outside resolveState(), it is initially
      // empty and gets filled asynchronously. We need to keep track of the promise for the
      // (fully resolved) current locals, and pass this down the chain.
      var resolved = $q.when(locals);
      for (var l=keep; l<toPath.length; l++, state=toPath[l]) {
        locals = toLocals[l] = inherit(locals);
        resolved = resolveState(state, toParams, state===to, resolved, locals);
      }

      // Once everything is resolved, we are ready to perform the actual transition
      // and return a promise for the new state. We also keep track of what the
      // current promise is, so that we can detect overlapping transitions and
      // keep only the outcome of the last transition.
      var transition = $state.transition = resolved.then(function () {
        var l, entering, exiting;

        if ($state.transition !== transition) return TransitionSuperseded;

        // Exit 'from' states not kept
        for (l=fromPath.length-1; l>=keep; l--) {
          exiting = fromPath[l];
          if (exiting.self.onExit) {
            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);
          }
          exiting.locals = null;
        }

        // Enter 'to' states not kept
        for (l=keep; l<toPath.length; l++) {
          entering = toPath[l];
          entering.locals = toLocals[l];
          if (entering.self.onEnter) {
            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);
          }
        }

        // Run it again, to catch any transitions in callbacks
        if ($state.transition !== transition) return TransitionSuperseded;

        // Update globals in $state
        $state.$current = to;
        $state.current = to.self;
        $state.params = toParams;
        copy($state.params, $stateParams);
        $state.transition = null;

        // Update $location
        var toNav = to.navigable;
        if (options.location && toNav) {
          $location.url(toNav.url.format(toNav.locals.globals.$stateParams));

          if (options.location === 'replace') {
            $location.replace();
          }
        }

        if (options.notify) {
        /**
         * @ngdoc event
         * @name ui.router.state.$state#$stateChangeSuccess
         * @eventOf ui.router.state.$state
         * @eventType broadcast on root scope
         * @description
         * Fired once the state transition is **complete**.
         *
         * @param {Object} event Event object.
         * @param {State} toState The state being transitioned to.
         * @param {Object} toParams The params supplied to the `toState`.
         * @param {State} fromState The current state, pre-transition.
         * @param {Object} fromParams The params supplied to the `fromState`.
         */
          $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);
        }
        currentLocation = $location.url();

        return $state.current;
      }, function (error) {
        if ($state.transition !== transition) return TransitionSuperseded;

        $state.transition = null;
        /**
         * @ngdoc event
         * @name ui.router.state.$state#$stateChangeError
         * @eventOf ui.router.state.$state
         * @eventType broadcast on root scope
         * @description
         * Fired when an **error occurs** during transition. It's important to note that if you
         * have any errors in your resolve functions (javascript errors, non-existent services, etc)
         * they will not throw traditionally. You must listen for this $stateChangeError event to
         * catch **ALL** errors.
         *
         * @param {Object} event Event object.
         * @param {State} toState The state being transitioned to.
         * @param {Object} toParams The params supplied to the `toState`.
         * @param {State} fromState The current state, pre-transition.
         * @param {Object} fromParams The params supplied to the `fromState`.
         * @param {Error} error The resolve error object.
         */
        $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);
        syncUrl();

        return $q.reject(error);
      });

      return transition;
    };

    /**
     * @ngdoc function
     * @name ui.router.state.$state#is
     * @methodOf ui.router.state.$state
     *
     * @description
     * Similar to {@link ui.router.state.$state#methods_includes $state.includes},
     * but only checks for the full state name. If params is supplied then it will be
     * tested for strict equality against the current active params object, so all params
     * must match with none missing and no extras.
     *
     * @example
     * <pre>
     * $state.is('contact.details.item'); // returns true
     * $state.is(contactDetailItemStateObject); // returns true
     *
     * // everything else would return false
     * </pre>
     *
     * @param {string|object} stateName The state name or state object you'd like to check.
     * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like
     * to test against the current active state.
     * @returns {boolean} Returns true if it is the state.
     */
    $state.is = function is(stateOrName, params) {
      var state = findState(stateOrName);

      if (!isDefined(state)) {
        return undefined;
      }

      if ($state.$current !== state) {
        return false;
      }

      return isDefined(params) && params !== null ? angular.equals($stateParams, params) : true;
    };

    /**
     * @ngdoc function
     * @name ui.router.state.$state#includes
     * @methodOf ui.router.state.$state
     *
     * @description
     * A method to determine if the current active state is equal to or is the child of the
     * state stateName. If any params are passed then they will be tested for a match as well.
     * Not all the parameters need to be passed, just the ones you'd like to test for equality.
     *
     * @example
     * <pre>
     * $state.$current.name = 'contacts.details.item';
     *
     * $state.includes("contacts"); // returns true
     * $state.includes("contacts.details"); // returns true
     * $state.includes("contacts.details.item"); // returns true
     * $state.includes("contacts.list"); // returns false
     * $state.includes("about"); // returns false
     * </pre>
     *
     * @description
     * Basic globing patterns will also work.
     *
     * @example
     * <pre>
     * $state.$current.name = 'contacts.details.item.url';
     *
     * $state.includes("*.details.*.*"); // returns true
     * $state.includes("*.details.**"); // returns true
     * $state.includes("**.item.**"); // returns true
     * $state.includes("*.details.item.url"); // returns true
     * $state.includes("*.details.*.url"); // returns true
     * $state.includes("*.details.*"); // returns false
     * $state.includes("item.**"); // returns false
     * </pre>
     *
     * @param {string} stateOrName A partial name to be searched for within the current state name.
     * @param {object} params A param object, e.g. `{sectionId: section.id}`,
     * that you'd like to test against the current active state.
     * @returns {boolean} Returns true if it does include the state
     */

    $state.includes = function includes(stateOrName, params) {
      if (isString(stateOrName) && isGlob(stateOrName)) {
        if (doesStateMatchGlob(stateOrName)) {
          stateOrName = $state.$current.name;
        } else {
          return false;
        }
      }

      var state = findState(stateOrName);
      if (!isDefined(state)) {
        return undefined;
      }

      if (!isDefined($state.$current.includes[state.name])) {
        return false;
      }

      var validParams = true;
      angular.forEach(params, function(value, key) {
        if (!isDefined($stateParams[key]) || $stateParams[key] !== value) {
          validParams = false;
        }
      });
      return validParams;
    };


    /**
     * @ngdoc function
     * @name ui.router.state.$state#href
     * @methodOf ui.router.state.$state
     *
     * @description
     * A url generation method that returns the compiled url for the given state populated with the given params.
     *
     * @example
     * <pre>
     * expect($state.href("about.person", { person: "bob" })).toEqual("/about/bob");
     * </pre>
     *
     * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.
     * @param {object=} params An object of parameter values to fill the state's required parameters.
     * @param {object=} options Options object. The options are:
     *
     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the
     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka
     *    ancestor with a valid url).
     * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.
     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'),
     *    defines which state to be relative from.
     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. "http://www.example.com/fullurl".
     *
     * @returns {string} compiled state url
     */
    $state.href = function href(stateOrName, params, options) {
      options = extend({ lossy: true, inherit: false, absolute: false, relative: $state.$current }, options || {});
      var state = findState(stateOrName, options.relative);
      if (!isDefined(state)) return null;

      params = inheritParams($stateParams, params || {}, $state.$current, state);
      var nav = (state && options.lossy) ? state.navigable : state;
      var url = (nav && nav.url) ? nav.url.format(normalize(state.params, params || {})) : null;
      if (!$locationProvider.html5Mode() && url) {
        url = "#" + $locationProvider.hashPrefix() + url;
      }

      if (baseHref !== '/') {
        if ($locationProvider.html5Mode()) {
          url = baseHref.slice(0, -1) + url;
        } else if (options.absolute){
          url = baseHref.slice(1) + url;
        }
      }

      if (options.absolute && url) {
        url = $location.protocol() + '://' +
              $location.host() +
              ($location.port() == 80 || $location.port() == 443 ? '' : ':' + $location.port()) +
              (!$locationProvider.html5Mode() && url ? '/' : '') +
              url;
      }
      return url;
    };

    /**
     * @ngdoc function
     * @name ui.router.state.$state#get
     * @methodOf ui.router.state.$state
     *
     * @description
     * Returns the state configuration object for any specific state or all states.
     *
     * @param {string|object=} stateOrName If provided, will only get the config for
     * the requested state. If not provided, returns an array of ALL state configs.
     * @returns {object|array} State configuration object or array of all objects.
     */
    $state.get = function (stateOrName, context) {
      if (!isDefined(stateOrName)) {
        var list = [];
        forEach(states, function(state) { list.push(state.self); });
        return list;
      }
      var state = findState(stateOrName, context);
      return (state && state.self) ? state.self : null;
    };

    function resolveState(state, params, paramsAreFiltered, inherited, dst) {
      // Make a restricted $stateParams with only the parameters that apply to this state if
      // necessary. In addition to being available to the controller and onEnter/onExit callbacks,
      // we also need $stateParams to be available for any $injector calls we make during the
      // dependency resolution process.
      var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params, params);
      var locals = { $stateParams: $stateParams };

      // Resolve 'global' dependencies for the state, i.e. those not specific to a view.
      // We're also including $stateParams in this; that way the parameters are restricted
      // to the set that should be visible to the state, and are independent of when we update
      // the global $state and $stateParams values.
      dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);
      var promises = [ dst.resolve.then(function (globals) {
        dst.globals = globals;
      }) ];
      if (inherited) promises.push(inherited);

      // Resolve template and dependencies for all views.
      forEach(state.views, function (view, name) {
        var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});
        injectables.$template = [ function () {
          return $view.load(name, { view: view, locals: locals, params: $stateParams, notify: false }) || '';
        }];

        promises.push($resolve.resolve(injectables, locals, dst.resolve, state).then(function (result) {
          // References to the controller (only instantiated at link time)
          if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {
            var injectLocals = angular.extend({}, injectables, locals);
            result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);
          } else {
            result.$$controller = view.controller;
          }
          // Provide access to the state itself for internal use
          result.$$state = state;
          result.$$controllerAs = view.controllerAs;
          dst[name] = result;
        }));
      });

      // Wait for all the promises and then return the activation object
      return $q.all(promises).then(function (values) {
        return dst;
      });
    }

    return $state;
  }

  function shouldTriggerReload(to, from, locals, options) {
    if ( to === from && ((locals === from.locals && !options.reload) || (to.self.reloadOnSearch === false)) ) {
      return true;
    }
  }
}

angular.module('ui.router.state')
  .value('$stateParams', {})
  .provider('$state', $StateProvider);


$ViewProvider.$inject = [];
function $ViewProvider() {

  this.$get = $get;
  /**
   * @ngdoc object
   * @name ui.router.state.$view
   *
   * @requires ui.router.util.$templateFactory
   * @requires $rootScope
   *
   * @description
   *
   */
  $get.$inject = ['$rootScope', '$templateFactory'];
  function $get(   $rootScope,   $templateFactory) {
    return {
      // $view.load('full.viewName', { template: ..., controller: ..., resolve: ..., async: false, params: ... })
      /**
       * @ngdoc function
       * @name ui.router.state.$view#load
       * @methodOf ui.router.state.$view
       *
       * @description
       *
       * @param {string} name name
       * @param {object} options option object.
       */
      load: function load(name, options) {
        var result, defaults = {
          template: null, controller: null, view: null, locals: null, notify: true, async: true, params: {}
        };
        options = extend(defaults, options);

        if (options.view) {
          result = $templateFactory.fromConfig(options.view, options.params, options.locals);
        }
        if (result && options.notify) {
        /**
         * @ngdoc event
         * @name ui.router.state.$state#$viewContentLoading
         * @eventOf ui.router.state.$view
         * @eventType broadcast on root scope
         * @description
         *
         * Fired once the view **begins loading**, *before* the DOM is rendered.
         *
         * @param {Object} event Event object.
         * @param {Object} viewConfig The view config properties (template, controller, etc).
         *
         * @example
         *
         * <pre>
         * $scope.$on('$viewContentLoading',
         * function(event, viewConfig){
         *     // Access to all the view config properties.
         *     // and one special property 'targetView'
         *     // viewConfig.targetView
         * });
         * </pre>
         */
          $rootScope.$broadcast('$viewContentLoading', options);
        }
        return result;
      }
    };
  }
}

angular.module('ui.router.state').provider('$view', $ViewProvider);

/**
 * @ngdoc object
 * @name ui.router.state.$uiViewScrollProvider
 *
 * @description
 * Provider that returns the {@link ui.router.state.$uiViewScroll} service function.
 */
function $ViewScrollProvider() {

  var useAnchorScroll = false;

  /**
   * @ngdoc function
   * @name ui.router.state.$uiViewScrollProvider#useAnchorScroll
   * @methodOf ui.router.state.$uiViewScrollProvider
   *
   * @description
   * Reverts back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll) service for
   * scrolling based on the url anchor.
   */
  this.useAnchorScroll = function () {
    useAnchorScroll = true;
  };

  /**
   * @ngdoc object
   * @name ui.router.state.$uiViewScroll
   *
   * @requires $anchorScroll
   * @requires $timeout
   *
   * @description
   * When called with a jqLite element, it scrolls the element into view (after a
   * `$timeout` so the DOM has time to refresh).
   *
   * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,
   * this can be enabled by calling {@link ui.router.state.$uiViewScrollProvider#methods_useAnchorScroll `$uiViewScrollProvider.useAnchorScroll()`}.
   */
  this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {
    if (useAnchorScroll) {
      return $anchorScroll;
    }

    return function ($element) {
      $timeout(function () {
        $element[0].scrollIntoView();
      }, 0, false);
    };
  }];
}

angular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);

/**
 * @ngdoc directive
 * @name ui.router.state.directive:ui-view
 *
 * @requires ui.router.state.$state
 * @requires $compile
 * @requires $controller
 * @requires $injector
 * @requires ui.router.state.$uiViewScroll
 * @requires $document
 *
 * @restrict ECA
 *
 * @description
 * The ui-view directive tells $state where to place your templates.
 *
 * @param {string=} ui-view A view name. The name should be unique amongst the other views in the
 * same state. You can have views of the same name that live in different states.
 *
 * @param {string=} autoscroll It allows you to set the scroll behavior of the browser window
 * when a view is populated. By default, $anchorScroll is overridden by ui-router's custom scroll
 * service, {@link ui.router.state.$uiViewScroll}. This custom service let's you
 * scroll ui-view elements into view when they are populated during a state activation.
 *
 * *Note: To revert back to old [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)
 * functionality, call `$uiViewScrollProvider.useAnchorScroll()`.*
 *
 * @param {string=} onload Expression to evaluate whenever the view updates.
 *
 * @example
 * A view can be unnamed or named.
 * <pre>
 * <!-- Unnamed -->
 * <div ui-view></div>
 *
 * <!-- Named -->
 * <div ui-view="viewName"></div>
 * </pre>
 *
 * You can only have one unnamed view within any template (or root html). If you are only using a
 * single view and it is unnamed then you can populate it like so:
 * <pre>
 * <div ui-view></div>
 * $stateProvider.state("home", {
 *   template: "<h1>HELLO!</h1>"
 * })
 * </pre>
 *
 * The above is a convenient shortcut equivalent to specifying your view explicitly with the {@link ui.router.state.$stateProvider#views `views`}
 * config property, by name, in this case an empty name:
 * <pre>
 * $stateProvider.state("home", {
 *   views: {
 *     "": {
 *       template: "<h1>HELLO!</h1>"
 *     }
 *   }
 * })
 * </pre>
 *
 * But typically you'll only use the views property if you name your view or have more than one view
 * in the same template. There's not really a compelling reason to name a view if its the only one,
 * but you could if you wanted, like so:
 * <pre>
 * <div ui-view="main"></div>
 * </pre>
 * <pre>
 * $stateProvider.state("home", {
 *   views: {
 *     "main": {
 *       template: "<h1>HELLO!</h1>"
 *     }
 *   }
 * })
 * </pre>
 *
 * Really though, you'll use views to set up multiple views:
 * <pre>
 * <div ui-view></div>
 * <div ui-view="chart"></div>
 * <div ui-view="data"></div>
 * </pre>
 *
 * <pre>
 * $stateProvider.state("home", {
 *   views: {
 *     "": {
 *       template: "<h1>HELLO!</h1>"
 *     },
 *     "chart": {
 *       template: "<chart_thing/>"
 *     },
 *     "data": {
 *       template: "<data_thing/>"
 *     }
 *   }
 * })
 * </pre>
 *
 * Examples for `autoscroll`:
 *
 * <pre>
 * <!-- If autoscroll present with no expression,
 *      then scroll ui-view into view -->
 * <ui-view autoscroll/>
 *
 * <!-- If autoscroll present with valid expression,
 *      then scroll ui-view into view if expression evaluates to true -->
 * <ui-view autoscroll='true'/>
 * <ui-view autoscroll='false'/>
 * <ui-view autoscroll='scopeVariable'/>
 * </pre>
 */
$ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll'];
function $ViewDirective(   $state,   $injector,   $uiViewScroll) {

  function getService() {
    return ($injector.has) ? function(service) {
      return $injector.has(service) ? $injector.get(service) : null;
    } : function(service) {
      try {
        return $injector.get(service);
      } catch (e) {
        return null;
      }
    };
  }

  var service = getService(),
      $animator = service('$animator'),
      $animate = service('$animate');

  // Returns a set of DOM manipulation functions based on which Angular version
  // it should use
  function getRenderer(attrs, scope) {
    var statics = function() {
      return {
        enter: function (element, target, cb) { target.after(element); cb(); },
        leave: function (element, cb) { element.remove(); cb(); }
      };
    };

    if ($animate) {
      return {
        enter: function(element, target, cb) { $animate.enter(element, null, target, cb); },
        leave: function(element, cb) { $animate.leave(element, cb); }
      };
    }

    if ($animator) {
      var animate = $animator && $animator(scope, attrs);

      return {
        enter: function(element, target, cb) {animate.enter(element, null, target); cb(); },
        leave: function(element, cb) { animate.leave(element); cb(); }
      };
    }

    return statics();
  }

  var directive = {
    restrict: 'ECA',
    terminal: true,
    priority: 400,
    transclude: 'element',
    compile: function (tElement, tAttrs, $transclude) {
      return function (scope, $element, attrs) {
        var previousEl, currentEl, currentScope, latestLocals,
            onloadExp     = attrs.onload || '',
            autoScrollExp = attrs.autoscroll,
            renderer      = getRenderer(attrs, scope);

        scope.$on('$stateChangeSuccess', function() {
          updateView(false);
        });
        scope.$on('$viewContentLoading', function() {
          updateView(false);
        });

        updateView(true);

        function cleanupLastView() {
          if (previousEl) {
            previousEl.remove();
            previousEl = null;
          }

          if (currentScope) {
            currentScope.$destroy();
            currentScope = null;
          }

          if (currentEl) {
            renderer.leave(currentEl, function() {
              previousEl = null;
            });

            previousEl = currentEl;
            currentEl = null;
          }
        }

        function updateView(firstTime) {
          var newScope        = scope.$new(),
              name            = currentEl && currentEl.data('$uiViewName'),
              previousLocals  = name && $state.$current && $state.$current.locals[name];

          if (!firstTime && previousLocals === latestLocals) return; // nothing to do

          var clone = $transclude(newScope, function(clone) {
            renderer.enter(clone, $element, function onUiViewEnter() {
              if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {
                $uiViewScroll(clone);
              }
            });
            cleanupLastView();
          });

          latestLocals = $state.$current.locals[clone.data('$uiViewName')];

          currentEl = clone;
          currentScope = newScope;
          /**
           * @ngdoc event
           * @name ui.router.state.directive:ui-view#$viewContentLoaded
           * @eventOf ui.router.state.directive:ui-view
           * @eventType emits on ui-view directive scope
           * @description           *
           * Fired once the view is **loaded**, *after* the DOM is rendered.
           *
           * @param {Object} event Event object.
           */
          currentScope.$emit('$viewContentLoaded');
          currentScope.$eval(onloadExp);
        }
      };
    }
  };

  return directive;
}

$ViewDirectiveFill.$inject = ['$compile', '$controller', '$state'];
function $ViewDirectiveFill ($compile, $controller, $state) {
  return {
    restrict: 'ECA',
    priority: -400,
    compile: function (tElement) {
      var initial = tElement.html();
      return function (scope, $element, attrs) {
        var name      = attrs.uiView || attrs.name || '',
            inherited = $element.inheritedData('$uiView');

        if (name.indexOf('@') < 0) {
          name = name + '@' + (inherited ? inherited.state.name : '');
        }

        $element.data('$uiViewName', name);

        var current = $state.$current,
            locals  = current && current.locals[name];

        if (! locals) {
          return;
        }

        $element.data('$uiView', { name: name, state: locals.$$state });
        $element.html(locals.$template ? locals.$template : initial);

        var link = $compile($element.contents());

        if (locals.$$controller) {
          locals.$scope = scope;
          var controller = $controller(locals.$$controller, locals);
          if (locals.$$controllerAs) {
            scope[locals.$$controllerAs] = controller;
          }
          $element.data('$ngControllerController', controller);
          $element.children().data('$ngControllerController', controller);
        }

        link(scope);
      };
    }
  };
}

angular.module('ui.router.state').directive('uiView', $ViewDirective);
angular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);

function parseStateRef(ref) {
  var parsed = ref.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/);
  if (!parsed || parsed.length !== 4) throw new Error("Invalid state ref '" + ref + "'");
  return { state: parsed[1], paramExpr: parsed[3] || null };
}

function stateContext(el) {
  var stateData = el.parent().inheritedData('$uiView');

  if (stateData && stateData.state && stateData.state.name) {
    return stateData.state;
  }
}

/**
 * @ngdoc directive
 * @name ui.router.state.directive:ui-sref
 *
 * @requires ui.router.state.$state
 * @requires $timeout
 *
 * @restrict A
 *
 * @description
 * A directive that binds a link (`<a>` tag) to a state. If the state has an associated
 * URL, the directive will automatically generate & update the `href` attribute via
 * the {@link ui.router.state.$state#methods_href $state.href()} method. Clicking
 * the link will trigger a state transition with optional parameters.
 *
 * Also middle-clicking, right-clicking, and ctrl-clicking on the link will be
 * handled natively by the browser.
 *
 * You can also use relative state paths within ui-sref, just like the relative
 * paths passed to `$state.go()`. You just need to be aware that the path is relative
 * to the state that the link lives in, in other words the state that loaded the
 * template containing the link.
 *
 * You can specify options to pass to {@link ui.router.state.$state#go $state.go()}
 * using the `ui-sref-opts` attribute. Options are restricted to `location`, `inherit`,
 * and `reload`.
 *
 * @example
 * Here's an example of how you'd use ui-sref and how it would compile. If you have the
 * following template:
 * <pre>
 * <a ui-sref="home">Home</a> | <a ui-sref="about">About</a>
 *
 * <ul>
 *     <li ng-repeat="contact in contacts">
 *         <a ui-sref="contacts.detail({ id: contact.id })">{{ contact.name }}</a>
 *     </li>
 * </ul>
 * </pre>
 *
 * Then the compiled html would be (assuming Html5Mode is off):
 * <pre>
 * <a href="#/home" ui-sref="home">Home</a> | <a href="#/about" ui-sref="about">About</a>
 *
 * <ul>
 *     <li ng-repeat="contact in contacts">
 *         <a href="#/contacts/1" ui-sref="contacts.detail({ id: contact.id })">Joe</a>
 *     </li>
 *     <li ng-repeat="contact in contacts">
 *         <a href="#/contacts/2" ui-sref="contacts.detail({ id: contact.id })">Alice</a>
 *     </li>
 *     <li ng-repeat="contact in contacts">
 *         <a href="#/contacts/3" ui-sref="contacts.detail({ id: contact.id })">Bob</a>
 *     </li>
 * </ul>
 *
 * <a ui-sref="home" ui-sref-opts="{reload: true}">Home</a>
 * </pre>
 *
 * @param {string} ui-sref 'stateName' can be any valid absolute or relative state
 * @param {Object} ui-sref-opts options to pass to {@link ui.router.state.$state#go $state.go()}
 */
$StateRefDirective.$inject = ['$state', '$timeout'];
function $StateRefDirective($state, $timeout) {
  var allowedOptions = ['location', 'inherit', 'reload'];

  return {
    restrict: 'A',
    require: '?^uiSrefActive',
    link: function(scope, element, attrs, uiSrefActive) {
      var ref = parseStateRef(attrs.uiSref);
      var params = null, url = null, base = stateContext(element) || $state.$current;
      var isForm = element[0].nodeName === "FORM";
      var attr = isForm ? "action" : "href", nav = true;

      var options = {
        relative: base
      };
      var optionsOverride = scope.$eval(attrs.uiSrefOpts) || {};
      angular.forEach(allowedOptions, function(option) {
        if (option in optionsOverride) {
          options[option] = optionsOverride[option];
        }
      });

      var update = function(newVal) {
        if (newVal) params = newVal;
        if (!nav) return;

        var newHref = $state.href(ref.state, params, options);

        if (uiSrefActive) {
          uiSrefActive.$$setStateInfo(ref.state, params);
        }
        if (!newHref) {
          nav = false;
          return false;
        }
        element[0][attr] = newHref;
      };

      if (ref.paramExpr) {
        scope.$watch(ref.paramExpr, function(newVal, oldVal) {
          if (newVal !== params) update(newVal);
        }, true);
        params = scope.$eval(ref.paramExpr);
      }
      update();

      if (isForm) return;

      element.bind("click", function(e) {
        var button = e.which || e.button;
        if ( !(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || element.attr('target')) ) {
          // HACK: This is to allow ng-clicks to be processed before the transition is initiated:
          $timeout(function() {
            $state.go(ref.state, params, options);
          });
          e.preventDefault();
        }
      });
    }
  };
}

/**
 * @ngdoc directive
 * @name ui.router.state.directive:ui-sref-active
 *
 * @requires ui.router.state.$state
 * @requires ui.router.state.$stateParams
 * @requires $interpolate
 *
 * @restrict A
 *
 * @description
 * A directive working alongside ui-sref to add classes to an element when the
 * related ui-sref directive's state is active, and removing them when it is inactive.
 * The primary use-case is to simplify the special appearance of navigation menus
 * relying on `ui-sref`, by having the "active" state's menu button appear different,
 * distinguishing it from the inactive menu items.
 *
 * @example
 * Given the following template:
 * <pre>
 * <ul>
 *   <li ui-sref-active="active" class="item">
 *     <a href ui-sref="app.user({user: 'bilbobaggins'})">@bilbobaggins</a>
 *   </li>
 * </ul>
 * </pre>
 *
 * When the app state is "app.user", and contains the state parameter "user" with value "bilbobaggins",
 * the resulting HTML will appear as (note the 'active' class):
 * <pre>
 * <ul>
 *   <li ui-sref-active="active" class="item active">
 *     <a ui-sref="app.user({user: 'bilbobaggins'})" href="/users/bilbobaggins">@bilbobaggins</a>
 *   </li>
 * </ul>
 * </pre>
 *
 * The class name is interpolated **once** during the directives link time (any further changes to the
 * interpolated value are ignored).
 *
 * Multiple classes may be specified in a space-separated format:
 * <pre>
 * <ul>
 *   <li ui-sref-active='class1 class2 class3'>
 *     <a ui-sref="app.user">link</a>
 *   </li>
 * </ul>
 * </pre>
 */
$StateActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];
function $StateActiveDirective($state, $stateParams, $interpolate) {
  return {
    restrict: "A",
    controller: ['$scope', '$element', '$attrs', function($scope, $element, $attrs) {
      var state, params, activeClass;

      // There probably isn't much point in $observing this
      activeClass = $interpolate($attrs.uiSrefActive || '', false)($scope);

      // Allow uiSref to communicate with uiSrefActive
      this.$$setStateInfo = function(newState, newParams) {
        state = $state.get(newState, stateContext($element));
        params = newParams;
        update();
      };

      $scope.$on('$stateChangeSuccess', update);

      // Update route state
      function update() {
        if ($state.$current.self === state && matchesParams()) {
          $element.addClass(activeClass);
        } else {
          $element.removeClass(activeClass);
        }
      }

      function matchesParams() {
        return !params || equalForKeys(params, $stateParams);
      }
    }]
  };
}

angular.module('ui.router.state')
  .directive('uiSref', $StateRefDirective)
  .directive('uiSrefActive', $StateActiveDirective);

/**
 * @ngdoc filter
 * @name ui.router.state.filter:isState
 *
 * @requires ui.router.state.$state
 *
 * @description
 * Translates to {@link ui.router.state.$state#methods_is $state.is("stateName")}.
 */
$IsStateFilter.$inject = ['$state'];
function $IsStateFilter($state) {
  return function(state) {
    return $state.is(state);
  };
}

/**
 * @ngdoc filter
 * @name ui.router.state.filter:includedByState
 *
 * @requires ui.router.state.$state
 *
 * @description
 * Translates to {@link ui.router.state.$state#methods_includes $state.includes('fullOrPartialStateName')}.
 */
$IncludedByStateFilter.$inject = ['$state'];
function $IncludedByStateFilter($state) {
  return function(state) {
    return $state.includes(state);
  };
}

angular.module('ui.router.state')
  .filter('isState', $IsStateFilter)
  .filter('includedByState', $IncludedByStateFilter);

/*
 * @ngdoc object
 * @name ui.router.compat.$routeProvider
 *
 * @requires ui.router.state.$stateProvider
 * @requires ui.router.router.$urlRouterProvider
 *
 * @description
 * `$routeProvider` of the `ui.router.compat` module overwrites the existing
 * `routeProvider` from the core. This is done to provide compatibility between
 * the UI Router and the core router.
 *
 * It also provides a `when()` method to register routes that map to certain urls.
 * Behind the scenes it actually delegates either to
 * {@link ui.router.router.$urlRouterProvider $urlRouterProvider} or to the
 * {@link ui.router.state.$stateProvider $stateProvider} to postprocess the given
 * router definition object.
 */
$RouteProvider.$inject = ['$stateProvider', '$urlRouterProvider'];
function $RouteProvider(  $stateProvider,    $urlRouterProvider) {

  var routes = [];

  onEnterRoute.$inject = ['$$state'];
  function onEnterRoute(   $$state) {
    /*jshint validthis: true */
    this.locals = $$state.locals.globals;
    this.params = this.locals.$stateParams;
  }

  function onExitRoute() {
    /*jshint validthis: true */
    this.locals = null;
    this.params = null;
  }

  this.when = when;
  /*
   * @ngdoc function
   * @name ui.router.compat.$routeProvider#when
   * @methodOf ui.router.compat.$routeProvider
   *
   * @description
   * Registers a route with a given route definition object. The route definition
   * object has the same interface the angular core route definition object has.
   *
   * @example
   * <pre>
   * var app = angular.module('app', ['ui.router.compat']);
   *
   * app.config(function ($routeProvider) {
   *   $routeProvider.when('home', {
   *     controller: function () { ... },
   *     templateUrl: 'path/to/template'
   *   });
   * });
   * </pre>
   *
   * @param {string} url URL as string
   * @param {object} route Route definition object
   *
   * @return {object} $routeProvider - $routeProvider instance
   */
  function when(url, route) {
    /*jshint validthis: true */
    if (route.redirectTo != null) {
      // Redirect, configure directly on $urlRouterProvider
      var redirect = route.redirectTo, handler;
      if (isString(redirect)) {
        handler = redirect; // leave $urlRouterProvider to handle
      } else if (isFunction(redirect)) {
        // Adapt to $urlRouterProvider API
        handler = function (params, $location) {
          return redirect(params, $location.path(), $location.search());
        };
      } else {
        throw new Error("Invalid 'redirectTo' in when()");
      }
      $urlRouterProvider.when(url, handler);
    } else {
      // Regular route, configure as state
      $stateProvider.state(inherit(route, {
        parent: null,
        name: 'route:' + encodeURIComponent(url),
        url: url,
        onEnter: onEnterRoute,
        onExit: onExitRoute
      }));
    }
    routes.push(route);
    return this;
  }

  /*
   * @ngdoc object
   * @name ui.router.compat.$route
   *
   * @requires ui.router.state.$state
   * @requires $rootScope
   * @requires $routeParams
   *
   * @property {object} routes - Array of registered routes.
   * @property {object} params - Current route params as object.
   * @property {string} current - Name of the current route.
   *
   * @description
   * The `$route` service provides interfaces to access defined routes. It also let's
   * you access route params through `$routeParams` service, so you have fully
   * control over all the stuff you would actually get from angular's core `$route`
   * service.
   */
  this.$get = $get;
  $get.$inject = ['$state', '$rootScope', '$routeParams'];
  function $get(   $state,   $rootScope,   $routeParams) {

    var $route = {
      routes: routes,
      params: $routeParams,
      current: undefined
    };

    function stateAsRoute(state) {
      return (state.name !== '') ? state : undefined;
    }

    $rootScope.$on('$stateChangeStart', function (ev, to, toParams, from, fromParams) {
      $rootScope.$broadcast('$routeChangeStart', stateAsRoute(to), stateAsRoute(from));
    });

    $rootScope.$on('$stateChangeSuccess', function (ev, to, toParams, from, fromParams) {
      $route.current = stateAsRoute(to);
      $rootScope.$broadcast('$routeChangeSuccess', stateAsRoute(to), stateAsRoute(from));
      copy(toParams, $route.params);
    });

    $rootScope.$on('$stateChangeError', function (ev, to, toParams, from, fromParams, error) {
      $rootScope.$broadcast('$routeChangeError', stateAsRoute(to), stateAsRoute(from), error);
    });

    return $route;
  }
}

angular.module('ui.router.compat')
  .provider('$route', $RouteProvider)
  .directive('ngView', $ViewDirective);
})(window, window.angular);
/*
 jQuery UI Sortable plugin wrapper

 @param [ui-sortable] {object} Options to pass to $.fn.sortable() merged onto ui.config
 */
angular.module('ui.sortable', [])
  .value('uiSortableConfig',{})
  .directive('uiSortable', [
    'uiSortableConfig', '$timeout', '$log',
    function(uiSortableConfig, $timeout, $log) {
      return {
        require: '?ngModel',
        link: function(scope, element, attrs, ngModel) {
          var savedNodes;

          function combineCallbacks(first,second){
            if(second && (typeof second === 'function')) {
              return function(e, ui) {
                first(e, ui);
                second(e, ui);
              };
            }
            return first;
          }

          function hasSortingHelper (element, ui) {
            var helperOption = element.sortable('option','helper');
            return helperOption === 'clone' || (typeof helperOption === 'function' && ui.item.sortable.isCustomHelperUsed());
          }

          var opts = {};

          var callbacks = {
            receive: null,
            remove:null,
            start:null,
            stop:null,
            update:null
          };

          var wrappers = {
            helper: null
          };

          angular.extend(opts, uiSortableConfig, scope.$eval(attrs.uiSortable));

          if (!angular.element.fn || !angular.element.fn.jquery) {
            $log.error('ui.sortable: jQuery should be included before AngularJS!');
            return;
          }

          if (ngModel) {

            // When we add or remove elements, we need the sortable to 'refresh'
            // so it can find the new/removed elements.
            scope.$watch(attrs.ngModel+'.length', function() {
              // Timeout to let ng-repeat modify the DOM
              $timeout(function() {
                // ensure that the jquery-ui-sortable widget instance
                // is still bound to the directive's element
                if (!!element.data('ui-sortable')) {
                  element.sortable('refresh');
                }
              });
            });

            callbacks.start = function(e, ui) {
              // Save the starting position of dragged item
              ui.item.sortable = {
                index: ui.item.index(),
                cancel: function () {
                  ui.item.sortable._isCanceled = true;
                },
                isCanceled: function () {
                  return ui.item.sortable._isCanceled;
                },
                isCustomHelperUsed: function () {
                  return !!ui.item.sortable._isCustomHelperUsed;
                },
                _isCanceled: false,
                _isCustomHelperUsed: ui.item.sortable._isCustomHelperUsed
              };
            };

            callbacks.activate = function(/*e, ui*/) {
              // We need to make a copy of the current element's contents so
              // we can restore it after sortable has messed it up.
              // This is inside activate (instead of start) in order to save
              // both lists when dragging between connected lists.
              savedNodes = element.contents();

              // If this list has a placeholder (the connected lists won't),
              // don't inlcude it in saved nodes.
              var placeholder = element.sortable('option','placeholder');

              // placeholder.element will be a function if the placeholder, has
              // been created (placeholder will be an object).  If it hasn't
              // been created, either placeholder will be false if no
              // placeholder class was given or placeholder.element will be
              // undefined if a class was given (placeholder will be a string)
              if (placeholder && placeholder.element && typeof placeholder.element === 'function') {
                var phElement = placeholder.element();
                // workaround for jquery ui 1.9.x,
                // not returning jquery collection
                phElement = angular.element(phElement);

                // exact match with the placeholder's class attribute to handle
                // the case that multiple connected sortables exist and
                // the placehoilder option equals the class of sortable items
                var excludes = element.find('[class="' + phElement.attr('class') + '"]');

                savedNodes = savedNodes.not(excludes);
              }
            };

            callbacks.update = function(e, ui) {
              // Save current drop position but only if this is not a second
              // update that happens when moving between lists because then
              // the value will be overwritten with the old value
              if(!ui.item.sortable.received) {
                ui.item.sortable.dropindex = ui.item.index();
                ui.item.sortable.droptarget = ui.item.parent();

                // Cancel the sort (let ng-repeat do the sort for us)
                // Don't cancel if this is the received list because it has
                // already been canceled in the other list, and trying to cancel
                // here will mess up the DOM.
                element.sortable('cancel');
              }

              // Put the nodes back exactly the way they started (this is very
              // important because ng-repeat uses comment elements to delineate
              // the start and stop of repeat sections and sortable doesn't
              // respect their order (even if we cancel, the order of the
              // comments are still messed up).
              if (hasSortingHelper(element, ui) && !ui.item.sortable.received) {
                // restore all the savedNodes except .ui-sortable-helper element
                // (which is placed last). That way it will be garbage collected.
                savedNodes = savedNodes.not(savedNodes.last());
              }
              savedNodes.appendTo(element);

              // If received is true (an item was dropped in from another list)
              // then we add the new item to this list otherwise wait until the
              // stop event where we will know if it was a sort or item was
              // moved here from another list
              if(ui.item.sortable.received && !ui.item.sortable.isCanceled()) {
                scope.$apply(function () {
                  ngModel.$modelValue.splice(ui.item.sortable.dropindex, 0,
                                             ui.item.sortable.moved);
                });
              }
            };

            callbacks.stop = function(e, ui) {
              // If the received flag hasn't be set on the item, this is a
              // normal sort, if dropindex is set, the item was moved, so move
              // the items in the list.
              if(!ui.item.sortable.received &&
                 ('dropindex' in ui.item.sortable) &&
                 !ui.item.sortable.isCanceled()) {

                scope.$apply(function () {
                  ngModel.$modelValue.splice(
                    ui.item.sortable.dropindex, 0,
                    ngModel.$modelValue.splice(ui.item.sortable.index, 1)[0]);
                });
              } else {
                // if the item was not moved, then restore the elements
                // so that the ngRepeat's comment are correct.
                if ((!('dropindex' in ui.item.sortable) || ui.item.sortable.isCanceled()) &&
                    !hasSortingHelper(element, ui)) {
                  savedNodes.appendTo(element);
                }
              }
            };

            callbacks.receive = function(e, ui) {
              // An item was dropped here from another list, set a flag on the
              // item.
              ui.item.sortable.received = true;
            };

            callbacks.remove = function(e, ui) {
              // Workaround for a problem observed in nested connected lists.
              // There should be an 'update' event before 'remove' when moving
              // elements. If the event did not fire, cancel sorting.
              if (!('dropindex' in ui.item.sortable)) {
                element.sortable('cancel');
                ui.item.sortable.cancel();
              }

              // Remove the item from this list's model and copy data into item,
              // so the next list can retrive it
              if (!ui.item.sortable.isCanceled()) {
                scope.$apply(function () {
                  ui.item.sortable.moved = ngModel.$modelValue.splice(
                    ui.item.sortable.index, 1)[0];
                });
              }
            };

            wrappers.helper = function (inner) {
              if (inner && typeof inner === 'function') {
                return function (e, item) {
                  var innerResult = inner(e, item);
                  item.sortable._isCustomHelperUsed = item !== innerResult;
                  return innerResult;
                };
              }
              return inner;
            };

            scope.$watch(attrs.uiSortable, function(newVal /*, oldVal*/) {
              // ensure that the jquery-ui-sortable widget instance
              // is still bound to the directive's element
              if (!!element.data('ui-sortable')) {
                angular.forEach(newVal, function(value, key) {
                  if(callbacks[key]) {
                    if( key === 'stop' ){
                      // call apply after stop
                      value = combineCallbacks(
                        value, function() { scope.$apply(); });
                    }
                    // wrap the callback
                    value = combineCallbacks(callbacks[key], value);
                  } else if (wrappers[key]) {
                    value = wrappers[key](value);
                  }

                  element.sortable('option', key, value);
                });
              }
            }, true);

            angular.forEach(callbacks, function(value, key) {
              opts[key] = combineCallbacks(value, opts[key]);
            });

          } else {
            $log.info('ui.sortable: ngModel not provided!', element);
          }

          // Create sortable
          element.sortable(opts);
        }
      };
    }
  ]);

window.gaiawebcomponents = angular.module("gaiafrontend", ["themeCtrl", "accordion", "bsDateParse", "bsSelect", "bsTimeDatepicker", "bsTooltip", "bsTypeahead", "carouselFix", "closeable", "events", "form", "mpAccordionHeading", "mpAddressNormalizer", "mpAlert", "mpAlerts", "mpAutoCompleteAddresses", "mpAutoCompleteCity", "mpCarousel", "mpCarouselNavigator", "mpCcc", "mpChange", "mpCharts", "mpContactNormalizer", "mpDefaultValueList", "mpDefaultValuesList", "mpDocumentValidator", "mpFancytree", "mpGenie", "mpGraph", "mpGraphBar", "mpGraphPie", "mpGrid", "mpGridActions", "mpGridCrud", "mpGridCrudMultiple", "mpHeader", "mpIban", "mpId", "mpInputAutocomplete", "mpInputCalendar", "mpInputCurrency", "mpInputFile", "mpInputMask", "mpInputNumber", "mpLoading", "mpMessageAdvanced1", "mpMessageAdvanced2", "mpMessageWaiting", "mpMultiFileUpload", "mpMultilist", "mpMultiselect", "mpName", "mpNavbar", "mpNavbarFilter", "mpNumber", "mpOptionsList", "mpRichTextEditor", "mpSelect", "mpSession", "mpSlider", "mpStateModal", "mpTable", "mpTabsSet", "mpTimeDatepicker", "mpToLowerCase", "mpToUpperCase", "mpTooltip", "mpTooltipError", "mpTouch", "mpTree", "mpType", "mpTypeahead", "mpValidations", "mpValuesList", "mpVideo", "mpWysiwyg", "mpZoom", "ngModel", "tabTitle", "utils", "active", "capitalize", "disabled", "exclude", "filterByPath", "formatCurrency", "formatNumber", "plural", "removeWhitespaces", "startFrom", "acrobatReaderSrv", "avoidCacheInterceptor", "browserDetectSrv", "constantsSrv", "cookieSrv", "dataSrv", "documentValidator", "errorInterceptor", "exportDataToCSVSrv", "httpInterceptor", "httpSrv", "i18n", "i18nInterceptor", "language", "localStorageSrv", "loggerSrv", "objectDefSrv", "parallelNavigationSrv", "sessionInterceptor", "sessionStorageSrv", "state", "tbidInterceptor", "theme", "themeInterceptor", "unauthorizedInterceptor", "userSrv", "mgcrea.ngStrap", "ngAnimate", "ngResource", "ngSanitize", "once", "pascalprecht.translate", "reCAPTCHA", "ui.bootstrap", "ui.router", "ui.sortable"]);
window.gaiawebcomponents.version = "1.17.0";
}(window));
